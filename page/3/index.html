<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="祥瑞客栈">
<meta property="og:url" content="http://mackrui.com/page/3/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Collider">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mackrui.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">43</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/23/%E5%85%89%E8%BF%BD1.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/%E5%85%89%E8%BF%BD1.3/" class="post-title-link" itemprop="url">三：光线、相机与天空</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-23T00:00:00+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-14 15:28:02" itemprop="dateModified" datetime="2022-08-14T15:28:02+08:00">2022-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/23/%E5%85%89%E8%BF%BD1.3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/23/%E5%85%89%E8%BF%BD1.3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h4><p>如何将抽象的光线具体的表现出来并不困难，在初中物理的时候我们就使用一个点加上一个射线的方式来表示光线，于是我们可以用这样的公式描述它：<code>P(t)=A+t*b</code></p>
<p><img src="https://s2.loli.net/2022/03/05/s71P5mzYDjenywC.png" alt="image.png"></p>
<p><strong>A</strong>表示光线的原点（光源位置），<strong>b</strong>为一个单位向量表示一个方向，t则表示单位时间，通过给t取不同的值，我们可以得到沿路上所有的点的三维坐标，当然，这个值一般来说不会为负数，我们新建ray.h，输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//空构造。</span></span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//带参构造，显然我们需要一个原点和一个方向。</span></span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//通过这个函数拿取原点值。</span></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">		<span class="comment">//通过这个函数拿取方向值。</span></span><br><span class="line">    	<span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//这个函数就对应了上方数学公式中的P(t)，通过传入一个时间t，能得到当前光线传播到的坐标位置。</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h4><p>我们把“相机”固定在一个位置，并且固定一下它观察的方向。</p>
<p>接下来需要解决两个问题：</p>
<ol>
<li>光线从哪里射出呢？相机位置。按照常理来说，太阳发出的光线从物体上弹射了多次，最终会被摄像机（或者人眼）捕捉。相机位置应该是光线的终点才对啊，怎么会是起点呢？<strong>原因是我们需要逆光路取色，这是路径追踪的经典光线模型，重点是我们的光线和现实中的光线是反过来的，如果正向光路进行光线追踪会极其困难，几乎寸步难行。</strong></li>
<li>光线朝哪个方向射出呢？这就要引出一个“虚拟视口”的概念。它就像一个相框，摆在相机的前面，相机发射的密集光铺满相框，就得到图像，具体方法为：<strong>按照行优先的顺序，从左上角开始，一排一排的射出光线，射出光线的数目就是像素的数目，换句话说，我们对每一个像素都会射出一根光线</strong>。</li>
</ol>
<p>将相机位置定位（0，0，0）这个场景是这样的：</p>
<p><img src="https://s2.loli.net/2022/03/05/qhcP98ZAYve1SCt.png" alt="image.png"></p>
<p>假设图中的虚拟视口上有800个像素，每个像素长宽都是0.1，最终得到一张40<em>20的图片，我们只需要瞄准<em>*每一个像素的中心</em></em>。</p>
<p>按照行优先左上角开始，发生的第一根光线应该是从（0，0，0）射向（-2+0.05，1-0.05，-1）方向。不必要求这个方向向量是一个单位向量，保持方向向量是单位向量并不能给项目提供更多便利。如此类推：第二个是（-2+0.15，1-0.05，-1）方向、第四十个是（-2+3.95，1-0.05，-1）方向、第八百个是（-2+3.95，1-1.95，-1）方向。</p>
<p>改写main函数，并且为其所在的文件添加一个全局函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个简单的决定光线所带回颜色的函数。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先把这个光线的方向向量单位化。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再根据这个单位化向量的y分量给他设定颜色，得保证t在[0,1]之间。</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 插值函数，t靠近0它就越靠近白色，越靠近1它就越靠近一种蓝色。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//图片数据，这次我们换一种角度去定义图片的长宽，我们定义一个长宽比，再把它的宽度定义出来。</span></span><br><span class="line">    <span class="comment">//长度就可以通过简单的计算得到。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟视口数据，我们保持它的高度（宽度）为2，长度同样通过长宽比得到。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//保持视口和实际图片的长宽比一致。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height; </span><br><span class="line">    <span class="comment">//这是视口离相机的距离，保持为1就好，我们暂时把它写死。</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相机位置</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//相机水平方向，即X轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//相机头顶方向，即Y轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个是虚拟视口左下角所在位置的坐标，在上面那个图片例子里，它就是（-2，-1，-1）。</span></span><br><span class="line">    <span class="comment">//注意因为长宽比不是2/1而是16/9，所以本例子里这个值和图片中的值不同。</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环（render loop）</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//这个uv就是当前像素位置的横纵坐标偏移。</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//创造射线。</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            <span class="comment">//通过全局函数取到本像素颜色。</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="comment">//写颜色到输出流。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/qt3BYcAd9NI5kvS.png" alt="image.png"></p>
<p>通过光线在y轴方向上的分量得到一种类似于蓝天的效果，这个图片也将在后来成为我们的背景。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1：循环渲染射出光线瞄准的是哪里呢？</p>
<p>仔细计算可以发现，是每个像素的左上角，并不是中心点，其实左上角又或是中心点这一点的颜色都不能代表整个像素的颜色，这个问题后续将会解决。</p>
<p>2：更改ray_color函数可以制作一些更加炫酷的背景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec = r.<span class="built_in">direction</span>() * <span class="number">1</span> - r.<span class="built_in">origin</span>(); </span><br><span class="line">    <span class="keyword">auto</span> absVec = <span class="built_in">vec3</span>(std::<span class="built_in">abs</span>(vec.<span class="built_in">x</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">y</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unit_vector</span>(absVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/OVRxAhGDbnywlYm.png" alt="image.png"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第4节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/21/%E5%85%89%E8%BF%BD1.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E5%85%89%E8%BF%BD1.2/" class="post-title-link" itemprop="url">二：点、向量、颜色</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T00:00:00+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-14 15:04:58" itemprop="dateModified" datetime="2022-08-14T15:04:58+08:00">2022-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/21/%E5%85%89%E8%BF%BD1.2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/21/%E5%85%89%E8%BF%BD1.2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>既然是光追，肯定离不开点和方向于颜色，在大多数工程中，颜色和方向是四维的向量，但是对于这个工程，三位向量可以满足需求，我们定义一个类来表示它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止被重复引用，用ifndef去包裹所有代码。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要一些cmath类里面的数学函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精确引用，只需要开方函数就只引入最小的命名空间</span></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 空构造，默认构造一个（0，0，0）向量</span></span><br><span class="line">        <span class="built_in">vec3</span>() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 传入三个参数的构造。</span></span><br><span class="line">        <span class="built_in">vec3</span>(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义x，y，z分量。这样就可以用 向量.x() 直接拿取x分量。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//下面进行运算符重载。</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//单目 &#x27;-&#x27; 运算符 ，会对三维向量的每一维取反。</span></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符的const版本，返回右值。</span></span><br><span class="line">    	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符普通版本，返回左值</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;+=&#x27;运算符，const保护参数不被修改，返回引用允许操作符嵌套。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// &#x27;*=&#x27;运算符</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;/=&#x27;运算符，直接使用*=去定义&#x27;/=&#x27;。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//模相关。</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 模的平方。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 模</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 向量中的数组也直接暴露出去了，这里是float也没问题，看你的喜好。</span></span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给vec3类多起几个名字。</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point，在指定三维空间中的点的时候使用这种别名。</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color，在指定颜色的时候使用这种别名。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="类外补充"><a href="#类外补充" class="headerlink" title="类外补充"></a>类外补充</h4><p>接下来是一些加减乘除等操作，其中的有些操作并不可以写在类内，比如double类型<code>*</code>vec3类型，所以统一写在类外：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vec3 类外函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出流符号&quot;&lt;&lt;&quot;</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123; </span><br><span class="line">    <span class="comment">//当用户使用 cout &lt;&lt; vec3的时候，输出vec3中的各个分量值。</span></span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符，它的返回值不是引用，这很合理，我们永远不会把 “a + b”这样的东西放在赋值符号左侧</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，向量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，标量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还是*运算符，但这次参数中标量和向量的顺序是反过来的。</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用*去定义/</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量点乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量叉乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单位化这个向量，就是把它的各个分量除以它的长度，正好，我们可以用上面刚刚写完的/运算符去定义它。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽离与简化"><a href="#抽离与简化" class="headerlink" title="抽离与简化"></a>抽离与简化</h4><p>在第一章时，有三行将0-1的通道映射到0-255的代码，这部分代码是固定的，可以统一将它们抽离出去，创建、<code>color.h</code>文件，以后的关于渲染颜色的代码统一放到这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个全局的函数，接受一个输出流参数，和一个color参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把之前的代码两步并作一步，直接转到[0,255]区间然后直接输出出去。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来main函数的代码将相当简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//直接调用vec3类有参构造构造一个对象</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写颜色！如此的简单！</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第3节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/19/%E5%85%89%E8%BF%BD1.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" class="post-title-link" itemprop="url">一：生成第一张图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-19T00:00:00+08:00">2022-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 09:44:31" itemprop="dateModified" datetime="2022-08-19T09:44:31+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/19/%E5%85%89%E8%BF%BD1.1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前言：</strong>前段时间在学习C++ primer的同时，我还有幸接触到了一本非常有趣的书，它通过我们的vs写出的代码直接模拟光线追踪生成图像。地址：<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a>。它非常的有趣也具有很高的学习价值，所以我想把学习的过程记录下来，也欢迎大家来一起学习并找出其中的错误，废话不多说，直接开始！</p>
<h4 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h4><p>首先明确我们这里使用的是ppm格式的图片格式，它是通过类似于<code>vector&lt;vector&lt;int&gt;&gt;</code>的方式记录下每个色素的RGB值。</p>
<p><img src="https://s2.loli.net/2022/03/04/enLDpxsbyNRazIu.png" alt="image.png"></p>
<p>此外在开头还需要做一些说明：</p>
<ul>
<li>P3#代表颜色使用ASCII码表示</li>
<li>3 2#代表3行两列，它使得我们接下来的数字不需要按照行列摆放工整，而是可以</li>
<li>255#表示使用0-255来表示一个通道的颜色</li>
</ul>
<p>可以试着通过代码来生成一张这样的图片：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义图片的宽度和高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印ppm文件的开头</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以左下角为原点，从左上方依次打印像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//将r和g通道控制在0-1内</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line">			<span class="comment">//之后统一将它们映射到0-255</span></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">			<span class="comment">//依次输出rgb，注意中间空格</span></span><br><span class="line">            std::cout &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完代码之后，我们以release方式运行，之所以不选择debug模式，主要还是因为太耗费时间，在保证代码不出现错误的情况下，使用release可以节省一些时间。</p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>以上代码只能让信息输出到控制台，而我们希望将其输出到一个文件内，所以我们可以使用命令行实现：</p>
<ul>
<li>打开命令行输入项目所在硬盘加冒号之后回车，如：<code>D:</code></li>
<li>接着输入，cd+空格+项目文件下的release文件夹地址后回车，如：<code>cd D:\C++\RayTracing\x64\Release</code>同时还要注意是X86还是X64。</li>
<li>之后输入<code>raycast.exe &gt; image.ppm</code>，raycast.exe为我们的程序，使用<code>&gt;</code>重定向将数据输出到文件名为image1.1的文件中，同时指定文件格式为ppm</li>
</ul>
<p>最后依次回车之后我们就可以在release文件夹下看到一个image的图片文件，如果打不开，可以下载一个极速看图软件。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220819094425458.png" alt="image-20220819094425458"></p>
<p>一张非常绚丽的图，正如我们代码中的那样，从左到右越来越红，从下到上越来越绿。</p>
<h4 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h4><p>现在我们并不知道图片能够多久加载完成，当所需要的图片像素点非常多时，这个问题会更加明显，所以我们使用std::cerr来显式加载的进度，它主要用于显示错误消息，且不被缓冲，可以发送到显示器，并且不被重定向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 提示还有多少行数据没有处理完。</span></span><br><span class="line">       std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提示已经完全搞定。</span></span><br><span class="line">   std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>同时使用“\r”可以把光标强行移回本行开头，这样这次输出的内容就会覆盖掉这一行原本的内容，就好像每次到来的新东西会“冲洗”掉之前输出的东西。</p>
<p>注意这一行的结尾是std::flush，它表示再输出完这一行之后，会强行把内存中缓冲区内的数据打出到错误输出流里（清空缓冲区）。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sss_0916/article/details/95622404?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5.pc_relevant_default&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8">endl、ends和flush的区别</a></p>
<p>再次使用命令行就可以看到</p>
<p><img src="https://s2.loli.net/2022/03/04/hHqw6jYGFof7dPX.png" alt="image.png"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第2节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十六章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-15T00:00:00+08:00">2022-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:42" itemprop="dateModified" datetime="2022-03-04T12:58:42+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> string&amp; v1, <span class="keyword">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl &lt; v2) <span class="keyword">return</span> -l; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; v1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于像这样除了类型意外一模一样的函数，我们可以使用模板来适配各种各样的类型。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板，而不是为每一个类型定义一个新的函数。则compare的模板可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; vl) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板定义以关键字template开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(&lt;)和大于号(&gt;）包围起来。</p>
<p><strong>在模板定义中,模板参数列表不能为空。</strong></p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>调用一个函数模板时，编译器用函数的实参来推断模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt; endl; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>

<p>编译会推断出实参int，并绑定到T，这样推断出来的为我们<strong>实例化</strong>一个特定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T为int</span></span><br><span class="line"><span class="comment">//实例化出int compare (const vector&lt;int&gt;&amp;,const vector&lt;int&gt;&amp;)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;, vec2&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1, vec2) &lt;&lt;endl; <span class="comment">// T为vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里编译器会实例化两个不同版本的compare。其中一个T为int，另一个T为vector<int>，编译器生成的版本成为模板的实例。</p>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>我们的compare函数有一个模板类型参数(type parameter)。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:返回类型和参数类型相同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">Tfoo</span> (T* p)&#123;</span><br><span class="line">	T tmp = *p; <span class="comment">// tmp 的类型将是指针p指向的类型/ / ...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数前必须使用关键字class或typename:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:U之前必须加上class或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;)</span> </span>;</span><br><span class="line"><span class="comment">//正确:在模板参数列表中,typename和class没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="built_in">calc</span> (<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;) ;</span><br></pre></td></tr></table></figure>

<p>因为可以使用非类的类型作为模板实参，所以使用typename更为直观。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了模板参数，我们还可以定义非类型参数，简言之就是一个固定的值，当模板被实例化后，非类型模板参数就被这个值所取代，这个值也必须时常量表达式，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span> (p1, p2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span> ( <span class="string">&quot;hi&quot;</span>, <span class="string">&#x27;mom&quot;)</span></span><br></pre></td></tr></table></figure>

<p>最后编译器使用字面常量大小代替N和M：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1) [<span class="number">3</span>],<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。</p>
<p>通常在需要常量表达式的地方需要用到此参数。</p>
<h4 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:inline说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误:inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>通过const＋引用的方式，我们保证了函数可以用于不能拷贝的类型。</p>
<p>此外，我们没必要即使用<code>&lt;</code>又使用<code>&gt;</code>运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//期望的比较操作</span></span><br><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -l;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//即使用于指针也正确的compare版本;参见14.8.2节（第510页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">( less&lt;T&gt;()(vl, v2))</span> <span class="keyword">return</span> -1</span>;</span><br><span class="line"><span class="keyword">if</span> ( less&lt;T&gt;() (v2, v1)) <span class="keyword">return</span> l;<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的（据查阅资料，less<T>的默认实现用的就是&lt;，所以这其实并未起到让这种比较有一个良好定义的作用—译者注)。</p>
<p><strong>模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>编译器遇到模板时，只有当实例化除模板特例时，才会生成代码。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同:为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>关键概念:模板和头文件</strong></p>
<p>模板包含两种名字:</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p>当使用模板时,所有不依赖于模板参数的名字都必须是可见的,这是由模板的提供者来保证的。而且,模板的提供者必须保证，当模板被实例化时,模板的定义,包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件,包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件,以及用来实例化模板的任何类型的头文件。</p>
<h4 id="实例化器件错误报告"><a href="#实例化器件错误报告" class="headerlink" title="实例化器件错误报告"></a>实例化器件错误报告</h4><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<p>例如原始版本的<code>if (vl &lt; v2) return -l;//要求类型T的对象支持&lt;操作</code>其中如果调用者传入类型没有<code>&lt;</code>运算符，则会在第三个阶段报错。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板是用来蓝图的，编译器不能为类推断参数类型。必须在尖括号中提供额外的信息，用来代替参数的模板实参列表。</p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>我们实现StrBlib的模板版本，为Bolb，不在针对string，使用时用户需要指出元素类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t ypedef T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;T&gt; : :size_type size_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: : initializer_list&lt;T&gt; il);</span><br><span class="line">	<span class="comment">// Blob中的元素数目</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="comment">//移动版本，参见13.6.3节（第484页)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std : : <span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (size_type i); <span class="comment">// 在14.5节(第501页)中定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: : shared ptr&lt;std : : vector&lt;T&gt;&gt; data;<span class="comment">//若data[i]无效，则抛出msg</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std: :string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例如，我们将元素访问操作的返回类型定义为T&amp;。当用户实例化Blob时，T就会被替换为特定的模板实参类型。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>使用类模板时，提供额外信息，这些信息实际上是显示模板实参列表，它们被绑定到模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;					<span class="comment">//空Blob&lt;int&gt;</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; 	<span class="comment">//有5个元素的Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是编译器生成一个类似这样的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;<span class="keyword">int</span>&gt;: :size_type size_type; </span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: :initializer_list&lt;<span class="keyword">int</span>&gt; il); <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: :shared ptr&lt;std: :vector&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std : : string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联,也不会对任何其他B1ob类型的成员有特殊访问权限。</strong></p>
<h4 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h4><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的data 成员使用了两个模板，vector和 shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是Blob的模板参数。因此，data的定义如下:</p>
<p><code>std: :shared_ ptr&lt;std: : vector&lt;T&gt;&gt; data;</code></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</p>
<p>当我们定义一个成员函数时，模板实参与模板形参相同。对于strBlob的一个给定的成员函数</p>
<p><code>ret-type StrBlob : : member-name(parm-list)</code></p>
<p>对应的Blob的成员应该是这样的:</p>
<p><code>template &lt;typename T&gt; ret-type Blob&lt;T&gt;: :member-name(parm-list)</code></p>
<h4 id="check和元素访问成员"><a href="#check和元素访问成员" class="headerlink" title="check和元素访问成员"></a>check和元素访问成员</h4><p>我们首先定义check成员，它检查一个给定的索引:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">check</span>(size_type i,<span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;=data-&gt;<span class="built_in">size</span> ())</span><br><span class="line">		<span class="keyword">throw</span> std: :<span class="built_in">out_of_range</span>(msg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用模板参数指出返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;: : <span class="built_in">back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>); <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt; : : <span class="keyword">operator</span>[](size_type i) &#123;</span><br><span class="line">	<span class="comment">//如果i太大，check会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    <span class="built_in">check</span> (i, <span class="string">&quot;subscript out of range&quot;</span> ) ;</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pop_back函数与原StrBlob的成员几乎相同:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Blob构造函数"><a href="#Blob构造函数" class="headerlink" title="Blob构造函数"></a>Blob构造函数</h4><p>与类模板外函数一样，构造函数先定义模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span> (std: :make_shared&lt;std: :vector&lt;T&gt;&gt;())&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>分配一个空vcector，并将指向vector的指针保存在data中，还要有接受一个initializer_list参数的构造函数将其类型参数工作为initializer list参数的元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std: :initializer_list&lt;T&gt; il):</span><br><span class="line">			<span class="built_in">data</span>(std: :make_shared&lt;std: :vector&lt;T&gt;&gt;(il))&#123; &#125;	</span><br></pre></td></tr></table></figure>

<p>为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob的元素类型兼容:</p>
<p><code>Blob&lt;string&gt; articles = &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot; &#125;;</code></p>
<h4 id="类模板成员的实例化"><a href="#类模板成员的实例化" class="headerlink" title="类模板成员的实例化"></a>类模板成员的实例化</h4><p>只有当程序用到它时才会进行实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; squares = &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt; : :size ( ) const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != squares.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	squares[i] = i*i;<span class="comment">//实例化Blob&lt;int&gt; : : operator[] (size_t)</span></span><br></pre></td></tr></table></figure>

<p>实例化了 Blob<int>类和它的三个成员函数: operator[ ] 、 size和接受initializer_list<int>的构造函数。</p>
<p><strong>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
<h4 id="在类内简化模板类名"><a href="#在类内简化模板类名" class="headerlink" title="在类内简化模板类名"></a>在类内简化模板类名</h4><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若试图访问一个不存在的元素，BlobPtr抛出一个异常template &lt;typename T&gt; class BlobPtr &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, <span class="keyword">size_t</span> sz - <span class="number">0</span>):</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; </span><br><span class="line">        <span class="comment">// (*p)为本对象指向的vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递增和递减</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置运算符</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--( );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check 返回一个指向vector的shared_ptr</span></span><br><span class="line">	std: :shared_ptr&lt;std: :vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std : : <span class="keyword">size_t</span>, <span class="keyword">const</span> std : : string&amp;) <span class="keyword">const</span>; </span><br><span class="line">	<span class="comment">// 保存一个weak ptr，表示底层vector可能被销毁</span></span><br><span class="line">	std : : weak_ptr&lt;std : : vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std : : <span class="keyword">size_t</span> curr; <span class="comment">//数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在递增和递减函数中，我们返回的是BlobPtr&amp;，而不使用BlobPtr<T>&amp;，因为当处于一个类模板的作用域时，自身引用时就等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>

<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>由于在类外，只有遇到类名才代表进入类的作用域，所以类外函数返回自身需要使用BlobPtr<T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置:递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;: :<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查;调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//保存当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>;<span class="comment">//推进一个元素;前置++检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数体已经进入类内，所以可以直接使用BlobPtr。</p>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</strong></p>
<h4 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h4><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<h4 id="一对一友好关系"><a href="#一对一友好关系" class="headerlink" title="一对一友好关系"></a>一对一友好关系</h4><p>我们的Blob类应该将BlobPtr类和模板版本的Blob相等运算符定义为友元，此外我们在Blob加入可以用==运算符的友元函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在 Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span><span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;); </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">		(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">	<span class="comment">//其他成员定义，与12.1.1（第405页）相同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里在Blob类中出现的5个T，说明它将对应的类与函数声明为友元，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;<span class="comment">// BlobPtr&lt;char&gt;和operator==&lt;char&gt;都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;<span class="comment">// BlobPtr&lt;int&gt;和operator==&lt;int&gt;都是本对象的友元</span></span><br></pre></td></tr></table></figure>

<h4 id="通过和特定的模板友好关系"><a href="#通过和特定的模板友好关系" class="headerlink" title="通过和特定的模板友好关系"></a>通过和特定的模板友好关系</h4><p>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> &#123;</span><span class="comment">//C是一个普通的非模板类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;<span class="comment">//用类c实例化的Pal是c的一个友元/l Pal2的所有实例都是c的友元;这种情况无须前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">c2</span> &#123;</span><span class="comment">// C2本身是一个类模板</span></span><br><span class="line">	<span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;; <span class="comment">// Pal的模板声明必须在作用域之内</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> x&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">	<span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span><span class="comment">//不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
<h4 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Type; <span class="comment">//将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成为Bar<Foo>的友元，sales data将成为Bar<Sales data>的友元，依此类推。</p>
<h4 id="模板的类型别名"><a href="#模板的类型别名" class="headerlink" title="模板的类型别名"></a>模板的类型别名</h4><p>可以给已经实例化的类起别名：<code>typedef Blob&lt;string&gt; StrBlob;</code>模板起别名的方式为则不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以固定多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">// books是一个pair&lt;string,unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars是一个pair&lt;Vehicle,unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids是一个pair&lt;Student,unsigned&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>类模板也可以声明static成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> std: :<span class="function"><span class="keyword">size_t</span> <span class="title">count</span> <span class="params">()</span></span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">//其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> std: : <span class="keyword">size_t</span> ctr;<span class="comment">//其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的static成员会在同一个类型内共享，如Foo<X>这个类型的所有对象，共享这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化static成员Foo&lt;string&gt; ::ctr和Foo&lt;string&gt; : :count</span></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line"><span class="comment">//所有三个对象共享相同的Foo&lt;int&gt; : :ctr和Foo&lt;int&gt; : : count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2,fi3;</span><br></pre></td></tr></table></figure>

<p>数据成员也同样如此，且必须有且仅有一个定义，所有该特定类的对象共享此成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt; : : ctr = <span class="number">0</span>; <span class="comment">//定义并初始化ctr</span></span><br></pre></td></tr></table></figure>

<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问static成员，我们必须引用一个特定的实例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;						<span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">count</span> () ;	 <span class="comment">//实例化Foo&lt;int&gt; ; :count</span></span><br><span class="line">ct = fi.<span class="built_in">count</span> ();					<span class="comment">//使用Foo&lt;int&gt; : : count</span></span><br><span class="line">ct= Foo: :<span class="built_in">count</span> ();					<span class="comment">//错误:使用哪个模板实例的count?</span></span><br></pre></td></tr></table></figure>

<p>static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板参数的名字不仅可以是T还可以是其他任何命名。</p>
<h4 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h4><p>一个模板参数可用范围是在其声明之后，至模板声明或定义结束之前。与其他任何名字一样的是模板参数隐藏外层作用域声明的相同的名字，不同的是，在模板内不能重用模板参数名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a,B b)</span></span></span><br><span class="line"><span class="function">	A tmp </span>= a;<span class="comment">// tmp的类型为模板参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;<span class="comment">//错误:重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于模板名字不能重用，所以在模板参数列表也只能出现一次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:非法重用模板参数名v</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> v, <span class="keyword">typename</span> v&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>模板的声明必须包括模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明但不定义compare和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
<h4 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h4><p>由于使用：：运算符在模板参数上就会有困难，如：T：：men，它不知道men声明类型成员和static数据成员，所以必须知道这个T是否表示一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>如果希望使用一个类型成员就必须显示使用typename关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p><strong>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用 class。</strong></p>
<h4 id="默认的模板实参"><a href="#默认的模板实参" class="headerlink" title="默认的模板实参"></a>默认的模板实参</h4><p>就像函数的默认实参一样，我们也可以为模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2，Ff = <span class="built_in">F</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(vl, v2) ) <span class="keyword">return</span> -l;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户调用时，可以自己提供，也可以使用默认的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = <span class="built_in">compare</span> (<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//使用less; i为-1</span></span><br><span class="line"><span class="comment">//结果依赖于item1和item2中的isbn</span></span><br><span class="line"><span class="function">sales_data <span class="title">item1</span><span class="params">(cin)</span>, <span class="title">item2</span><span class="params">(cin)</span> </span>;</span><br><span class="line"><span class="keyword">bool</span> j = <span class="built_in">compare</span> (iteml, item2,compareIsbn);</span><br></pre></td></tr></table></figure>

<p>与函数默认实参一样,对于一个模板参数,只有当它右侧的所有参数都有默认实参时它才可以有默认实参。</p>
<h4 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h4><p>同样的，类可以使用默认模板参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> &#123;</span><span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Numbers</span>(T V = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line">	<span class="comment">//对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>

<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><h4 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h4><p>若一个普通类中有一个模板函数，便被称为成员模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象类，对给定指针执行delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DebugDelete</span>(std::ostream&amp; s = std::cerr) :<span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">	<span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std : : endl; <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::ostream &amp; os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个类似unique_ptr的使用的默认删除器，根据不同的类型进行销毁操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">//可像delete表达式一样使用的对象</span></span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用 DebugDelete: :operator() (double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在一个临时 DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip) ;</span><br></pre></td></tr></table></figure>

<p>我们就可以用这个类型替换unique_ptr中的删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁p指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;int&gt; (int *)</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>，DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>,DebugDelete())</span></span>;</span><br><span class="line"><span class="comment">//销毁sp指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;string&gt; (string* )</span></span><br><span class="line"><span class="function">unique _ptr&lt;string,DebugDelete&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> string,DebugDelete() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>当unique_ptr析构函数调用时，De—类便会实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebugDelete的成员模板实例化样例</span></span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">int</span> *p) <span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>()(string *p)<span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h4><p>类和成员有各自的模板，即可以像这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="built_in">Blob</span> (It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::<span class="built_in">Blob</span> (It b, It e):</span><br><span class="line">		<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h4><p>为了实例化上一个模板类的成员模板，我们必须同时提供类和函数的实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] =&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">long</span>&gt; vi = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; w = &#123; <span class="string">&quot;now&quot;</span> , <span class="string">&quot;is&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;time&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类及其接受两个int*参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span> <span class="params">(begin(ia), end (ia))</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt; : :iterator的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin (), vi.end ())</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;string&gt;及其接受两个list&lt;const char*&gt; : :iterator参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;string&gt; <span class="title">a3</span> <span class="params">( w.begin (), w.end ())</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义a1时就实例化了如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">Blob</span> (<span class="keyword">int</span>* , <span class="keyword">int</span>* );</span><br></pre></td></tr></table></figure>

<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板,并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>在新标准中，我们可以通过显式实例化(explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;		<span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;				<span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">//declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</span></span><br><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;				<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>

<p>编译器遇到extern声明时，它不会在本文件中生成实例化代码，而是承诺其他地方有这样的实例化，我现在只是使用它，对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p>extern声明必须在任何使用此实例之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cc</span></span><br><span class="line"><span class="comment">//这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sal,sa2; <span class="comment">//实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; al = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(al)</span></span>; <span class="comment">//拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">compare</span>(a1 [<span class="number">0</span>],a2[<span class="number">0</span>]);<span class="comment">//实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>

<p>上面的这些使用extern的实例必须在其他地方有定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">//实例化文件必须为每个在其他文件中声明为extern 的类型和函数提供一个(非extern)的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;<span class="comment">//实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>

<p><strong>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
<h4 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h4><p><strong>在一个类模板的实例化定义中,所用类型必须能用于模板的所有成员函数。</strong></p>
<h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>unique_ptr避免了间接调用删除其的运行时开销，而shared_ptr使用户可以重载删除器。前者有效率，后者有灵活度。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li>const转换:可以将一个非 const对象的引用（或指针）传递给一个const的引用（或指针）形参。</li>
<li>数组或函数指针转换:如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T，T)</span></span>;<span class="comment">//实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 引用</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">s2</span> <span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);<span class="comment">//调用fobj(string,string); const被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);<span class="comment">//调用fref(const string&amp;, const string&amp;)</span></span><br><span class="line"><span class="comment">//将s1转换为const是允许的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b) ;</span><br><span class="line"><span class="comment">//调用f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a,b);</span><br><span class="line"><span class="comment">//错误:数组类型不匹配</span></span><br></pre></td></tr></table></figure>

<p>在最后一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针(参见6.2.4节，第195页)。a和 b的类型是不匹配的，因此调用是错误的。</p>
<p><strong>将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有const转换及数组或函数到指针的转换。</strong></p>
<h4 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h4><p>模板的参数只允许几种有限的类型转换，因此传递的这些形参必须具有相同的类型。我们的compare函数接受两个const T&amp;参数，其实参必须是相同类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);<span class="comment">//错误:不能实例化compare (long, int)</span></span><br></pre></td></tr></table></figure>

<p>如果希望可以类型转换，可以将函数模板定义为两个类型参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span> <span class="params">(<span class="keyword">const</span> A&amp; v1,<span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl&lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2&lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cout,<span class="number">42</span>); <span class="comment">//实例化print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span> <span class="params">( <span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span> (f，<span class="number">10</span>);<span class="comment">//使用print (ostream&amp;, int);将f转换为ostream&amp;</span></span><br></pre></td></tr></table></figure>

<p>第一个函数参数是一个已知类型ostream&amp;。第二个参数 obj 则是模板参数类型。由于os 的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换:</p>
<p><strong>如果函教参教类型不是模板参数，则对实参进行正常的类型转换。</strong></p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>某些时候模板参数无法推断除类型，允许用户控制模板实例化。</p>
<h4 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h4><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">Tl <span class="title">sum</span><span class="params">(T2，T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没有任何参数可供推断出T1的类型，所以调用时必须提供一个显示模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);<span class="comment">// long long sum(int，long)</span></span><br></pre></td></tr></table></figure>

<p>显式模板实参时一一对应的，只有右边的可以忽略，但必须可以从函数参数推断出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//糟糕的设计:用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span> <span class="params">(T2,T1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则我们总是必须为所有三个形参指定实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; (i, lng) ;<span class="comment">//正确:显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>，<span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>所以把需要显示提供的参数放在最前面</p>
<h4 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h4><p>如果模板类型参数已经显式指定，页可以进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);					<span class="comment">//错误:模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare (long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare(int,int)</span></span><br></pre></td></tr></table></figure>

<p>第一个调用由于类型不匹配错误，后面的调用由于显式指定，而可以进行正常的类型转换。</p>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span> (It beg, It end)&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不知道返回结果的准确类型，但所需类型是所处理的序列的元素类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span> (vi.<span class="built_in">begin</span> (), vi.<span class="built_in">end</span>() ); 	<span class="comment">//fcn应该返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span> (ca.<span class="built_in">begin</span> (), ca.<span class="built_in">end</span>());		<span class="comment">// fcn应该返回string&amp;</span></span><br></pre></td></tr></table></figure>

<p>我们知道函数应该返回*beg，而且知道我们可以用decltype (*beg)来获取表达式类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg,It end)</span> -&gt; <span class="title">decitype</span> <span class="params">(*beg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h4><p>如果并不想返回引用而是返回其中的值，可以使用标准库<strong>类型转换</strong>模板。在头文件type_traits中，如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化 remove_reference&lt;int&amp;&gt;，则type 成员将是int。类似的，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string，依此类推。更一般的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span> (*beg) &gt;::type</span><br></pre></td></tr></table></figure>

<p>组合使用它们就可以在函数中返回元素值的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用模板参数的成员，必须用typename，参见16.1.3节（第593页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span> <span class="params">(It beg,It end)</span> -&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span> <span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png" alt="image.png"></p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>可以用一个函数模板对一个函数指针进行赋值，可根据形参生成一个实例，被指针所指：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> ( *pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<p>如果不能从函数指针类型却低估模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本;每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*) (<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span> (compare); <span class="comment">//错误:使用compare的哪个实例?</span></span><br></pre></td></tr></table></figure>

<p>由于既可以接受int和string版本的compare，所以调用失败。不过可以显式的指出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:显式指出实例化哪个compare版本</span></span><br><span class="line"><span class="built_in">func</span> (compare&lt;<span class="keyword">int</span>&gt;);<span class="comment">//传递compare (const int&amp;,const int&amp;)</span></span><br></pre></td></tr></table></figure>

<p><strong>当参数是一个函数模板实例的地址时,程序上下文必须满足:对每个模板参数,能唯一确定其类型或值。</strong></p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><h4 id="左值引用函数参数推断类型"><a href="#左值引用函数参数推断类型" class="headerlink" title="左值引用函数参数推断类型"></a>左值引用函数参数推断类型</h4><p>一个函数参数是模板类型参数的普通引用时，只能传递给它一个左值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参必须是一个左值//对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line"><span class="built_in">f1</span>(i);<span class="comment">// i是一个int;模板参数类型T是int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">// ci是一个const int;模板参数T是const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>); <span class="comment">//错误:传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果是const T&amp;,则推断结果不会是一个const类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">//f2中的参数是const &amp; ;实参中的const是无关的</span></span><br><span class="line"><span class="comment">//在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i);<span class="comment">//i是一个int;模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">//ci是一个const int，但模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);<span class="comment">//一个const&amp;参数可以绑定到一个右值;T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h4><p>如果函数参数是右值引用，如T&amp;&amp;，推断出T的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp; &amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">//实参是一个int类型的右值;模板参数T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h4><p>如果一个函数参数是指向模板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&amp;)。</p>
<h4 id="编写接受右值引用参数的模板函数"><a href="#编写接受右值引用参数的模板函数" class="headerlink" title="编写接受右值引用参数的模板函数"></a>编写接受右值引用参数的模板函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">	Tt = val; <span class="comment">//拷贝还是绑定一个引用?</span></span><br><span class="line">	t = <span class="built_in">fcn</span> (t) ; <span class="comment">//赋值只改变t还是既改变t又改变val?</span></span><br><span class="line">	<span class="keyword">if</span> (val == t)&#123;<span class="comment">/* ...*/</span> &#125;<span class="comment">//若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，如果传入42，则T会推断为int，但如果传入int的左值，则T会推断为int&amp;，则如果修改t的同时也会修改val。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; )</span> </span>;		<span class="comment">//绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;		<span class="comment">//左值和const右值</span></span><br></pre></td></tr></table></figure>

<p>通常是这样重载模板函数，与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>在13.6.2节中我们注意到，虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<h4 id="std-move如何定义"><a href="#std-move如何定义" class="headerlink" title="std::move如何定义"></a>std::move如何定义</h4><p>标准库的的move</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// static_cast是在4.11.3节（第145页）中介绍的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt; (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很短，但其中有些微妙之处。首先，move的函数参数T&amp; &amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span> <span class="params">( <span class="string">&quot;hi! &quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std: :<span class="built_in">move</span>(<span class="built_in">string</span> ( <span class="string">&quot;bye ! &quot;</span>) );<span class="comment">//正确:从一个右值移动数据</span></span><br><span class="line">s2 = std: :<span class="built_in">move</span>(sl);<span class="comment">//正确:但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>

<h4 id="std-move如何工作"><a href="#std-move如何工作" class="headerlink" title="std::move如何工作"></a>std::move如何工作</h4><p>如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型。因此，在<code>std: : move (string ( &quot;bye ! &quot;))</code>中:</p>
<ul>
<li>推断出的T的类型为string。</li>
<li>因此，remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp; 。</li>
<li>move的函数参数t的类型为string&amp; &amp;。</li>
</ul>
<p>因此，这个调用实例化move<string>，即函数<code>string&amp;&amp; move(string &amp;t)</code></p>
<h4 id="左值static-cast到右值引用时允许的"><a href="#左值static-cast到右值引用时允许的" class="headerlink" title="左值static_cast到右值引用时允许的"></a>左值static_cast到右值引用时允许的</h4><p>我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是const的以及实参是左值还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受一个可调用对象和另外两个参数的模板//对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现:顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f,T1 t1,T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用一个接受引用的参数就会出问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span><span class="comment">//注意v2是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;++v2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数第二个参数为引用，说明我们希望通过函数改变原变量的值，但是使用模板调用就会丢失这个引用的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,i);			<span class="comment">//f改变了实参i</span></span><br><span class="line"><span class="built_in">flip1</span>(f,j,<span class="number">42</span>);		<span class="comment">//通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非int&amp;。因此，这个flip1调用会实例化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn) (<span class="keyword">int</span>,<span class="keyword">int</span>&amp; ), <span class="keyword">int</span> t1,<span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h4><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值〉使得我们可以保持const属性,因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&amp;&amp;和 T2&amp;&amp;,通过引用折叠（参见 16.2.5节，第608页）就可以保持翻转实参的左值/右值属性（参见16.2.5节，第608页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2, t1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样调用就传递给t1一个左值j，t1会折叠为int&amp;，则t1会绑定到j上，就可以通过函数改变j的值。</p>
<p><strong>如果一个函数参数是指向模板类型参数的右值引用(如 T&amp;&amp;)，它对应的实参的const属性和左值/右值属性将得到保持。</strong></p>
<p>但是不能用于接受右值引用参数的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp; &amp;i, <span class="keyword">int</span>&amp; j)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传递一个右值给flip2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>);<span class="comment">//错误:不能从一个左值实例化int&amp; &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="std-forward保持类型信息"><a href="#std-forward保持类型信息" class="headerlink" title="std::forward保持类型信息"></a>std::forward保持类型信息</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line">	<span class="built_in">finalFcn</span> (std::forward&lt;Type&gt;(arg));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节。</strong></p>
<p>于是我们可以重写前面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f,T1 &amp; &amp;t1,T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">f</span> (std: :forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h4 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h4><p>首先编写俩个不同的函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	ostringstream ret;	<span class="comment">//参见8.3节（第287页)</span></span><br><span class="line">	ret &lt;&lt; t;			<span class="comment">//使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); 	<span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个对象对应string表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">//注意:此函数不能用于char*;参见16.3节（第617页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p;	<span class="comment">//打印指针本身的值</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;<span class="built_in">debug_rep</span> (*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; null pointer&quot;</span> ;<span class="comment">//或指出 p为空</span></span><br><span class="line">	<span class="keyword">return</span> ret.<span class="built_in">str</span>();<span class="comment">//返回ret绑定的string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内容并不重要，我们先看使用它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">( <span class="string">&quot;hi&quot;</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>这个调用只有第一个版本是可行的，第二个版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。</p>
<p>如果用一个指针调用debug_rep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>两个函数都生成可行的实例:</p>
<ul>
<li>debug rep(const string*&amp;)，由第一个版本的debug_rep实例化而来，T被绑定到string*。</li>
<li>debug rep(string*)，由第二个版本的 debug_rep实例化而来，T被绑定到string。</li>
</ul>
<p>但第二个版本更加精确，第一个版本需要进行普通指针到const的转换，编译器也会选择第二个版本。</p>
<h4 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (sp) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配:</p>
<ul>
<li><code>debug rep(const string*&amp;)</code>，由第一个版本的 debug_rep 实例化而来，T被绑定到<code>string*</code>。</li>
<li><code>debug rep(const string*)</code>，由第二个版本的 debug_rep 实例化而来，T被绑定到const string。</li>
</ul>
<p>再这种时候编译器会选择最特例化的，我的理解是，最简洁的，则选择第一个版本。</p>
<h4 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印双引号包围的string</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27; &quot;&quot; +s + &#x27;</span><span class="string">&quot;&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当同时匹配同样好的模板和非模板函数的时候，编译器一定会选择非模板版本。</p>
<h4 id="重载模板和类型转换"><a href="#重载模板和类型转换" class="headerlink" title="重载模板和类型转换"></a>重载模板和类型转换</h4><p>如果使用这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;<span class="comment">//调用debug_rep(T*)</span></span><br><span class="line"><span class="comment">//本例中所有三个debug _rep版本都是可行的:</span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> T&amp;)</span>，<span class="comment">//T被绑定到char [10]。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span><span class="params">(T*)</span>，<span class="comment">//T被绑定到const char。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> strina&amp;)</span>，<span class="comment">//要求从const char*到string 的类型转换。</span></span></span><br></pre></td></tr></table></figure>

<p>前两个版本都是匹配的，而第二个版本会被认为是精确匹配的，非模板版本是可行的，但需要一次用户定义的类型转换。所以选择第二个。</p>
<p>如果更希望使用字符版本，可以定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符指针转换为string，并调用string版本的 debug_reg</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h4><p>为了使用<code>char*</code>版本的函数，必须提前准备好其中的模板函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *P)</span></span>;</span><br><span class="line"><span class="comment">//为了使debug_rep(char*)的定义正确工作，下面的声明必须在作用域中string debug_rep (const string &amp;);</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function">i</span></span><br><span class="line"><span class="function"><span class="comment">//如果接受一个const string&amp;的版本的声明不在作用域中，</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回语句将调用debug_rep(const T&amp;)的T实例化为string 的版本return debug_rep(string(p) );</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</strong></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个<strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。存在两种参数包:<strong>模板参数包</strong>template parameter packet)，表示零个或多个模板参数;<strong>函数参数包</strong>（function parameteroacket)，表示零个或多个函数参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包; rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与往常一样，编译器从函数的实参推断模板参数类型。对于可变参数模板，编译器会推断保重的参数数目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span> ;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>,d);	<span class="comment">//包中有三个参数</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="built_in">foo</span>(d,s);			<span class="comment">//包中有一个参数</span></span><br><span class="line"><span class="built_in">foo</span> ( <span class="string">&quot;hi&quot;</span>);		<span class="comment">//空包</span></span><br><span class="line"><span class="comment">//编译器会为foo实例化出四个不同的版本:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;，<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> string&amp;)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h4><p>若需要知道包中的运算符，使用sizeof…运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt;endl; <span class="comment">//类型参数的数目</span></span><br><span class="line">	cout&lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;		<span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>. . . Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;...rest)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;，&quot;</span>;			<span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>print (cout, i, s,42); //包中有两个参数</code>来调用上面的函数，首先会匹配到第二个函数，然后递归调用第二个函数，直至最后一个参数由第一个函数打印。</p>
<p><strong>当定义可变参数版本的 print时，非可变参数版本的声明必须在作用域中。否则,可变参数版本会无限递归。</strong></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>除了获取其大小以外，我们还可以<strong>扩展</strong>，我们还要提供扩展元素的<strong>模式</strong>。就时分解为构成的元素，在模式右边放一个省略号(…)触发扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;<span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span><span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);		<span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个扩展操作扩展模板参数包，为 print生成函数参数列表。第二个扩展操作出现在对print的调用中。此模式为print调用生成实参列表。</p>
<h4 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">	<span class="comment">//print (os,debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span> (os,<span class="built_in">debug_rep</span> (rest)... ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看这样的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将包传递给debug_rep; print (os，debug_rep(a1,a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os,<span class="built_in">debug_rep</span>(rest.. .) );<span class="comment">//错误:此调用无匹配函数</span></span><br></pre></td></tr></table></figure>

<p>它们的区别就是第一个对扩展包中的每一个调用函数，第二个是在调用中展开：</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;...)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员的定义，同13.5节（第465页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">chk_n_alloc</span>(); <span class="comment">//如果需要的话重新分配 StrVec内存空间</span></span><br><span class="line">	alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emplace_back的函数体调用了chk_n_alloc（参见13.5节，第465页）来确保有足够的空间容纳一个新元素，然后调用了construct在first_free 指向的位置中创建了一个元素。construct调用中的扩展为</p>
<p><code>std: : forward&lt;Args&gt;(args) ...</code><br>它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素</p>
<p><code>std::forward&lt;T&gt;(t)</code></p>
<p>其中T,表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如.假定svec是一个strVec，如果我们调用</p>
<p><code>svec.emplace_back (10,&#39;c&#39;);//将cccccccccc添加为新的尾元素</code></p>
<p>construct调用中的模式会扩展出</p>
<p><code>std::forward&lt;int&gt; (10), std::forward&lt;char&gt;(c)</code></p>
<p>通过在此调用中使用forward，我们保证如果用一个右值调用emplace back，则construct也会得到一个右值。例如，在下面的调用中:</p>
<p><code>svec.emplace back (s1 + s2);//使用移动构造函数</code></p>
<p>传递给emplace_back的实参是一个右值，它将以如下形式传递给construct</p>
<p><code>std: :forward&lt;string&gt; (string ( &quot;the end&quot; ))</code></p>
<p>forward<string>的结果类型是string&amp;&amp;，因此construct将得到一个右值引用实参。construct会继续将此实参传递给string 的移动构造函数来创建新元素。</p>
<p><strong>建议:转发和可变参数模板</strong></p>
<p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的emp lace_ back函数一样的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">(Args&amp;&amp;... args)</span> <span class="comment">//将Args扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// work的实参既扩展Args又扩展args</span></span><br><span class="line">	<span class="built_in">work</span>(std: : forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们希望将fun的所有实参转发给另一个名为work的函数,假定由它完成函数的实际工作。类似emplace_back中对 construct的调用,work调用中的扩展既扩展了模板参数包也扩展了函数参数包。<br>由于 fun的参数是右值引用,因此我们可以传递给它任意类型的实参;由于我们使用std:: forward传递这些实参，因此它们的所有类型信息在调用work时都会得到保持。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp; )</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们定义了另一个版本的compare，当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用，而传递给它字符指针，就会调用第一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span> ;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);<span class="comment">//调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>( <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;mom&quot;</span> );<span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>因为无法将指针转换为数组的引用，因此参数是p1和p2时，第二个版本compare不可行。</p>
<p>为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例化( template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<h4 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h4><p>特例化一个函数模板时，必须为每个模板参数提供实参，在template后跟&lt;&gt;，指出正在实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个特例化版本时，函数的参数类型必须与先前模板中对应类型匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>特例化中T对应的为const char*，模板函数中为一个常量指针，而我们需要一个指向常量的指针，我们需要在特例化版本中使用的类型是const char * const &amp;，即一个指向const char的const指针的引用。</p>
<h4 id="函数重载与模板特例化"><a href="#函数重载与模板特例化" class="headerlink" title="函数重载与模板特例化"></a>函数重载与模板特例化</h4><p><strong>特例化的本质是实例化一个模板,而非重载它。因此,特例化不影响函数匹配。</strong></p>
<p><strong>关键概念:普通作用域规则应用于特例化</strong></p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且,在任何使用模板实例的代码之前,特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板,很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是,这种错误编译器又无法发现。</p>
<p><strong>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面,然后是这些模板的特例化版本。</strong></p>
<h4 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h4><p>我们将has模板定义一个特例化版本，用它保存Sale_data对象，为了让我们自己的数据类型能使用hash<key_type>，必须定义hash模板的一个特例化版本。一个特例化hash类必须定义:</p>
<ul>
<li>一个重载的调用运算符（参见14.8节，第506页)，它接受一个容器关键字类型的对象，返回一个size_t。</li>
<li>两个类型成员，result type和 argument_type，分别调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义，参见13.1.2节，第443页)。</li>
</ul>
<p>首先打开命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;<span class="comment">//我们正在定义一个特例化版本，模板参数为sales_data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Sales_data&gt; </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> sales_data argument_type;<span class="comment">// 默认情况下，此类型需要==</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> sales_data&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;string&gt;() (s.bookNo) ^</span><br><span class="line">            hash&lt;<span class="keyword">unsigned</span>&gt;() (s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="keyword">double</span>&gt;() (s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//关闭std命名空间;注意:右花括号之后没有分号</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十五章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-12T00:00:00+08:00">2022-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:23" itemprop="dateModified" datetime="2022-03-04T12:58:23+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p><strong>面向对象程序设计（object-oriented programming）</strong>的核心思想是<strong>数据抽象</strong>、<strong>继承</strong>和<strong>动态绑定</strong>。</p>
<ul>
<li>使用数据抽象，我们可以将类的接口与实现分离；</li>
<li>使用继承，可以定义相似的类型并对其相似关系建模；</li>
<li>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>通过<strong>继承（inheritance）</strong>联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类(base class)<strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为</strong>派生类( derived class)**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（ virtual function)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过使用类派生列表(class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是 : 首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="comment">//Bulk_quote继承了Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为使用public派生，所以可以使用基类成员，可以把Bulk quote的对象当成Quote的对象来使用。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>用它可以分别处理Quote和Bulk_quote的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据传入item形参的对象类型调用Quote::net_price</span></span><br><span class="line">    <span class="comment">//或者Bulk_quote::net_price</span></span><br><span class="line">	<span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;ISBN:&quot;</span> &lt;&lt; item.<span class="built_in">isbn</span> ()<span class="comment">//调用Quote: :isbn</span></span><br><span class="line">		&lt;&lt;<span class="string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>函数形参中的item是基类的引用，我们既可以使用基类的该函数，又可以使用派生类中的该函数，这回根据对象的类型决定执行哪一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic的类型是Quote; bulk的类型是Bulk_quote</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, basic,<span class="number">20</span>);			<span class="comment">//调用Quote的net_price</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, bulk,<span class="number">20</span>);			<span class="comment">//调用Bulk quote的net price</span></span><br></pre></td></tr></table></figure>

<p>函数的运行版本由实参决定，所以动态绑定又被称为运行时绑定。</p>
<p><strong>在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。</strong></p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">//关于=default请参见7.1.4节（第 237页)</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> std::string &amp;book,<span class="keyword">double</span> sales_price) </span><br><span class="line">        : <span class="built_in">bookNo</span> (book), <span class="built_in">price</span>(sales_price)&#123; &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="comment">//返回给定数量的书籍的销售总额</span></span><br><span class="line">	<span class="comment">//派生类负责改写并使用不同的折扣计算算法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">					</span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span> () = <span class="keyword">default</span>;	<span class="comment">//对析构函数进行动态绑定</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string bookNo;				<span class="comment">//书籍的ISBN 编号</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;				<span class="comment">//代表普通状态下不打折的价格</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如此。</strong></p>
<h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>派生类需要提供自己新定义覆盖从基类而来的虚函数。任何希望在派生类中改变的函数定义为virtual，而不希望改变的直接定义为函数。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用<strong>受保护的( protected）</strong>访问运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须使用类派生列表指出从哪继承而来。派生类必须将继承类的虚函数重新声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;		<span class="comment">//Bulk_quote继承自Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span> (<span class="keyword">const</span> std::string&amp;,<span class="keyword">double</span>,std::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">//覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;		<span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span> ;			<span class="comment">//以小数表示的折扣额</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再派生类中使用public继承，所以回隐式包含isbn函数</p>
<h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类可以不覆盖它继承的虚函数，但必须重新声明：如果没有覆写，其行为类似其他的普通成员。</p>
<p>派生类可以再它覆盖的函数前使用virtual，可以在函数const关键字后添加override。</p>
<h4 id="派生类对象及派生类向基类转换"><a href="#派生类对象及派生类向基类转换" class="headerlink" title="派生类对象及派生类向基类转换"></a>派生类对象及派生类向基类转换</h4><p>派生类大致可以认为是这样分布：</p>
<p><img src="https://s2.loli.net/2022/02/15/wRpdlhZ4XqbNygO.png" alt="image.png"></p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;				<span class="comment">//基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">//p指向Quote对象</span></span><br><span class="line">p = &amp;bulk ;				<span class="comment">// p指向bulk 的 Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;		<span class="comment">// r绑定到bulk 的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>这种派生类到基类的转换回隐式的进行，所以可以将派生类的引用或指针用在基类引用或者指针上。</p>
<h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p>派生类构造函数可以调用基类的构造函数帮助建立自己的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std::string&amp; book,<span class="keyword">double</span> p,</span></span></span><br><span class="line"><span class="params"><span class="function">			std::<span class="keyword">size_t</span> qty,<span class="keyword">double</span> disc)</span>:</span></span><br><span class="line"><span class="function">			Quote(book, p), min_qty(qty), discount (disc)&#123;</span> &#125;</span><br><span class="line">		<span class="comment">//与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除非特别指出，否则派生类的所有成员都会执行默认初始化。编译器会首先初始化基类的部分，然后按顺序声明派生类的成员。</p>
<h4 id="派生类使用基类成员"><a href="#派生类使用基类成员" class="headerlink" title="派生类使用基类成员"></a>派生类使用基类成员</h4><p>派生类可以访问基类的公有成员和受保护成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt;= min_qty)</span><br><span class="line">		<span class="keyword">return</span> cnt *(<span class="number">1</span> - discount) * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员（例如min_qty和discount)的方式与使用基类成员（例如price）的方式没什么不同。</p>
<p><strong>关键概念:遵循基类的接口</strong><br>必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口,即使这个对象是派生类的基类部分也是如此。<br>派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了静态成员，则它在整个继承体系中只存在该成员的唯一定义。不论有几个派生，每个静态成员都只存在唯一实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span> <span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">const</span> Derived&amp;)</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmem</span> ();		<span class="comment">//正确:Base定义了statmem</span></span><br><span class="line">	Derived::<span class="built_in">statmem</span> ();	<span class="comment">//正确:Derived继承了statmem</span></span><br><span class="line">	<span class="comment">//正确:派生类的对象能访问基类的静态成员</span></span><br><span class="line">	derived_obj.<span class="built_in">statmem</span> () ;<span class="comment">//通过Derived对象访问</span></span><br><span class="line">	<span class="built_in">statmem</span> ();				<span class="comment">//通过this对象访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类声明方式和一般类一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote;<span class="comment">//错误:派生列表不能出现在这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>				<span class="comment">//正确:声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>

<h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>如果想将派生类作为基类，则必须已经被定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>;</span>				<span class="comment">//声明但未定义</span></span><br><span class="line"><span class="comment">//错误:Quote必须被定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>派生类包含从基类中来的成员，为了使用它们，必须先知道它们。也表明了一个类不能派生它本身。</p>
<p>一个类是基类，同时也可以是派生类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base &#123;<span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1 &#123;<span class="comment">/* ...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个继承关系中，Base是D1的**直接基类( direct base)<strong>，同时是D2的</strong>间接基类( indirectbase)**。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。</p>
<p>每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员;该直接基类的成员又含有其基类的成员;依此类推直至继承链的顶端。</p>
<h4 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h4><p>类名后加上final可防止类被继承：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span> <span class="comment">/** / &#125;;			//NoDerived不能作为基类</span></span><br><span class="line"><span class="comment">class Base &#123;/* */</span> &#125;;	</span><br><span class="line"><span class="comment">// Last是final的;我们不能继承</span></span><br><span class="line">Lastclass Last <span class="keyword">final</span> : Base &#123;<span class="comment">/**/</span> &#125;;		<span class="comment">// Last不能作为基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> NoDerived&#123;<span class="comment">/**/</span>&#125;;				<span class="comment">//错误:NoDerived是final的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> Last &#123;<span class="comment">/* */</span> &#125;;					<span class="comment">//错误: Last是final的</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>在继承关系的类中，基类的指针和引用可以绑定到派生类对象上，所以使用基类指针或者引用时，并不清楚绑定对象的真实类型。</p>
<p><strong>和内置指针一样,智能指针类也支持派生类向基类的类型转换,这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</strong></p>
<h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><p>在继承关系中必须区分两种类型，表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型，动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当print_total调用net_price 时(参见15.1节，第527页):</span></span><br><span class="line"><span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n) ;</span><br></pre></td></tr></table></figure>

<p>item在前面时用Quote&amp;去定义的，那么Quote&amp;就是item的静态类型，动态类型知道在运行时调用该函数才会知道。如果传递一个Bulk_quote对象给print_total，则item的动态类型于静态类型不一致。只有引用和指针动态和静态类型才会不一致。</p>
<h4 id="不存在基类想派生类的隐式类型转换"><a href="#不存在基类想派生类的隐式类型转换" class="headerlink" title="不存在基类想派生类的隐式类型转换"></a>不存在基类想派生类的隐式类型转换</h4><p>派生类可以向基类转换是因为每一个派生类对象都包含一个基类的部分。所以一个基类对象既可以独立存在可以作为派生类的一部分存在。但任何派生类对象都不可以向基类隐式的转换，包括引用和指针。</p>
<p><strong>总结</strong>：要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样,派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节（第544页)详细介绍可访问性的问题。</li>
</ul>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在我们使用基类的引用或指针调用虚函数时会执行动态绑定。因为知道运行时才知道调用了哪个版本，所以所有的虚函数都必须有定义，不论它是否被用到。</p>
<h4 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h4><p>虚函数执行哪个版本完全依赖于运行时绑定到其对象的实际动态类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, base, <span class="number">10</span>);			<span class="comment">//调用Quote::net price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">derived</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">.19</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, derived, <span class="number">10</span>);			<span class="comment">//调用Bulk_quote::net_price</span></span><br></pre></td></tr></table></figure>

<p>依据调用对象的不同，会调用两种不同的函数。此外动态绑定也只有当通过指针或引用调用虚函数才会发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base = derived;			<span class="comment">//把derived的Quote部分拷贝给base</span></span><br><span class="line">base.<span class="built_in">net_price</span> (<span class="number">20</span>);	<span class="comment">//调用Quote::net price</span></span><br></pre></td></tr></table></figure>

<p><strong>关键概念:C++的多态性</strong><br>OOP的核心思想是多态性（polymorphism)。多态性这个词源自希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型,因为我们能使用这些类型的“多种形式”而无须在意它们的差异。<strong>引用或指针的静态类型与动态类型不同</strong>这一事实正是C++语言支持多态性的根本所在。</p>
<p>当我们使用基类的引用或指针调用基类中定义的一个函数时,我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本,判断的依据是引用或指针所绑定的对象的真实类型。</p>
<p>另一方面,对非虚函数的调用在编译时进行绑定。类似的,通过对象进行的函数(虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此,通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。</p>
<p><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</strong></p>
<h4 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>当我们在派生类中可以再一次使用virtual关键字指出函数的性质。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参、返回类型必须与被覆盖的基类函数完全一致。有一个例外是当类的虚函数返回类型是类本身的指针和引用时，规则无效：也就是说，如果D由B派生得到，则基类的虚函数可以返回B<code>*</code>而派生类的对应函数可以返回D<code>*</code>，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
<h4 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h4><p>我们使用override来覆盖继承而来的虚函数，但该函数并没有覆盖已存在的虚函数，此时编译器将会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span> <span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;		<span class="comment">//正确:f1与基类中的f1匹配</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;				<span class="comment">//错误:B没有形如2 (int)的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:f3不是虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">	<span class="comment">//从B继承f2()和f3 ()，覆盖f1 (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;<span class="comment">//不允许后续的其他类覆盖f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 正确:覆盖从间接基类B继承而来的f2</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//错误:D2已经将f2声明成final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>final和 override说明符出现在形参列表(包括任何const或引用修饰符）以及尾置返回类型之后。</strong></p>
<h4 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h4><p>虚函数可以有默认实参，如果某次函数调用使用默认实参，则实参值由静态类型决定：</p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。</p>
<p><strong>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>
<h4 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h4><p>如果希望虚函数调用不要进行动态绑定，而是强迫其执行某个版本，可以使用作用域运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>此代码在编译时就可以完成解析</p>
<p><em>通常情况下,只有成员函数(或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。</em></p>
<p><em>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归</em></p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>我们可以将一个函数定义为纯虚函数，这样做的目的时为了告诉用户，当前此函数没有任何意义，所以它无需定义，通过在函数体位置添加=0就可以声明一个纯虚函数，它只能出现在类内部虚函数声明语句处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Disc_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">		std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Quote</span>(book, price),</span><br><span class="line">		<span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//折扣适用的购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount - <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//表示折扣的小数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<h4 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h4><p>含有纯虚函数的类是<strong>抽象基类</strong>，这种类只负责定义接口，后续的其他类可以覆盖接口，我们不可以直接创建一个抽象基类的对象，因为此时的其中的纯虚函数并没有被定义，我们可以在派生类中覆盖此函数，然后就可以创建派生类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></span><br><span class="line">Disc_quote discounted;		<span class="comment">//错误:不能定义 Disc quote的对象</span></span><br><span class="line">Bulk_quote bulk;			<span class="comment">//正确:Bulk quote中没有纯虚函数</span></span><br></pre></td></tr></table></figure>

<p>如果不给出纯虚函数的定义，它任然是抽象基类。</p>
<h4 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h4><p>重新实现Bulk_quote，让它继承Disc_quote：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当同一书籍的销售量超过某个值时启用折扣</span></span><br><span class="line"><span class="comment">//折扣的值是一个小于1的正的小数值，以此来降低正常销售价格</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">			std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;;<span class="comment">//覆盖基类中的函数版本以实现一种新的折扣策略</span></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的 Bulk_quote 的直接基类是 Disc_quote，间接基类是 Quote。每个Bulk quote对象包含三个子对象:一个(空的)Bulk_quote部分、一个 Disc_quote子对象和一个Quote子对象。</p>
<p>每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，也必须提供构造函数，在构造函数中调用直接基类的构造函数，进而继续调用间接基类 的构造函数。</p>
<p><strong>关键概念:重构</strong><br>在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。</p>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<p>值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。</p>
<h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问</strong>（ accessible)。</p>
<h4 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h4><p>如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是 public和 private 中和后的产物:</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;						<span class="comment">// protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky: :prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">//不能访问Base: :prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//正确:clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误:clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp; b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>例子中派生类成员函数使用基类对象访问受保护的成员是不可行的。</p>
<h4 id="公有、私有、受保护继承"><a href="#公有、私有、受保护继承" class="headerlink" title="公有、私有、受保护继承"></a>公有、私有、受保护继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// public成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">	<span class="comment">// protected成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> priv_mem;</span><br><span class="line">	<span class="comment">// private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="comment">// 正确:派生类能访问protected成员int f() &#123; return prot_mem; &#125;</span></span><br><span class="line">	<span class="comment">//错误:private成员对于派生类来说是不可访问的char g() &#123; return priv_mem;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">// 依旧不能访问</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生访问说明符对派生类的成员（及友元）能否访问直接基类成员没有影响。访问权限只与基类中的访问说明符有关。派生类只能访问直接基类的受保护的与共有的成员。</p>
<p>派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内）对于基类成员的访问权限，概括来说：</p>
<ul>
<li>如果是共有继承，那么继承而来的成员访问等级不变。</li>
<li>受保护继承，继承而来的访问等级上升一级，public变为protect。</li>
<li>私有继承，所有继承成员访问等级上升到最高，及全部为private</li>
</ul>
<h4 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h4><p>派生类向基类的转换（参见15.2.2 节，第530页)是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B:</p>
<ul>
<li>只有当D 公有地继承B时，用户代码才能使用派生类向基类的转换;如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换;派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换;反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<p><strong>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的;反之则不行。</strong></p>
<p><strong>关键概念:类的设计与受保护的成员</strong><br>不考虑继承的话,我们可以认为一个类有两种不同的用户:普通用户和类的实现者。</p>
<p>其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有(实现)部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的。</p>
<h4 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h4><p>就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="comment">//添加friend声明，其他成员与之前的版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span>			<span class="comment">// Pal在访问Base的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; 		<span class="comment">//正确: Pal是 Base的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;			<span class="comment">//错误: Pal不是Sneaky的友元</span></span><br><span class="line">    <span class="comment">//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125;		<span class="comment">//正确: Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在f2中j是Sneaky成员而不是Base成员，由于pal只是Base的友元所以不能访问其派生类成员。而f3访问的是Sneaky中的Base成员所以可以访问。</p>
<p>当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D2对Base 的 protected和private成员不具有特殊的访问能力class D2 : public Pal &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b.prot_mem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//错误:友元关系不能继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h4><p>使用using声明可以改变和继承某个名字的访问级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std : : <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">//注意:private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base : : size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base : : n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>using使得不论如何继承而来的成员在保持using前一个访问说明符的访问等级，如size是public，n是protect。但是派生的类只能为可以访问的名字提供using声明</p>
<h4 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h4><p>默认情况下class定义派生类是私有继承，而struct是共有继承。但更建议显示的声明出来。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p><strong>派生类的作用域嵌套在基类内</strong>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt;bulk.<span class="built_in">isbn</span> () ;</span><br></pre></td></tr></table></figure>

<p>名字isbn的解析将按照下述过程所示:</p>
<ul>
<li>因为我们是通过Bulk_quote的对象调用isbn的，所以首先在Bulk_quote中查找，这一步没有找到名字isbn</li>
<li>因为Bulk quote是 Disc quote 的派生类，所以接下来在 Disc_quote 中查找，仍然找不到。</li>
<li>因为 Disc_quote是 Quote的派生类，所以接着查找Quote;此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中的isbn。</li>
</ul>
<h4 id="编译时进行名字查找"><a href="#编译时进行名字查找" class="headerlink" title="编译时进行名字查找"></a>编译时进行名字查找</h4><p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况)，但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p>这是因为当使用基类指针时，可使用的成员已经确定，如果使用它绑定一个派生类对象，且派生类对象又新增了几个成员，此时对于这个指针来说，它并不知道这些多出来的成员，自然也无法使用它们。</p>
<h4 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h4><p>如果派生类中定义了其基类同名的成员，那么此成员将会隐藏基类中的同名成员，就像局部变量被优先使用。主要还是因为派生类的作用域嵌套在基类内。</p>
<h4 id="通过作用域运算符使用隐藏成员"><a href="#通过作用域运算符使用隐藏成员" class="headerlink" title="通过作用域运算符使用隐藏成员"></a>通过作用域运算符使用隐藏成员</h4><p>通过在同名成员前加上作用域就可以调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base : :mem;&#125; <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>建议还是不要同名。</p>
<p>*<em>关键概念:名字查找与继承</em><br>理解函数调用的解析过程对于理解C++的继承至关重要,假定我们调用p-&gt;mem ()（或者obj .mem())，则依次执行以下4个步骤:</p>
<ul>
<li>首先确定p(或obj)的静态类型。因为我们调用的是一个成员,所以该类型必然是类类型。</li>
<li>在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到,则编译器将报错。</li>
<li>一旦找到了mem,就进行常规的类型检查(参见6.1节,第183页)以确认对于当前找到的 mem，本次调用是否合法。</li>
<li>假设调用合法,则编译器将根据调用的是否是虚函数而产生不同的代码:<ul>
<li>如果 mem是虚函数且我们是通过引用或指针进行的调用,则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用,则编译器将产生一个常规函数调用。</li>
</ul>
</li>
</ul>
<h4 id="一如既往，名字查找先于类型检查"><a href="#一如既往，名字查找先于类型检查" class="headerlink" title="一如既往，名字查找先于类型检查"></a>一如既往，名字查找先于类型检查</h4><p>如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类(即内层作用域）的成员与基类（即外层作用域)的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致。</p>
<h4 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h4><p>现在可以理解为什么基类与派生类的虚函数必须有相同的形参列表了，如果不相同就会隐藏同名成员，而不是覆写。不然就无法通过基类引用或指针访问派生类的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//隐藏基类的fcn，这个fcn不是虚函数</span></span><br><span class="line">    <span class="comment">// D1继承了Base : :fcn ()的定义</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//形参列表与Base 中的fcn不一致</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//是一个新的虚函数，在 Base中不存在</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">//是一个非虚函数，隐藏了D1 : : fcn (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;		<span class="comment">//覆盖了Base的虚函数fcn</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//覆盖了D1的虚函数f2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过基类调用隐藏的虚函数"><a href="#通过基类调用隐藏的虚函数" class="headerlink" title="通过基类调用隐藏的虚函数"></a>通过基类调用隐藏的虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1l = &amp;bobj, * bp2 = &amp;dlobj, * bp3 = &amp;d2obj; </span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用，将在运行时调用 Base : : fcn</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用 Base : : fcn</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用D2 : :fcn</span></span><br><span class="line">D1* dlp = &amp;dlobj; D2* d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;<span class="built_in">f2</span>();			<span class="comment">//错误:Base没有名为f2的成员</span></span><br><span class="line">dlp-&gt;<span class="built_in">f2</span>();			<span class="comment">//虚调用，将在运行时调用D1 : :f2()</span></span><br><span class="line">d2p-&gt;<span class="built_in">f2</span>();			<span class="comment">// 虚调用，将在运行时调用D2: : f2()</span></span><br></pre></td></tr></table></figure>

<p>对于调用非虚函数，并不会发生动态绑定，由指针的类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *pl = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//错误:Base中没有接受一个int的fcn</span></span><br><span class="line">p2-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//静态绑定，调用D1 : :fcn(int)</span></span><br><span class="line">p3-&gt;<span class="built_in">fcn</span> ( <span class="number">42</span>);			<span class="comment">//静态绑定，调用D2 : :fcn (int)</span></span><br></pre></td></tr></table></figure>

<h4 id="覆盖重载函数"><a href="#覆盖重载函数" class="headerlink" title="覆盖重载函数"></a>覆盖重载函数</h4><p>和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。</p>
<p>一种好的解决方案是为重载的成员提供一条using声明语句（参见15.5节，第546页)，这样我们就无须覆盖基类中的每一个重载版本了。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见15.2.1节，第528页)，这样我们就能动态分配继承体系中的对象了。</p>
<p>当delete一个动态分配的对象的指针时执行析构函数，但如果指针指向了其“子孙”，则有可能出现指针静态类型与被删除对象的动态类型不符。所以必须在基类中将析构函数定义为析构函数保证函数的执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如果基类的析构函数不是虚函数,则delete一个指向派生类对象的基类指针将产生未定义的行为。</strong></p>
<p>在之前的准则中：如果一个类需要一个析构函数，那么它同样也需要拷贝和赋值操作。但基类的析构是一个重要的例外。它的虚函数并没有内容所以可以没有其他操作。</p>
<h4 id="虚析构函数阻止合成移动"><a href="#虚析构函数阻止合成移动" class="headerlink" title="虚析构函数阻止合成移动"></a>虚析构函数阻止合成移动</h4><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>这里的合成的拷贝，赋值或析构与普通类似，</p>
<p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构<br>函数类似:它们对类本身的成贝依城优对一个对象的直接基类部分进行初始化、赋值或销成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如，</p>
<ul>
<li>合成的Bulk quote默认构造函数运行Disc_quote 的默认构造函数，后者又运行Quote的默认构造函数。</li>
<li>Quote 的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0。</li>
<li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化 qty和discount。</li>
<li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它什么具体工作也不做。</li>
</ul>
<p>拷贝构造也是类似，此外基类成员是合成或自定义都没有影响，但唯一的要求是成员应该可以访问比关切不是被删除的。</p>
<p>如前所述，Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作。如我们即将看到的那样，Quote没有移动操作意味着它的派生类也没有。</p>
<h4 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h4><ul>
<li>如果基类中基础操作（构造、拷贝。。。）是删除的函数或不可访问，那么派生类对应的成员也是被删除的，因为派生类不能通过这些基类成员来为基类执行这些操作。</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</li>
<li>和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>();</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">//其他成员，不含有移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">	<span class="comment">//没有声明任何构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D d;					<span class="comment">//正确:D的合成默认构造函数使用B的默认构造函数</span></span><br><span class="line"><span class="function">D <span class="title">d2</span><span class="params">(d)</span></span>;				<span class="comment">//错误:D的合成拷贝构造函数是被删除的</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std: : move(d))</span></span>;	<span class="comment">//错误:隐式地使用D的被删除的拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h4><p>如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦 Quote定义了自己的移动操作，那么它必须同时显式地定义铂贝操作（参见13.6.2节，第476页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次进行默认初始化</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//移动赋值virtual ~Quote() = default;</span></span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数不仅仅要负责自己的成员初始化还有基类成员。而析构函数只负责销毁派生类自己分配的资源</p>
<p><strong>当派生类定义了拷贝或移动操作时,该操作负责铂贝或移动包括基类部分成员在内的整个对象。</strong></p>
<h4 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h4><p>派生类拷贝或移动构造通常是应用对应的基类构造来初始化对象的基类部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中</span></span><br><span class="line">    <span class="comment">//显式地调用该构造函数</span></span><br><span class="line">	<span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d) : <span class="built_in">Base</span>(d)</span><br><span class="line">		<span class="comment">//拷贝基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ...*/</span>	&#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">Base</span>(std : : <span class="built_in">move</span>(d))<span class="comment">//移动基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将D类型的对象d传递给基类的拷贝构造函数。这个构造负责将d的基类部分拷贝给要创建的对象。如果d并没有基类初始值，则默认初始化。</p>
<p><strong>在默认情况下,基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝(或移动)构造函数。</strong></p>
<h4 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h4><p>派生类的赋值运算符也必须显示地为其基类部分赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base: : operator=(const Base&amp;)不会被自动调用</span></span><br><span class="line">D D: :<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base: :<span class="keyword">operator</span>=(rhs); <span class="comment">//为基类部分赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类的成员赋值</span></span><br><span class="line">	<span class="comment">//酌情处理自赋值及释放已有资源等情况return *this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用基类的赋值操作无论基类的构造函数或赋值运算符是合成还是自定义，派生类的对应操作都能够使用它们。</p>
<h4 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h4><p>派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Base : : ~Base被自动调用执行</span></span><br><span class="line">	~<span class="built_in">D</span>() &#123;<span class="comment">/*该处由用户定义清除派生类成员的操作*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象销毁的顺序与创建的顺序相反。从子孙到祖先。</p>
<h4 id="在构造和析构函数中调用虚函数"><a href="#在构造和析构函数中调用虚函数" class="headerlink" title="在构造和析构函数中调用虚函数"></a>在构造和析构函数中调用虚函数</h4><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>一个类只能初始化的直接基类，一个类也只能继承其直接类的构造函数。类不能默认继承默认的拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为派生类合成。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。举个例子，我们可以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote : : Disc_quote;<span class="comment">//继承Disc_quote的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>生成的构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">derived</span> (parms) : <span class="built_in">base</span> (args)&#123; &#125;</span><br><span class="line"><span class="comment">//在我们的 Bulk_quote类中，继承的构造函数等价于:</span></span><br><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span></span></span><br><span class="line"><span class="params"><span class="function">	std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc)</span> :</span></span><br><span class="line"><span class="function">	Disc quote(book, price, qty, disc) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。</p>
<h4 id="继承的构造函数的特点"><a href="#继承的构造函数的特点" class="headerlink" title="继承的构造函数的特点"></a>继承的构造函数的特点</h4><p>和普通using不一样的是，构造函数的using声明不会改变构造函数的访问级别，且using声明也不能指定exlicit或者constexpr。继承的构造函数会具有相同的属性。</p>
<p>当基类的构造函数含有默认的实参时，这些实参并不会被继承，相反的是，派生类会获得多个继承的构造函数，每个构造函数分别省略掉由默认实参的形参。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p><strong>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”,因此容器和存在继承关系的类型无法兼容。</strong></p>
<h4 id="在容器中放置智能指针而非对象"><a href="#在容器中放置智能指针而非对象" class="headerlink" title="在容器中放置智能指针而非对象"></a>在容器中放置智能指针而非对象</h4><p>容器中防止继承关系的对象时，通常存放的是基类的指针（智能指针更好）。</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>我们定义一个表示购物篮的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Basket使用合成的默认构造函数和拷贝控制成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; sale)</span> </span>&#123; items.<span class="built_in">insert</span>(sale); &#125;</span><br><span class="line">	<span class="comment">//打印每本书的总价和购物篮中所有书的总价</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(std : : ostream&amp;)</span><span class="keyword">const</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//该函数用于比较shared_ptr，multiset成员会用到它</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs-&gt;<span class="built_in">isbn</span>() &lt; rhs-&gt;<span class="built_in">isbn</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//multiset保存多个报价，按照compare成员排序</span></span><br><span class="line">	std::multiset&lt;std::shared ptr&lt;Quote&gt;, <span class="keyword">decltype</span> (compare)*&gt; items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的类使用一个multiset（参见11.2.1节，第377页)来存放交易信息，这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在一起（参见11.2.2节，第 378页)。</p>
<p>这个声明看起来不太容易理解，但是从左向右读的话，我们就能明白它其实是定义了一个指向Quote对象的shared ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。multiset成员的名字是 items，我们初始化items并令其使用我们的compare函数。</p>
<h4 id="定义Basket的成员"><a href="#定义Basket的成员" class="headerlink" title="定义Basket的成员"></a>定义Basket的成员</h4><p>这个成员的名字是total_receipt，它负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Basket : : <span class="built_in">total_receipt</span>(ostream&amp; os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0.0</span>;		<span class="comment">//保存实时计算出的总价格</span></span><br><span class="line">	<span class="comment">// iter指向ISBN相同的一批元素中的第一个</span></span><br><span class="line">	<span class="comment">// upper_bound返回一个迭代器，该迭代器指向这批元素的尾后位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = items.<span class="built_in">cbegin</span>();</span><br><span class="line">			iter != items.<span class="built_in">cend</span>();</span><br><span class="line">			iter = items.<span class="built_in">upper_bound</span>(*iter))&#123;</span><br><span class="line">		<span class="comment">//我们知道在当前的Basket中至少有一个该关键字的元素</span></span><br><span class="line">        <span class="comment">//打印该书籍对应的项目</span></span><br><span class="line">		sum += <span class="built_in">print_total</span>(os, **iter, items.<span class="built_in">count</span>(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Total sale: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//打印最终的总价格</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的for循环中upper函数会跳过相同的书直接指到下一种书。此外在print_total函数中，第二个参数第一次解引用得到一个指向该对象的指针指针，再一次解引用才能得到这个Quto对象（或派生对象）。使用multiset统计有多少个相同元素。</p>
<h4 id="隐藏指针"><a href="#隐藏指针" class="headerlink" title="隐藏指针"></a>隐藏指针</h4><p>接下的需要定义add_item成员，先看使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.<span class="built_in">add_item</span> (make_shared&lt;Quote&gt; ( <span class="string">&quot;123&quot;</span>,<span class="number">45</span>));</span><br><span class="line">bsk,<span class="built_in">add_item</span> (make_shared&lt;Bulk_quote&gt; (<span class="string">&quot;345&quot;</span>，<span class="number">45</span>，<span class="number">3</span>，<span class="number">.15</span>));</span><br></pre></td></tr></table></figure>

<p>下一步重新定义add_item使它接受一个Quote对象而非shared_ptr，新版本的add_item将负责内存的分配。定义两个版本，一个拷贝它给定的对象，另一个采取移动操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span> </span>;			<span class="comment">//拷贝给定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(Quote&amp;&amp; sale)</span> </span>;				<span class="comment">//移动给定的对象</span></span><br></pre></td></tr></table></figure>

<p>此时遇到的问题是，函数不知道分配的类型，若<code>new Quote(sale)</code>，则可能不正确，传入其派生类的对象时，会被切掉一部分。</p>
<h4 id="模拟虚拷贝"><a href="#模拟虚拷贝" class="headerlink" title="模拟虚拷贝"></a>模拟虚拷贝</h4><p>我们给Quote添加一个虚函数，函数申请一份当前对象的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">	<span class="comment">//这些成员使用的引用限定符参见13.6.3节（第483页)</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">							</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span>(std : : <span class="built_in">move</span> (*<span class="keyword">this</span>)); &#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line">	<span class="function">Bulk_quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; <span class="params">(<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (*<span class="keyword">this</span>); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    Bulk_quote* clone () &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">						&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (std: : move ( *<span class="keyword">this</span>)) ;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">//其他成员与之前的版本一致</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<p>因为我们拥有add_item的拷贝和移动版本，所以我们分别定义clone的左值和右值版本。</p>
<p>使用clone写出新版的add_item:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span>	<span class="comment">//拷贝给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(std: :shared_ptr&lt;Quote&gt;(sale.<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span>		<span class="comment">//移动给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(</span><br><span class="line">			std: :shared_ptr&lt;Quote&gt;(std: :<span class="built_in">move</span>(sale).<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clone根据作用与左值右值分不同的版本，add_item也有调用不同版本的重载。Sale的动态类型决定了运行Quote还是Bulk_quote函数。然后为这个对象绑定智能指针放在容器内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">C++ Primer文本查询程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T00:00:00+08:00">2022-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-19 12:24:45" itemprop="dateModified" datetime="2022-02-19T12:24:45+08:00">2022-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        此为C++ Primer中第十二章中的一个文本查询程序，我想通过自己的分析来更加透彻的理解整个程序的设计，于是将此节单独作为一章重点去看：</p>
<h1 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h1><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>当程序读取输入文件时，它必须记住单词出现的每一行。因此，程序需要逐行读取输入文件，并将每一行分解为独立的单词</li>
<li>当程序生成输出时，<ul>
<li>它必须能提取每个单词所关联的行号</li>
<li>行号必须按升序出现且无重复</li>
<li>它必须能打印给定行号中的文本。</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>当输入element时，得到的是：</p>
<p><img src="https://s2.loli.net/2022/02/07/7ANskrKFnG3qV1o.png" alt="image.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​        首先看这里我认为最重要一个对应关系，单词→行号。每一个单词都有n行与之对应，那么容易想到的方法是用容器将每个单词的行号记录下来，由于每个行号只出现一次且需要升序排列，所以最优解就是使用set容器，接着如何实现通过行号找到那一行文字呢？我们可以想到使用<code>vector&lt;string&gt;</code>按行号保存文本。此外使用一个map可以将单词与它对应的set容器绑定起来，就可以实现，单词对应行号，行号对应文本。</p>
<p>​        还有一个问题是：如何建立起这个map和set，我们定义一个函数，命名为istringstream，思路大致是从vector<string>读取每个元素（每行文本），访问每个单词前首先判断map中没有这个单词，如果有：就将对应的set中加入这一次遍历的下标（即行号），如果没有：就创建一个set，并将单词与set加入map中。</p>
<h3 id="大致的类"><a href="#大致的类" class="headerlink" title="大致的类"></a>大致的类</h3><p>​        我们需要将这些结构与操作串联起来，从定义一个保存输入文件的类开始，将类命名为TextQuery，它包含一个vector和一个map。我们用这个类来构造vector和map，并且执行查询操作。</p>
<p>​        之后如果我们查到了到底要返回什么呢？返回那么一大串的东西最好的方法就是定义另一个类，这个类内应该有一个打印操作。我们将它命名为QueryResult。</p>
<h3 id="类之间的数据共享"><a href="#类之间的数据共享" class="headerlink" title="类之间的数据共享"></a>类之间的数据共享</h3><p>​        再仔细看一下这个QueryResult类，由于我们必须要返回文本，所以要用到提到过的保存整个文本的vector，然而它是第一类的成员，我们拷贝一份貌似没有必要，因为我们只需要调用其中很小的一部分，这样会造成大量的浪费，那么使用一个类内的迭代器（或指针）可以嘛？答案也是不行，因为如果第一个类在第二个类之前销毁，那么打印操作就会访问一个不存在的对象中的数据。最好的办法就是使用我们“最牛逼”的shared_ptr来反映数据结构中的共享关系。</p>
<h3 id="设计类之前先使用类"><a href="#设计类之前先使用类" class="headerlink" title="设计类之前先使用类"></a>设计类之前先使用类</h3><p>​        当我们设计一个类时，在真正实现成员之前先编写程序使用这个类，是一种非常有用的方法。通过这种方法，可以看到类是否具有我们所需要的操作。例如，下面的程序使用了TextQuery和 QueryResult类。这个函数接受一个指向要处理的文件的ifstream，并与用户交互，打印给定单词的查询结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//infile是一个ifstream，指向我们要处理的文件</span></span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>; 	<span class="comment">//保存文件并建立查询map</span></span><br><span class="line">	<span class="comment">//与用户交互:提示用户输入要查询的单词，完成查询并打印结果</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;enter word to look for, or q to quit: &quot;</span>;</span><br><span class="line">		string s;</span><br><span class="line">		<span class="comment">//若遇到文件尾或用户输入了&#x27;q&#x27;时循环终止</span></span><br><span class="line">		<span class="keyword">if</span>(!(cin &gt;&gt; s) || s == <span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//指向查询并打印结果</span></span><br><span class="line">		<span class="built_in">print</span>(cout, tq.<span class="built_in">query</span>(s)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><h3 id="TextQuery框架"><a href="#TextQuery框架" class="headerlink" title="TextQuery框架"></a>TextQuery框架</h3><p>​        首先是TextQuery，用用户提供的一个istream读取文件，类中应该还有query操作，接受string，返回QueryResult表示string出现的行。我们创建一个头文件命名为textquery，在其中输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEXTQUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXTQUERY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span><span class="comment">// 为了定义函数query的返回类型，这个定义是必需的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//简化行下标</span></span><br><span class="line">	<span class="keyword">using</span> line_no = vector&lt;string&gt;::size_type;</span><br><span class="line">	<span class="comment">//通过用户提供的文本的构造函数</span></span><br><span class="line">	<span class="built_in">TextQuery</span>(std::ifstream&amp;);</span><br><span class="line">	<span class="comment">//返回查询结果的函数，由于只是查询所以应该加上const</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> string&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//输入的文件</span></span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;</span><br><span class="line">	<span class="comment">//每个单词到它所在的行号的集合的映射</span></span><br><span class="line">	std::map&lt;string, shared_ptr&lt;std::set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​        至于这里为什么出现这么多的std，而不是直接引入整个命名空间：在头文件这样做是非常危险的，由于C++头文件通常与源文件分开存放，对于不知道这个头文件里有什么的用户来说，使用这个头文件就有可能会导致很多的命名冲突。这里建议在任何文件中都不要这样做。</p>
<h3 id="QueryResult框架"><a href="#QueryResult框架" class="headerlink" title="QueryResult框架"></a>QueryResult框架</h3><p>​        QueryResult类有三个数据成员：一个string，保存查询单词：一个shared_ptr，指向保存输入文件的vector；一个shared ptr，指向保存单词出现行号的set。它唯一的一个成员函数是一个构造函数，初始化这三个数据成员。在刚才的类之后，紧接着写入以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">    <span class="comment">//将ostream声明为友元函数，之后用来打印结果</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">QueryResult</span>(string s,</span><br><span class="line">		shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; p,</span><br><span class="line">		shared_ptr&lt;vector&lt;string&gt;&gt; f) :</span><br><span class="line">		<span class="built_in">sought</span>(s), <span class="built_in">lines</span>(p), <span class="built_in">file</span>(f) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 查询单词</span></span><br><span class="line">	string sought; 							</span><br><span class="line">    <span class="comment">//出现的行号</span></span><br><span class="line">	shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; lines;</span><br><span class="line">    <span class="comment">//输入文件</span></span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;		 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里为什么不在TextQuery类之前那里写呢？因为这个类中我们用到了TextQuery中的line_no，这两个类其实是你中有我，我中有你的关系，所以我们在开头需要一个声明，在之后去定义他。</p>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><h3 id="TextQuery构造函数"><a href="#TextQuery构造函数" class="headerlink" title="TextQuery构造函数"></a>TextQuery构造函数</h3><p>接下来是类的实现，我们创建一个源文件，取名为textquery.cpp，首先是构造函数，直接写入代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取输入文件并建立单词到行号的映射</span></span><br><span class="line">TextQuery::<span class="built_in">TextQuery</span>(std::ifstream&amp; is) : <span class="built_in">file</span>(<span class="keyword">new</span> vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	string text;</span><br><span class="line">	<span class="comment">//对文件中每一行</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(is, text)) &#123;</span><br><span class="line">		<span class="comment">//保存此行文本</span></span><br><span class="line">		file-&gt;<span class="built_in">push_back</span>(text);</span><br><span class="line">		<span class="comment">//当前行号</span></span><br><span class="line">		<span class="keyword">int</span> n = file-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//将行文本分解为单词</span></span><br><span class="line">		<span class="function">std::istringstream <span class="title">line</span><span class="params">(text)</span></span>;</span><br><span class="line">		string word;</span><br><span class="line">		<span class="comment">//对行中每个单词</span></span><br><span class="line">		<span class="keyword">while</span> (line &gt;&gt; word) &#123;</span><br><span class="line">			<span class="comment">//如果单词不在 wm 中，以之为下标在wm中添加一项</span></span><br><span class="line">			<span class="comment">// lines是一个shared_ptr</span></span><br><span class="line">			<span class="keyword">auto</span>&amp; lines = wm[word];</span><br><span class="line">			<span class="keyword">if</span> (!lines)</span><br><span class="line">				<span class="comment">//分配一个新的set</span></span><br><span class="line">				lines.<span class="built_in">reset</span>(<span class="keyword">new</span> set&lt;line_no&gt;);</span><br><span class="line">			lines-&gt;<span class="built_in">insert</span>(n);<span class="comment">//将此行号插入set中</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到在函数体之前就已经为file分配了动态内存，同时由于file是指针类型这里需要使用-&gt;来使用push函数，之后使用istringstream处理当前这一行的字符，按空格存入word内，在第二个while循环中，首先定义lines获取在map中的这个单词的set容器，注意这里line是一个只能指针类型，由于有可能是第一次录入改单词，则需要对line进行判断，若不存在则需要新分配一个set，这里同样需要动态的分配内存。最后不论一定要将则一行的行号传入这个set容器中。</p>
<h3 id="query函数"><a href="#query函数" class="headerlink" title="query函数"></a>query函数</h3><p>它接受一个string参数，用它在map中对应行号，如果找到就构造一个QueryResult返回。这里有一个问题是如果没有找到返回什么呢？我们可以定义一个局部的static对象，它指向空的行号set的shared_ptr，没有找到就返回它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(<span class="keyword">const</span> string&amp; sought)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果未找到sought，我们将返回一个指向此set的指针</span></span><br><span class="line">	<span class="keyword">static</span> shared_ptr&lt;set&lt;line_no&gt;&gt; <span class="built_in">nodata</span>(<span class="keyword">new</span> set&lt;line_no&gt;);</span><br><span class="line">	<span class="comment">//使用find而不是下标运算符来查找单词，避免将单词添加到wm中!</span></span><br><span class="line">	<span class="keyword">auto</span> loc = wm.<span class="built_in">find</span>(sought);</span><br><span class="line">	<span class="keyword">if</span> (loc == wm.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">QueryResult</span>(sought, nodata, file);<span class="comment">//未找到</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">QueryResult</span>(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果ctr的值大于1，返回word的复数形式</span></span><br><span class="line"><span class="function">string <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr, <span class="keyword">const</span> string &amp;word, <span class="keyword">const</span> string &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ctr &gt; <span class="number">1</span>) ? word + ending : word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="keyword">const</span> QueryResult&amp; qr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; qr.lines-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">make_plural</span>(qr.lines-&gt;<span class="built_in">size</span>(), <span class="string">&quot;time&quot;</span>, <span class="string">&quot;s&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : *qr.lines)</span><br><span class="line">		<span class="comment">//避免行号从0开始给用户带来的困惑</span></span><br><span class="line">		os &lt;&lt; <span class="string">&quot;\t (line &quot;</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">&quot;)&quot;</span></span><br><span class="line">		<span class="comment">//使用标准库:文本查询程序</span></span><br><span class="line">		&lt;&lt; *(qr.file-&gt;<span class="built_in">begin</span>() + num) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文本查询程序2-0"><a href="#文本查询程序2-0" class="headerlink" title="文本查询程序2.0"></a>文本查询程序2.0</h1><p>利用C++继承与多态的性质改进该类， 以实现更多功能。</p>
<h2 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h2><ul>
<li><p>单词查询，用于得到匹配某个给定string的所有行:</p>
<p>Executing Query for: Daddy<br>Daddy occurs 3 times<br>(line 2) Her Daddy says when the wind blows<br>(line 7) “Daddy , shush, there is no such thing , “<br>(line 10) shyly, she asks,”I mean,Daddy ,is there?”</p>
</li>
<li><p>逻辑非查询，使用~运算符得到不匹配查询条件的所有行:</p>
<p>Executing Query for: ~(Alice)<br>~(Alice) occurs 9 times<br>( line 2) Her Daddy says when the wind blows<br>(line 3) through her hair, it looks almost alive,( line 4) like a fiery bird in flight.</p>
</li>
<li><p>逻辑或查询，使用|运算符返回匹配两个条件中任意一个的行:</p>
<p>Executing Query for: (hair l Alice)<br>(hair \ Alice) occurs 2 times<br>(line 1) Alice Emma has long flowing red hair.(line 3) through her hair, it looks almost alive,</p>
</li>
<li><p>逻辑与查询，使用&amp;运算符返回匹配全部两个条件的行:</p>
<p>Executing query for: (hair &amp; Alice)<br>(hair &amp;Alice) occurs 1 time<br>(line 1)Alice Emma has long f1owing red hair.</p>
</li>
<li><p>此外，我们还希望能够混合使用这些运算符，比如:fiery &amp; bird l wind</p>
<p>Executing Query for: ((fiery &amp; bird)l wind)                                                                                                                ( (fiery &amp; bird) l wind) occurs 3 times<br>(line 2) Her Daddy says when the wind blows                                                                                                        (line 4) like a fiery bird in flight.<br>(line 5) A beautiful fiery bird, he tells her ,</p>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们可以将集中不同的查询建模成相互独立的类，它们共享一个公共基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wordQuery		<span class="comment">// Daddy</span></span><br><span class="line">NotQuery		<span class="comment">// ~Alice</span></span><br><span class="line">orQuery			<span class="comment">// hair l Alice</span></span><br><span class="line">AndQuery		<span class="comment">// hair &amp; Alice</span></span><br></pre></td></tr></table></figure>

<p>这些类将只包含两个操作:</p>
<ul>
<li>eval，接受一个TextQuery对象并返回一个 QueryResult，eval函数使用给定的TextQuery对象查找与之匹配的行。</li>
<li>rep，返回基础查询的string表示形式，eval函数使用rep创建一个表示匹配结果的QueryResult，输出运算符使用rep打印查询表达式。</li>
</ul>
<p><strong>关键概念:继承与组合</strong></p>
<p>继承体系的设计本身是一个非常复杂的问题,已经超出了本书的范围。然而,有一条设计准则非常重要也非常基础，每个程序员都应该熟悉它。</p>
<p>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种(IsA)”关系。在设计良好的类体系当中，公有派生类的对象应该可以用在任何需要基类对象的地方。</p>
<p>类型之间的另一种常见关系是“有一个(Has A)”关系，具有这种关系的类暗含成员的意思。</p>
<p>在我们的书店示例中，基类表示的是按规定价格销售的书籍的报价。Bulk_quote“是一种”报价结果，只不过它使用的价格策略不同。我们的书店类都“有一个”价格成员和ISBN成员。</p>
<h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>由于这四种查询并不存在继承关系，从概念上来说互为熊底，它们都共享同一个接口，我们定义一个抽象基类Query_base，并把eval和rep定义为纯虚函数。</p>
<p><img src="https://s2.loli.net/2022/02/18/WJghfcmUL6SvKPE.png" alt="image.png"></p>
<h4 id="将层次关系隐藏于接口类中"><a href="#将层次关系隐藏于接口类中" class="headerlink" title="将层次关系隐藏于接口类中"></a>将层次关系隐藏于接口类中</h4><p>我们的程序将致力于计算查询结果，而非仅仅构建查询的体系。为了使程序能正常运行，我们必须首先创建查询命令，最简单的办法是编写C++表达式。例如，可以编写下面的代码来生成之前描述的复合查询:</p>
<p><code>Query q = Query(&quot;fiery&quot;) &amp; Query (&quot;bird&quot;) | Query ( &quot;wind&quot; ) ;</code></p>
<p>用户不会直接使用这些类，而是使用Query保存一个Query_base指针，用户将通过 Query 对象的操作间接地创建并处理Query _base对象。我们定义Query对象的三个重载运算符以及一个接受string参数的Query构造函数，这些函数动态分配一个新的Query base派生类的对象:</p>
<ul>
<li><code>&amp;</code>运算符生成一个绑定到新的AndQuery对象上的Query对象;</li>
<li><code>|</code>运算符生成一个绑定到新的orQuery对象上的Query对象;</li>
<li><code>~</code>运算符生成一个绑定到新的NotQuery对象上的Query对象;</li>
<li>接受string 参数的Query构造函数生成一个新的wordQuery对象。</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/18/RcP7iGoENgdhuf9.png" alt="image.png"></p>
<h2 id="Query-base类和Query类"><a href="#Query-base类和Query类" class="headerlink" title="Query_base类和Query类"></a>Query_base类和Query类</h2><p>首先定义Query_base类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个抽象基类，具体的查询类型从中派生，所有成员都是private的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> line_no = TextQuery: :line_no; <span class="comment">//用于eval函数virtual ~Query_base() = default;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// eval返回与当前Query 匹配的QueryResult</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// rep是表示查询的一个string</span></span><br><span class="line">	<span class="keyword">virtual</span> std: :<span class="function">string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把所有操作都纯虚函数，因此Query_base是一个抽象基类，因为不直接使用它，所有没有public成员。</p>
<h4 id="Query类"><a href="#Query类" class="headerlink" title="Query类"></a>Query类</h4><p>它负责提供外界的接口，并隐藏继承体系。每个Query对象都含有一个指向Query_base对象的智能指针。</p>
<p>接受一个string参数的Query构造函数将创建一个新的wordQuery对象，然后将它的 shared_ prt成员绑定到这个新创建的对象上。&amp;、|和~运算符分别创建AndQuery、OrQuery和 NotQuery对象，这些运算符将返回一个绑定到新创建的对象上的Query对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个管理Query base继承体系的接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">	<span class="comment">//这些运算符需要访问接受shared _ptr的构造函数，而该函数是私有的</span></span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~ (<span class="keyword">const</span> Query &amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>/ (<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp; (<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;); </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Query</span>(<span class="keyword">const</span> std: :string&amp;);															</span><br><span class="line">	<span class="comment">//构建一个新的wordouery</span></span><br><span class="line">	<span class="comment">//接口函数:调用对应的Query base操作</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; t)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q-&gt;<span class="built_in">eval</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	std: :<span class="function">string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> q-&gt;<span class="built_in">rep</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Query</span>(std: :shared_ptr&lt;Query_base&gt; query) : <span class="built_in">q</span>(query)&#123; &#125;</span><br><span class="line">	std: :shared_ptr&lt;Query_base&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Query-的输出运算符"><a href="#Query-的输出运算符" class="headerlink" title="Query 的输出运算符"></a>Query 的输出运算符</h3><p>输出运算符可以很好地解释我们的整个查询系统是如何工作的:std: :ostream &amp;<br>operator&lt;&lt;(std: :ostream &amp;os,const Query &amp;query)<br>/ / Query: :rep通过它的Query base指针对rep ()进行了虚调用return os&lt;&lt;query.rep (;<br>当我们打印一个 Query时，输出运算符调用Query类的公有rep成员。运算符函数通过指针成员虚调用当前Query所指对象的rep成员。也就是说，当我们编写如下代码时:<br>Query andq = Query (sought1) &amp;Query (sought2 );<br>cout &lt;&lt; andq &lt;&lt; endl;<br>输出运算符将调用andq 的 Query: :rep,而 Query: :rep通过它的Query base指针虚调用Query _base版本的rep函数。因为andq指向的是一个AndQuery对象，所以本次的函数调用将运行AndQuery: : rep。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十四章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-06T00:00:00+08:00">2022-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:57:59" itemprop="dateModified" datetime="2022-03-04T12:57:59+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>它们由关键字operato和其后要定义的运算符号组成，其他和函数相同。当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显式)参数数量比运算对象的数量少一个。</p>
<p>我们只能重载<strong>一部分</strong>的<strong>已有</strong>运算符。对于重载的运算符，优先级和结合律与对应内置运算符（原先的）保持一致（不考虑运算对象）。</p>
<h4 id="调用重载运算符"><a href="#调用重载运算符" class="headerlink" title="调用重载运算符"></a>调用重载运算符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个非成员运算符函数的等价调用</span></span><br><span class="line">datal + data2 ;<span class="comment">//普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);<span class="comment">//等价的函数调用</span></span><br></pre></td></tr></table></figure>

<p>也可以像调用成员函数一样调用它们</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datal +=data2;				<span class="comment">//基于“调用”的表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+= (data2);	<span class="comment">//对成员运算符函数的等价调用</span></span><br></pre></td></tr></table></figure>

<h4 id="某些运算符不应被重载"><a href="#某些运算符不应被重载" class="headerlink" title="某些运算符不应被重载"></a>某些运算符不应被重载</h4><p>通常情况下,不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p>
<h4 id="使用与内置类型一致的含义"><a href="#使用与内置类型一致的含义" class="headerlink" title="使用与内置类型一致的含义"></a>使用与内置类型一致的含义</h4><p>如果类的操作与运算符相关，才适合重载它们：</p>
<ol>
<li>如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致。</li>
<li>如果类的某个操作是检查相等性，则定义 operator==;如果类有了operator==，意味着它通常也应该有operator!=。</li>
<li>如果类包含一个内在的单序比较操作，则定义 operator&lt;;如果类有了operator&lt;，则它也应该含有其他关系操作。</li>
<li>重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容:逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。</li>
</ol>
<p><em>尽量明智的重载它们，使操作符保持原有的操作逻辑</em></p>
<h4 id="赋值和复合赋值运算符"><a href="#赋值和复合赋值运算符" class="headerlink" title="赋值和复合赋值运算符"></a>赋值和复合赋值运算符</h4><p>例如类中有+和=运算符那么最好也重载+=。</p>
<h4 id="选择成员或非成员"><a href="#选择成员或非成员" class="headerlink" title="选择成员或非成员"></a>选择成员或非成员</h4><p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择:·</p>
<ol>
<li>赋值(=)、下标（[ ])、调用（( )）和成员访问箭头(-&gt;)运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员,但并非必须,这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ol>
<p>如果希望在含有混合类型的表达式中使用对称性运算符，例如求int和doubie的和，因为它们都可以是第一个运算对象。所以必须定义为非成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;<span class="comment">//正确:我们能把一个const char*加到一个string对象中</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">//如果+是string 的成员，则产生错误</span></span><br></pre></td></tr></table></figure>

<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>输出运算符的第一个形参是非常量的ostream对象的引用。非常量是因为向流写入内容会改变其状态；使用引用是我们无法赋值一个ostream对象。</p>
<h4 id="Sales-data的输出运算符"><a href="#Sales-data的输出运算符" class="headerlink" title="Sales_data的输出运算符"></a>Sales_data的输出运算符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; item.<span class="built_in">isbn</span> () &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">		&lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前类内的print函数一样，打印一个Sales_data类意味着打印三个数据成员。</p>
<h4 id="输出运算符尽量减少格式化"><a href="#输出运算符尽量减少格式化" class="headerlink" title="输出运算符尽量减少格式化"></a>输出运算符尽量减少格式化</h4><p>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
<h4 id="输入输出运算符必须是非成员函数"><a href="#输入输出运算符必须是非成员函数" class="headerlink" title="输入输出运算符必须是非成员函数"></a>输入输出运算符必须是非成员函数</h4><p>与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sales data data;</span><br><span class="line">data &lt;&lt; cout;		<span class="comment">//如果 operator&lt;&lt;是sales_data的成员</span></span><br></pre></td></tr></table></figure>

<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<h4 id="Sale-data的输入运算符"><a href="#Sale-data的输入运算符" class="headerlink" title="Sale_data的输入运算符"></a>Sale_data的输入运算符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> price; <span class="comment">// 不需要初始化，因为我们将先读入数据到price，之后才使用它</span></span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	<span class="keyword">if</span>(is)<span class="comment">//检查输入是否成功</span></span><br><span class="line">		item. revenue = item. units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		item = <span class="built_in">Sales_data</span> () ;<span class="comment">//输入失败:对象被赋予默认的状态return is;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if的判断检查读取操作是否成功，这样如果发生了错误，则运算符将给定的对象重置为空。</p>
<p><strong>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</strong></p>
<h4 id="输入时的错误"><a href="#输入时的错误" class="headerlink" title="输入时的错误"></a>输入时的错误</h4><p>执行输入时有可能发生错误：</p>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。例如在读取完bookNo后，输入运算符假定接下来读入的是两个数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都将失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<p>前面的函数中，没有诸葛检查读取操作，而是读取了所有数据后赶在使用这些数据前一次性检查。失败后的price的值是未定义的。所以只需要在错误时默认初始化这个对象</p>
<p><strong>当读取操作发生错误时,输入运算符应该负责从错误中恢复。</strong></p>
<h4 id="标示错误（略）"><a href="#标示错误（略）" class="headerlink" title="标示错误（略）"></a>标示错误（略）</h4><h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
<p>如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是<strong>使用复合赋值来定义算术运算符</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设两个对象指向同一本书</span></span><br><span class="line">sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> sales_data &amp;lhs,<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	sales_data sum = lhs;	<span class="comment">//把lhs的数据成员拷贝给sum</span></span><br><span class="line">	sum += rhs;				<span class="comment">//将rhs加到sum中</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs,<span class="keyword">const</span> sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  lhs.<span class="built_in">isbn</span> () == rhs.<span class="built_in">isbn</span> () &amp;&amp;</span><br><span class="line">			lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">       		lhs.revenue == rhs.revenue;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs,<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !( lhs==rhs ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中体现的设计准则：</p>
<ul>
<li>如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数:因为用户肯定希望能使用==比较对象，所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了==运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下，相等运算符应该具有传递性，换句话说，如果a==b和 b==c都为真，则a==c也应该为真。</li>
<li>如果类定义了operator==，则这个类也应该定义operator!=。对于用户来说，当他们能使用==时肯定也希望能使用!=，反之亦然。</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个,这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>如果存在唯一一种逻辑可靠的&lt;定义,则应该考虑为这个类定义&lt;运算符。如果类同时还包含==,则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>除了拷贝赋值和移动赋值外，还可以定义其他赋值运算吧别的对象作为右侧对象。例如vector接受花括号元素列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">= &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//可以把运算符添加到StrVec</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	strVec &amp;<span class="keyword">operator</span>=(std::initializer_list&lt;std::string&gt;);</span><br><span class="line">    <span class="comment">//其他成员与13.5节（第465页）一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">strVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//alloc_n_copy分配内存空间并从给定范围内拷贝元素</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span> (), il.<span class="built_in">end</span> () );</span><br><span class="line">    <span class="built_in">free</span> ( );				<span class="comment">//销毁对象中的元素并释放内存空间</span></span><br><span class="line">	elements = data.first;	<span class="comment">//更新数据成员使其指向新空间</span></span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和其他赋值函数一样需要先释放当前内存空间，创建一片新的空间，不同之处是，无需检查对象向自身的赋值。</p>
<p><strong>我们可以重载赋值运算符。不论形参的类型是什么,赋值运算符都必须定义为成员函数。</strong></p>
<h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h4><p>复合运算符不一定是类成员，不过倾向于把包括复合在内的所有运至运算都定义在类的内部，与内置类型保持一致。复合赋值也要返回左侧对象的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为成员的二元运算符:左侧运算对象绑定到隐式的this指针//假定两个对象表示的是同一本书</span></span><br><span class="line">sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>它必须是成员函数。它通常以访问元素的引用作为返回值，这样可以出现在赋值运算的任意一端。此外，如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string&amp; <span class="keyword">operator</span>[] (std::<span class="keyword">size_t</span> n)</span><br><span class="line">		&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">	<span class="keyword">const</span> std::string&amp; <span class="keyword">operator</span>[] (std::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">		&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">	<span class="comment">//其他成员与13.5（第465页）一致</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *elements;	<span class="comment">//指向数组首元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这两个下标运算符用法类似vector或者数组中的下标，非常量可以赋值，而常量不可以赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设svec是一个StrVec对象</span></span><br><span class="line"><span class="keyword">const</span> Strvec cvec = svec;		<span class="comment">//把svec 的元素拷贝到cvec中</span></span><br><span class="line"><span class="comment">//如果svec中含有元素，对第一个元素运行string 的 empty函数</span></span><br><span class="line"><span class="keyword">if</span> (svec.<span class="built_in">size</span>() &amp; &amp; svec[<span class="number">0</span>].<span class="built_in">empty</span>())&#123;</span><br><span class="line">&#123;</span><br><span class="line">	svec[<span class="number">0</span>]= <span class="string">&quot;zero&quot;</span>;		<span class="comment">//正确:下标运算符返回string的引用</span></span><br><span class="line">	cvec[<span class="number">0</span>]= <span class="string">&quot;Zip&quot;</span>;			<span class="comment">//错误:对cvec取下标返回的是常量引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>因为这两个运算符改变的是操作对象的状态，所以建议将其设定为成员函数。</p>
<p><strong>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</strong></p>
<h4 id="定义前置递增-递减"><a href="#定义前置递增-递减" class="headerlink" title="定义前置递增/递减"></a>定义前置递增/递减</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//递增和递减运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>++();			<span class="comment">//前置运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	<span class="comment">//其他成员和之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置版本:返回递增/递减对象的引用</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">	<span class="comment">//如果curr已经指向了容器的尾后位置，则无法递增它</span></span><br><span class="line">	<span class="built_in">check</span> (curr, <span class="string">&quot;increment past end of StrBlobPtr&quot;</span> );++curr;</span><br><span class="line">	<span class="comment">//将curr在当前状态下向前移动一个元素</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()&#123;</span><br><span class="line">	<span class="comment">//如果curr是0，则继续递减它将产生一个无效下标--curr;</span></span><br><span class="line">	<span class="comment">//将curr在当前状态下向后移动一个元素</span></span><br><span class="line">	<span class="built_in">check</span> (curr,<span class="string">&quot;decrement past begin of StrBlobPtr&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定要注意检查递增递减后的值是否还有意义，且最好返回引用。</p>
<h4 id="区分前置和后置"><a href="#区分前置和后置" class="headerlink" title="区分前置和后置"></a>区分前置和后置</h4><p>因为普通的重载无法区分前置和后置版本，所以后置版本接受一个额外的int类型的形参，使用时编译器提供值为0的形参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//递增和递减运算符</span></span><br><span class="line">	strBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>) ;	<span class="comment">//后置运算符</span></span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>) ;</span><br><span class="line">	<span class="comment">//其他成员和之前的版本一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置版本:递增/递减对象的值但是返回原值</span></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">    strBlobPtr ret = *<span class="keyword">this</span>;	<span class="comment">//记录当前的值</span></span><br><span class="line">	++*<span class="keyword">this</span>;				<span class="comment">//向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">	<span class="keyword">return</span> ret;				<span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查有效性，调用前置递减运算时才需要检查</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;	<span class="comment">//记录当前的值</span></span><br><span class="line">	-―*<span class="keyword">this</span>;				<span class="comment">//向后移动一个元素,前置--需要检查递减的有效性</span></span><br><span class="line">	<span class="keyword">return</span> ret;				<span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置运算符依然调用前置运算符完成，此外由于不需要用到int形参，所以不需要命名。</p>
<h4 id="显示调用后置运算符"><a href="#显示调用后置运算符" class="headerlink" title="显示调用后置运算符"></a>显示调用后置运算符</h4><p>可以通过函数调用方式调用后置版本，但必须传递一个值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(al)</span></span>;		<span class="comment">//p指向a1中的vector</span></span><br><span class="line">p.<span class="keyword">operator</span>++(O);		<span class="comment">//调用后置版本的operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();			<span class="comment">//调用前置版本的operator++</span></span><br></pre></td></tr></table></figure>

<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span></span><br><span class="line">	&#123; </span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">check</span> (curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];		<span class="comment">//(*p)是对象所指的vector</span></span><br><span class="line">    &#125;</span><br><span class="line">	std::string* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span></span><br><span class="line">	&#123;	</span><br><span class="line">        <span class="comment">//将实际工作委托给解引用运算符</span></span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>* ();</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个运算符用法与指针或者vector迭代器操作完全一致，需要检查curr是否在范围内，是的话返回curr所指元素的引用。</p>
<p><strong>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</strong></p>
<h4 id="对箭头返回值的限定"><a href="#对箭头返回值的限定" class="headerlink" title="对箭头返回值的限定"></a>对箭头返回值的限定</h4><p>箭头运算符永远不能丢掉成员访问这个最基本的含义。对于对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;的类的对象。根据point类型的不同，point-&gt;mem分别等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;			<span class="comment">// point是一个内置的指针类型</span></span><br><span class="line">point.<span class="built_in"><span class="keyword">operator</span></span>()-&gt;mem;	<span class="comment">// point是类的一个对象</span></span><br></pre></td></tr></table></figure>

<p>此外，代码都会发生错误，它的执行过程如下：</p>
<ol>
<li>如果point是指针,则我们应用内置的箭头运算符,表达式等价于(*point) .mem.首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类型没有名为mem的成员，程序会发生错误。</li>
<li>如果point是定义了operator-&gt;的类的一个对象,则我们使用point.operator-&gt;()的结果来获取mem。其中，如果该结果是一个指针，则执行第1步;如果该结果本身含有重载的 operator-&gt; ()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。</li>
</ol>
<p><strong>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</strong></p>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>它使我们可以像调用函数一个调用对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">( )</span> <span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &lt;<span class="number">0</span> ? -val : val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用的过程非常像函数的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absobj;				<span class="comment">//含有函数调用运算符的对象</span></span><br><span class="line"><span class="keyword">int</span> ui = <span class="built_in">absobj</span>(i);			<span class="comment">//将i传递给abs0bj.operator ( )</span></span><br></pre></td></tr></table></figure>

<p><strong>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</strong></p>
<h4 id="含有状态的函数对象类"><a href="#含有状态的函数对象类" class="headerlink" title="含有状态的函数对象类"></a>含有状态的函数对象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Printstring</span>(ostream &amp;o = cout, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>) : <span class="built_in">os</span>(o) , <span class="built_in">sep</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span> </span>&#123; os&lt;&lt;s &lt;&lt; sep; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ostream &amp;os;			<span class="comment">//用于写入的目的流</span></span><br><span class="line">	<span class="keyword">char</span> sep;				<span class="comment">//用于将不同输出隔开的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类有默认构造函数接受一个输出流引用和用于分隔的字符，之后调用运算符使用这些成员来协助打印给定的string。</p>
<p>当定义PrintString的对象时，对于分隔符及输出流既可以使用默认值也可以提供我们自己的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Printstring printer;		<span class="comment">//使用默认值，打印到cout</span></span><br><span class="line"><span class="built_in">printer</span> (s);				<span class="comment">//在cout中打印s，后面跟一个空格</span></span><br><span class="line"><span class="function">Printstring <span class="title">errors</span> <span class="params">(cerr, <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">errors</span>(s);					<span class="comment">//在cerr中打印s，后面跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>函数对象常常作为泛型算法的实参。例如，可以使用标准库for_each 算法（参见10.3.2节，第348页）和我们自己的 PrintString类来打印容器的内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(vs.begin (), vs.end(), PrintString (cerr, <span class="string">&#x27;\n&#x27;</span>) )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>编写lambda后，编译器就将它翻译成一个未命名的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据单词的长度对其进行排序，对于长度相同的单词按照字母表顺序排序</span></span><br><span class="line"><span class="built_in">stable_sort</span> (words. <span class="built_in">begin</span> () , words.<span class="built_in">end</span> (),</span><br><span class="line">				[](<span class="keyword">const</span> string &amp;a, <span class="keyword">const</span> string &amp;b)</span><br><span class="line">             		&#123;freturn a.<span class="built_in">size</span> () &lt; b.<span class="built_in">size</span>();&#125;);</span><br><span class="line"><span class="comment">//其行为类似于下面这个类的一个未命名对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shorterstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> string &amp;s1,<span class="keyword">const</span> string &amp;s2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    	</span>&#123; <span class="keyword">return</span> sl.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用这个类替代 lambda表达式后，我们可以重写并重新调用</span></span><br><span class="line">stable_sort:<span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>() ,<span class="built_in">Shorterstring</span>());</span><br></pre></td></tr></table></figure>

<h4 id="表示lambda及相应的捕获行为的类"><a href="#表示lambda及相应的捕获行为的类" class="headerlink" title="表示lambda及相应的捕获行为的类"></a>表示lambda及相应的捕获行为的类</h4><p>当lambda表达式通过引用捕获变量时，程序确保lambda执行时引用所引用对象存在。这个lambda产生的类未每个值建立对应的数据成员，同时创建构造函数，捕获的值用于初始化变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= Sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span> (words.<span class="built_in">begin</span>() , words.<span class="built_in">end</span>(),[sz] (<span class="keyword">const</span> string &amp;a)</span><br><span class="line">						&#123; <span class="keyword">return</span> a.<span class="built_in">size</span> () &gt;= sz;&#125; );</span><br><span class="line"><span class="comment">//该lambda表达式产生的类将形如:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> &#123;</span></span><br><span class="line">	<span class="built_in">SizeComp</span>(<span class="keyword">size_t</span> n): <span class="built_in">sz</span>(n)&#123; <span class="comment">//该形参对应捕获的变量</span></span><br><span class="line">    <span class="comment">//该调用运算符的返回类型、形参和函数体都与lambda一致</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">		</span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">size_t</span> sZ;</span><br><span class="line">	<span class="comment">//该数据成员对应通过值捕获的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用时必须提供一个实参用于构造函数。</span></span><br><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= sz</span></span><br><span class="line">    <span class="keyword">auto</span> wc = <span class="built_in">find_if</span> (words.<span class="built_in">begin</span> (), words.<span class="built_in">end</span> () , <span class="built_in">sizeComp</span>(sz) );</span><br></pre></td></tr></table></figure>

<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>C++语言中有几种可调用的对象:函数、函数指针、lambda表达式（参见10.3.2节,第346页)、bind创建的对象（参见10.3.4节，第354页）以及重载了函数调用运算符的类</p>
<h4 id="不同类型可以有相同的调用形式"><a href="#不同类型可以有相同的调用形式" class="headerlink" title="不同类型可以有相同的调用形式"></a>不同类型可以有相同的调用形式</h4><p>对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i +j; &#125;</span><br><span class="line"><span class="comment">//lambda，其产生一个未命名的函数对象类</span></span><br><span class="line"><span class="keyword">auto</span> mod = [ ](<span class="keyword">int</span> i, <span class="keyword">int</span> j）&#123; <span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line">struct divide &#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor) &#123;</span><br><span class="line">		<span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然各不相同但共享一种调用形式：<code>int(int,int)</code></p>
<p>我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个函数表(function table）用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。</p>
<p>假定我们的所有函数都相互独立，并且只处理关于 int的二元运算，则map可以定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建从运算符到函数指针的映射关系，其中函数接受两个int、返回一个int</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>(*）(<span class="keyword">int</span> ,<span class="keyword">int</span>) &gt; binops;</span><br><span class="line"><span class="comment">//我们可以按照下面的形式将add的指针添加到binops 中:</span></span><br><span class="line"><span class="comment">//正确:add是一个指向正确类型函数的指针</span></span><br><span class="line">binops.<span class="built_in">insert</span>( &#123; <span class="string">&quot;+&quot;</span>，add&#125; );<span class="comment">//&#123; &quot;+&quot;，add&#125;是一个pair(参见11.2.3节，379页)</span></span><br></pre></td></tr></table></figure>

<p>但是我们不能将mod或者divide存入 binops，因为他们时类类型，所以类型并不匹配。</p>
<h4 id="标准库function类型"><a href="#标准库function类型" class="headerlink" title="标准库function类型"></a>标准库function类型</h4><p>我们可以使用一个名为function的新的标准库类型解决上述问题，function定义在functional头文件中。</p>
<p><img src="https://s2.loli.net/2022/02/15/7iVLtUCMzxBcaTZ.png" alt="image.png"></p>
<p>声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; f1 = add;				<span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; f2= <span class="built_in">divide</span>() ;		<span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i * j; &#125;; <span class="comment">//lambda</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span> (<span class="number">4</span>,<span class="number">2</span>）&lt;&lt;endl;						</span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span> (<span class="number">4</span>,<span class="number">2</span>) &lt;&lt;endl;					</span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span> (<span class="number">4</span>,<span class="number">2</span>) &lt;&lt;endl;					</span><br></pre></td></tr></table></figure>

<p>使用function重新定义map</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列举了可调用对象与二元运算符对应关系的表格</span></span><br><span class="line"><span class="comment">//所有可调用对象都必须接受两个int、返回一个int</span></span><br><span class="line"><span class="comment">//其中的元素可以是函数指针、函数对象或者lambda</span></span><br><span class="line">map&lt;string, function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br></pre></td></tr></table></figure>

<p> 把可调用对象都添加到这个map中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">	&#123; <span class="string">&quot;+&quot;</span>, add&#125; ,					<span class="comment">//函数指针</span></span><br><span class="line">	&#123; <span class="string">&quot;-&quot;</span>, std::minus&lt;<span class="keyword">int</span>&gt; () &#125; ,	<span class="comment">//标准库函数对象</span></span><br><span class="line">	&#123; <span class="string">&quot;/&quot;</span>, <span class="built_in">divide</span> () &#125;,				<span class="comment">//用户定义的函数对象</span></span><br><span class="line">	&#123; <span class="string">&quot;*&quot;</span>, [] (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; H&#125;，<span class="comment">//未命名的lambda</span></span><br><span class="line">    &#123; <span class="string">&quot;%&quot;</span>, mod&#125; &#125;;					<span class="comment">//命名了的lambda对象</span></span><br></pre></td></tr></table></figure>

<p>最后在这个map中使用索引调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binops [ <span class="string">&quot;+&quot;</span>](<span class="number">10</span>，<span class="number">5</span>); <span class="comment">//调用add (10,5)</span></span><br><span class="line">binops [ <span class="string">&quot;-&quot;</span>](<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//使用minus&lt;int&gt;对象的调用运算符</span></span><br><span class="line">binops [ <span class="string">&quot;/&quot;</span>](<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//使用divide对象的调用运算符</span></span><br><span class="line">binops [ <span class="string">&quot;*&quot;</span>](<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//调用lambda函数对象</span></span><br><span class="line">binops [ <span class="string">&quot;%&quot;</span>](<span class="number">10</span>，<span class="number">5</span>); <span class="comment">//调用lambda函数对象</span></span><br></pre></td></tr></table></figure>

<h4 id="重载函数与function"><a href="#重载函数与function" class="headerlink" title="重载函数与function"></a>重载函数与function</h4><p>我们不可以直接向重载的函数名存入function类型的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i +j;&#125;</span><br><span class="line"><span class="function">sales_data <span class="title">add</span> <span class="params">(<span class="keyword">const</span> sales_data&amp;, <span class="keyword">const</span> sales_data&amp;)</span></span>;</span><br><span class="line">map&lt;string, function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>( &#123; <span class="string">&quot;+&quot;</span>, add&#125; );<span class="comment">//错误:哪个add?</span></span><br></pre></td></tr></table></figure>

<p>解决方法是储存一个函数的指针，而不是函数名字</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp)(<span class="built_in">int</span>,<span class="built_in">int</span>) = <span class="keyword">add</span>;			<span class="comment">//指针所指的add是接受两个int的版本</span></span><br><span class="line">binops.insert( &#123; <span class="string">&quot;+&quot;</span>, fp&#125; );		<span class="comment">//正确:fp指向一个正确的add版本</span></span><br><span class="line"><span class="comment">//同样，我们也能使用lambda来消除二义性:</span></span><br><span class="line"><span class="comment">//正确:使用lambda来指定我们希望使用的add版本</span></span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>，[](<span class="built_in">int</span> a, <span class="built_in">int</span> b) (<span class="keyword">return</span> <span class="keyword">add</span>(a,b);&#125; &#125; );</span><br></pre></td></tr></table></figure>

<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换(class-type conversions)，这样的转换有时也被称作用户定义的类型转换（user-defined conversions)。</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>它是类的特殊成员函数，负责将一个类类型转换成其他类型，型式为：<code>operator type() const;</code></p>
<p>其中 type表示某种类型。类型转换运算符可以面向任意类型(除了void之外)进行定义，只要该类型能作为函数的返回类型(参见6.1节，第184页)。因此，我们不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。</p>
<p><strong>一个类型转换函数必须是类的成员函数;它不能声明返回类型,形参列表也必须为空。类型转换函数通常应该是const。</strong></p>
<h4 id="定义含类型转换的类"><a href="#定义含类型转换的类" class="headerlink" title="定义含类型转换的类"></a>定义含类型转换的类</h4><p>令表示0到255之间的整数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span> (<span class="keyword">int</span> i = <span class="number">0</span>) : <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span> ( <span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;		<span class="comment">//首先将4隐式地转换成SmallInt，然后调用SmallInt : :operator=</span></span><br><span class="line">si + <span class="number">3</span>;		<span class="comment">//首先将si隐式地转换成int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>

<p>这个类即定义了类类型向其他类型的转换，也有其他类型向类类型的转换（通过内置转为int再转为类类型）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内置类型转换将double实参转换成int</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;			<span class="comment">//调用SmallInt (int)构造函数</span></span><br><span class="line"><span class="comment">//SmallInt的类型转换运算符将si转换成int</span></span><br><span class="line">si + <span class="number">3.14</span>;					<span class="comment">//内置类型转换将所得的int继续转换成double</span></span><br></pre></td></tr></table></figure>

<p>编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。因此，我们可以将任何算术类型传递给SmallInt的构造函数。类似的，我们也能使用类型转换运算符将一个SmallInt对象转换成int，然后再将所得的int转换成任何其他算术类型。</p>
<p>因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp; )</span> </span>;</span><br><span class="line"><span class="comment">//错误:不是成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//错误:指定了返回类型</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;	<span class="comment">//错误:参数列表不为空</span></span><br><span class="line">	<span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">42</span>;&#125;<span class="comment">//错误:42不是一个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>避免过度使用类行转换函数</strong></p>
<h4 id="类型转换可能产生意外的结果"><a href="#类型转换可能产生意外的结果" class="headerlink" title="类型转换可能产生意外的结果"></a>类型转换可能产生意外的结果</h4><p>例如一个像bool类型的转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i; <span class="comment">//如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的!</span></span><br></pre></td></tr></table></figure>

<p>这段程序试图将输出运算符作用于输入流。因为istream本身并没有定义&lt;&lt;，所以本来代码应该产生错误。然而，该代码能使用istream的 bool类型转换运算符将cin转换成bool,而这个bool值接着会被提升成int并用作内置的左移运算符的左侧运算对象。这样一来，提升后的bool值(1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。</p>
<h4 id="显示的类型转换运算符"><a href="#显示的类型转换运算符" class="headerlink" title="显示的类型转换运算符"></a>显示的类型转换运算符</h4><p>为防止上述情况，C++11引入此运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//编译器不会自动执行这一类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和显示构造函数一样，编译器不会将显示的类型转换用于隐式类型转换，使用时就必须显示的进行强制类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;		<span class="comment">//正确:SmallInt的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;					<span class="comment">//错误:此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;<span class="comment">//正确:显式地请求类型转换</span></span><br></pre></td></tr></table></figure>

<p>该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行:</p>
<ul>
<li>if、 while及do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>逻辑非运算符（!)、逻辑或运算符（)、逻辑与运算符（&amp;&amp;）的运算对象</li>
<li>条件运算符（?:）的条件表达式。</li>
</ul>
<h4 id="转换为bool"><a href="#转换为bool" class="headerlink" title="转换为bool"></a>转换为bool</h4><p>无论我们什么时候在条件中使用流对象，都会使用为IO类型定义的operatorbool。例如:<br><code>while (std: :cin &gt;&gt; value)</code><br>while语句的条件执行输入运算符，它负责将数据读入到value并返回cin。为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin的条件状态是good(参见8.1.2节，第280页)，则该函数返回为真;否则该函数返回为假。</p>
<p><strong>向bool的类型转换通常用在条件部分,因此 operator bool 一般定义成explicit的。</strong></p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。</p>
<p>在两种情况下可能产生多重转换路径。</p>
<ul>
<li>第一种情况是两个类提供相同的类型转换:例如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说它们提供了相同的类型转换。</li>
<li>第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。</li>
</ul>
<p><strong>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</strong></p>
<h4 id="实参匹配和相同的类型转换"><a href="#实参匹配和相同的类型转换" class="headerlink" title="实参匹配和相同的类型转换"></a>实参匹配和相同的类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最好不要在两个类之间构建相同的类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">const</span> B&amp;);		<span class="comment">//把一个B转换成A</span></span><br><span class="line">	<span class="comment">//其他数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span><span class="keyword">const</span></span>;	<span class="comment">//也是把一个B转换成A</span></span><br><span class="line">    <span class="comment">//其他数据成员</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">A <span class="title">f</span> <span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">Bb;</span><br><span class="line">A a= <span class="built_in">f</span>(b);	<span class="comment">//二义性错误:含义是f(B:: operator A())</span></span><br><span class="line">			<span class="comment">//还是f(A: :A(const B&amp;))?</span></span><br></pre></td></tr></table></figure>

<p>代码中同时存在两种B获得A的方法，造成编译器无法判断，此时必须显示调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>() ) ;		<span class="comment">//正确:使用B的类型转换运算符</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));					<span class="comment">//正确:使用A的构造函数</span></span><br></pre></td></tr></table></figure>

<p>但最好的办法就是避免此情况</p>
<h4 id="二义性与转换目标的为内置类型的多重转换"><a href="#二义性与转换目标的为内置类型的多重转换" class="headerlink" title="二义性与转换目标的为内置类型的多重转换"></a>二义性与转换目标的为内置类型的多重转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="built_in">A</span> (<span class="keyword">int</span> = <span class="number">0</span>);				<span class="comment">//最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">	<span class="built_in">A</span> (<span class="keyword">double</span>);</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> <span class="keyword">const</span></span>;	 <span class="comment">//最好不要创建两个转换对象都是算术类型的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">( <span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);			<span class="comment">//二义性错误:含义是f(A::operator int ())</span></span><br><span class="line">				<span class="comment">//还是f(A::operator double ()) ?</span></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>g)</span></span>;		<span class="comment">//二义性错误:含义是A::A(int)还是A::A(double)?</span></span><br></pre></td></tr></table></figure>

<p>在对f2的调用中，哪个类型转换都无法精确匹配long double。然而这两个类型转换都可以使用，只要后面再执行一次生成long double的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。</p>
<h4 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h4><p>要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。以下的经验规则可能对你有所帮助:</p>
<ul>
<li>不要令两个类执行相同的类型转换:如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。</li>
<li>避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时,接下来<ul>
<li>不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符,则类型转换操作将转换你的类型的对象,然后使用内置的运算符。</li>
<li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。</li>
</ul>
</li>
</ul>
<p>一言以蔽之:除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。</p>
<h4 id="重载函数与转换构造函数"><a href="#重载函数与转换构造函数" class="headerlink" title="重载函数与转换构造函数"></a>重载函数与转换构造函数</h4><p>举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">	<span class="built_in">c</span> (<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">	<span class="built_in">D</span> (<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span> <span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span> <span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span> (<span class="number">10</span>);<span class="comment">//二义性错误:含义是manip (c(10))还是manip(D(10) )</span></span><br></pre></td></tr></table></figure>

<p><em>如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型,则这通常意味着程序的设计存在不足。</em></p>
<h4 id="重载函数与用户定义的类型转换"><a href="#重载函数与用户定义的类型转换" class="headerlink" title="重载函数与用户定义的类型转换*"></a>重载函数与用户定义的类型转换*</h4><h3 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h3><p>调用对象函数与普通函数不同，如果a时一种类型，则a sym b可能是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. <span class="built_in">operatorsym</span>(b);	<span class="comment">//a有一个operatorsym成员函数</span></span><br><span class="line"><span class="built_in">operatorsym</span>(a,b);	<span class="comment">//operatorsym是一个普通函数</span></span><br></pre></td></tr></table></figure>

<p>但重载的运算符并不能通过调用形式区分成员与非成员函数</p>
<p>当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span></span><br><span class="line">	SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span> (<span class="keyword">int</span> = <span class="number">0</span> ) ;		<span class="comment">//转换源为int的类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">( )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;<span class="comment">//转换目标为int的类型转换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可以使用这个类将两个 smallInt对象相加，但如果我们试图执行混合模式的算术运算，就将遇到二义性的问题:</span></span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;		<span class="comment">//使用重载的operator+</span></span><br><span class="line"><span class="keyword">int</span> i = s3 +<span class="number">0</span> ;				<span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>

<p>第二条加法语句具有二义性：因为我们可以把0转换成smallInt，然后使用smallInt 的+，或者把s3转换成int，然后对于两个int执行内置的加法运算。</p>
<p><strong>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十三章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-27T00:00:00+08:00">2022-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:57:30" itemprop="dateModified" datetime="2022-03-04T12:57:30+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>() ;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Foo</span> (<span class="keyword">const</span> Foo&amp;);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数必须是引用，且通常都是const的，拷贝构造通常是隐式使用，不应该是explicit的。</p>
<h4 id="合成的拷贝构造"><a href="#合成的拷贝构造" class="headerlink" title="合成的拷贝构造"></a>合成的拷贝构造</h4><p>无论我们有没有定义其他拷贝构造，编译器都会自动和合成一个拷贝构造函数。合成的拷贝构造函数会从给定对象中依次将每个非static成员拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定了它如何拷贝:对类类型的成员，会使用其拷贝构造函数来拷贝;内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。</p>
<h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span> <span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(dots)</span> </span>;<span class="comment">//直接初始化</span></span><br><span class="line">string s2 = dots;<span class="comment">//拷贝初始化</span></span><br><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line">string nines = <span class="built_in">string</span> (<span class="number">100</span>,<span class="string">&#x27;9&#x27;</span>) ;<span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>

<p>如果类中有一个移动构造函数，则拷贝初始化有时会使用移动构造而非拷贝构造，所谓移动构造就是指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。所以我们应了解何时发生拷贝构造：</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生·</p>
<ul>
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p>
</li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p>
</li>
<li><p>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>
</li>
</ul>
<p>此外当初始化标准容器或调用insert或push时，会使用拷贝初始化，而emplace成员创建的元素都是直接初始化。</p>
<h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>函数调用过程中，具有非引用类型的参数都要进行拷贝初始化，函数返回值为非引用时，返回值也会被用来做为接受对象拷贝初始化的参数。</p>
<p>所以拷贝初始化的参数必须是引用类型，不然就一直调用也不会成功。</p>
<h4 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h4><p>值初始化和拷贝初始化不是一模一样的，如果使用explicit构造函数，我们就不能隐式的调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//正确:直接初始化</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;<span class="comment">//错误:接受大小参数的构造函数是explicit的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;)</span></span>;<span class="comment">// f的参数进行拷贝初始化</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//错误:不能用一个explicit的构造函数考贝一个实参</span></span><br><span class="line"><span class="built_in">f</span>(vector&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>));<span class="comment">//正确:从一个int直接构造一个临时vector</span></span><br></pre></td></tr></table></figure>

<p>必须显示的调用explicit函数。</p>
<h4 id="编译器可以绕过拷贝构造函数"><a href="#编译器可以绕过拷贝构造函数" class="headerlink" title="编译器可以绕过拷贝构造函数"></a>编译器可以绕过拷贝构造函数</h4><p>拷贝/移动构造可以被忽略，直接创建对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="comment">//改写为</span></span><br><span class="line"><span class="function">string <span class="title">null_book</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>; <span class="comment">//编译器略过了拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>可以跳过拷贝/移动构造，但必须有且可访问。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><h4 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h4><p>重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数（参见7.1.2节，第231页)。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Foo&amp;); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>赋值运算符应该返回一个引用！</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>和前几个构造函数一样，如果类内未定义，就会自动生成。作为一个例子，下面的代码等价于sales_data的合成拷贝赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sales_data&amp; Sales_data::<span class="keyword">operator</span>= (<span class="keyword">const</span> Sales_data &amp;rhs) &#123;</span><br><span class="line">	bookNo = rhs.bookNo;<span class="comment">//调用string : : operator=</span></span><br><span class="line">	units_sold = rhs.units_sold;<span class="comment">//使用内置的int赋值</span></span><br><span class="line">	revenue = rhs.revenue;<span class="comment">//使用内置的double赋值</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回一个此对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它和拷贝构造函数的区别是，拷贝构造是从无到有，而拷贝赋值时本来就有，只是值发生改变。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>它与构造函数相反，构造函数初始化非static数据成员，还有其他工作，析构函数释放对象使用资源，销毁对象非static数据成员。它没有返回值，也不接受参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Foo</span>();<span class="comment">//析构函数</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于没有参数，所以不能被重载。</p>
<h4 id="函数任务"><a href="#函数任务" class="headerlink" title="函数任务"></a>函数任务</h4><p>它所有顺序都与构造函数相反，先执行函数体，然后销毁成员，且按出现次序逆序销毁。且析构部分时隐式的，销毁完全取决与类型。</p>
<p><em>隐式销毁内置指针类型的成员不会delete指向的对象</em></p>
<h4 id="何时调用析构"><a href="#何时调用析构" class="headerlink" title="何时调用析构"></a>何时调用析构</h4><p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line"><span class="comment">// p和p2指向动态分配的对象</span></span><br><span class="line">	Sales_data *p = <span class="keyword">new</span> sales_data;		<span class="comment">// p是一个内置指针</span></span><br><span class="line">	<span class="keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();<span class="comment">// p2是一个shared_ptr</span></span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;	<span class="comment">//拷贝构造函数将*p拷贝到item中</span></span><br><span class="line">	vector&lt;sales_data&gt; vec;	<span class="comment">//局部对象</span></span><br><span class="line">	vec.<span class="built_in">push_back</span> (*p2);	<span class="comment">//拷贝 p2指向的对象</span></span><br><span class="line">    <span class="keyword">delete</span> p;	<span class="comment">//对p指向的对象执行析构函数</span></span><br><span class="line">&#125;<span class="comment">//退出局部作用域;对item、p2和vec调用析构函数</span></span><br><span class="line"><span class="comment">//销毁p2会递减其引用计数;如果引用计数变为0，对象被释放//销毁vec会销毁它的元素</span></span><br></pre></td></tr></table></figure>

<p><em>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</em></p>
<h4 id="合成的析构函数"><a href="#合成的析构函数" class="headerlink" title="合成的析构函数"></a>合成的析构函数</h4><p>概念如前，下面等同合成析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员会被自动销毁，除此之外不需要做其他事情</span></span><br><span class="line">    ~<span class="built_in">Sales_data</span>() &#123; &#125;</span><br><span class="line">	<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><h4 id="需要析构函数的类也需要拷贝和拷贝赋值"><a href="#需要析构函数的类也需要拷贝和拷贝赋值" class="headerlink" title="需要析构函数的类也需要拷贝和拷贝赋值"></a>需要析构函数的类也需要拷贝和拷贝赋值</h4><p>如果一个类需要析构函数，那么肯定也需要一个拷贝函数和一个拷贝赋值运算符。例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std: : string &amp;s = std: :<span class="built_in">string</span> () ):</span><br><span class="line">		<span class="built_in">ps</span>(<span class="keyword">new</span> std: :<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line">	<span class="comment">//错误:HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用合成拷贝，则会简单的拷贝指针成员，则有可能多个对象指向相同内存。</p>
<h4 id="需要拷贝操作的类也需要赋值，反之亦然"><a href="#需要拷贝操作的类也需要赋值，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值，反之亦然"></a>需要拷贝操作的类也需要赋值，反之亦然</h4><p>作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个铂贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是，这个类不需要自定义析构函数。</p>
<h3 id="使用-defult"><a href="#使用-defult" class="headerlink" title="使用=defult"></a>使用=defult</h3><p>这段代码可以显示的要求编译生成合成版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//拷贝控制成员;使用default</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">sales_data</span>(<span class="keyword">const</span> sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    sales_data&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> sales_data &amp;);</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>使用此语句，合成函数将隐式声明为内联，如果不希望是内联的，应该对类外使用它（如上面的拷贝赋值）。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>对于某些类来说，拷贝和赋值时没有意义的，如iostream，所以组织拷贝，以避免多个对象的写入过读取相同的IO缓冲。</p>
<h4 id="定义删除的函数"><a href="#定义删除的函数" class="headerlink" title="定义删除的函数"></a>定义删除的函数</h4><p>通过将拷贝和拷贝赋值函数定义为<strong>删除的函数</strong>来组织拷贝，这是一种我们虽然声明，但不能使用的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">	<span class="built_in">Nocopy</span> () = <span class="keyword">default</span>;	<span class="comment">//使用合成的默认构造函数</span></span><br><span class="line">	<span class="built_in">NoCopy</span>(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">//阻止拷贝</span></span><br><span class="line">	NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Nocopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;	<span class="comment">//使用合成的析构函数</span></span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与=default不同：</p>
<ul>
<li>=delete必须在函数第一次声明的时候出现，而=default知道编译器生成代码时才需要，可以出现在定义处。</li>
<li>另一个是可以对任意函数使用（虽然主要是阻止拷贝），但=default只可以使用在有合成版本的函数。</li>
</ul>
<h4 id="析构函数不能删除"><a href="#析构函数不能删除" class="headerlink" title="析构函数不能删除"></a>析构函数不能删除</h4><p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。所以不可删除。</p>
<h4 id="合成的拷贝控制成员可能是删除的"><a href="#合成的拷贝控制成员可能是删除的" class="headerlink" title="合成的拷贝控制成员可能是删除的"></a>合成的拷贝控制成员可能是删除的</h4><p>本质上，这些规则的含义是:如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。</p>
<h4 id="private拷贝控制"><a href="#private拷贝控制" class="headerlink" title="private拷贝控制"></a>private拷贝控制</h4><p>新标准以前，组织是通过将函数放在private里的，但现在应该使用=delete。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>类行对象有两种拷贝语意，一种像值：拷贝像值对象，副本和源对象完全独立，改变副本不会对源对象有影响，如string。一种像指针：拷贝这种对象，共同使用底层数据，改变自己也会改变源对象，如shared_ptr。</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>像值的行为，每个对象应该拥有一份自己的拷贝。HasPtr</p>
<ul>
<li>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</li>
<li>定义一个析构函数来释放string</li>
<li>定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝string</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">		<span class="built_in">ps</span> (<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="comment">//对ps指向的string，每个HasPtr对象都有自己的拷贝</span></span><br><span class="line">    <span class="built_in">HasPtr</span> (<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">		<span class="built_in">ps</span> (<span class="keyword">new</span> std::<span class="built_in">string</span>(*p.ps)) , <span class="built_in">i</span>(p.i) &#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="类值拷贝赋值运算符"><a href="#类值拷贝赋值运算符" class="headerlink" title="类值拷贝赋值运算符"></a>类值拷贝赋值运算符</h4><p>赋值类运算符通常是组合了析构和构造函数，赋值的操作其实会销毁左侧运算对象的资源，其次需要保证再异常发发生时代码也是安全的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span> ( *rhs.ps); <span class="comment">//拷贝底层string</span></span><br><span class="line">	<span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">	ps = newp;<span class="comment">//从右侧运算对象拷贝数据到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写赋值运算符时，有两点需要记住:</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和铂贝构造函数的工作。</li>
</ul>
<p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后,销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
<p>如果直接删除自身数据，然后将指针指向赋予对象的数据，那么在将自身赋予自身时就会出现访问无效内存的异常。</p>
<h3 id="定义行为像指针"><a href="#定义行为像指针" class="headerlink" title="定义行为像指针"></a>定义行为像指针</h3><p>这个类拷贝指针成员本身不是它指向的string，我们的类拷贝时拷贝的是指针而不是指向的对象。同时在析构时也需要在最后一个指向对象的HasPtr销毁时，销毁对象。</p>
<p>这时就需要一个类似引用计数的东西，类似shared_ptr。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>它的工作方式：</p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
</ul>
<p>计时器不可以放在类中，否则无法正确更新它，最好的办法就是保存在动态内存中，把它当作底层数据，多个对象共享，同样在最后一个指向它的对象销毁时销毁。</p>
<h4 id="定义使用引用计数的类"><a href="#定义使用引用计数的类" class="headerlink" title="定义使用引用计数的类"></a>定义使用引用计数的类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数分配新的string和新的计数器，将计数器置为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span> ()):</span><br><span class="line">		<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p) :</span><br><span class="line">		<span class="built_in">ps</span>(p.ps) , <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123;++*use;&#125;</span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">	~<span class="built_in">HasPtr</span> ();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *ps;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	std::<span class="keyword">size_t</span> *use; <span class="comment">//用来记录有多少个对象共享*ps 的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="拷贝与析构"><a href="#拷贝与析构" class="headerlink" title="拷贝与析构"></a>拷贝与析构</h4><p>当拷贝时，应该复制指针本身，并且递增关联的计数器。析构不能无脑delete，必须注意计数器数量，到0才可以delete。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span> (―-*use ==<span class="number">0</span>)&#123;<span class="comment">//如果引用计数变为0</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">//释放string内存</span></span><br><span class="line">		<span class="keyword">delete</span> use; <span class="comment">//释放计数器内存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	++*rhs.use; <span class="comment">//递增右侧运算对象的引用计数</span></span><br><span class="line">	<span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;<span class="comment">//然后递减本对象的引用计数</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">//如果没有其他用户</span></span><br><span class="line">		<span class="keyword">delete</span> use;<span class="comment">//释放本对象分配的成员</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;	<span class="comment">//将数据从rhs拷贝到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>通常的资源管理类都会有swap函数。如果类定义了自己的swap，算法将使用自定义版本，否则会使用标准库的swap，一次交换操作实际上包含了一次拷贝和两次赋值。如：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp = v1;	//创建v1的值的一个临时副本</span><br><span class="line">v1 = v2.;	//将v2的值赋予v1</span><br><span class="line">v2 = temp;	//将保存的v1的值赋予v2</span><br></pre></td></tr></table></figure>

<p>但理论上可以省取这些内存分配的过程，直接交换指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *temp = v1.ps;	<span class="comment">//为v1.ps中的指针创建一个副本</span></span><br><span class="line">vl.ps = v2.ps;	<span class="comment">//将v2.ps 中的指针赋予v1.ps</span></span><br><span class="line">v2.ps = temp;	<span class="comment">//将保存的v1.ps中原来的指针赋予v2.ps</span></span><br></pre></td></tr></table></figure>

<h4 id="编写swap函数"><a href="#编写swap函数" class="headerlink" title="编写swap函数"></a>编写swap函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp; )</span> </span>;</span><br><span class="line">    <span class="comment">//其他成员定义，与13.2.1节（第 453页）中一样</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(HasPtr &amp;lhs,HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span> (lhs.ps, rhs.ps);	<span class="comment">//交换指针，而不是string数据</span></span><br><span class="line">    <span class="built_in">swap</span> (lhs.i, rhs.i) ;	<span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将swap定义为friend，一遍能够访问HasPtr的数据成员。swap不是必要的，但是重要的优化手段。</p>
<h4 id="与std-swap不同"><a href="#与std-swap不同" class="headerlink" title="与std::swap不同"></a>与std::swap不同</h4><p>使用时不应该加上std::</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span> ( lhs.h, rhs.h) ; <span class="comment">//使用HasPtr版本的swap</span></span><br><span class="line">    <span class="comment">//交换类型Foo的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在赋值运算中使用swap"><a href="#在赋值运算中使用swap" class="headerlink" title="在赋值运算中使用swap"></a>在赋值运算中使用swap</h4><p>定义swap后会用来用它定义赋值运算符。是将左侧对象与右侧对象的副本进行交换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数</span></span><br><span class="line"><span class="comment">//将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交换左侧运算对象和局部变量rhs的内容</span></span><br><span class="line">	<span class="built_in">swap</span> (*<span class="keyword">this</span>, rhs);	<span class="comment">// rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//rhs被销毁，从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此版本参数不是引用，因此右侧传递进来的是一个副本，所以不需要额外的拷贝操作，它保证异常安全的同时也与原来的赋值运算实现一样。</p>
<h2 id="拷贝控制示例（单独成章）"><a href="#拷贝控制示例（单独成章）" class="headerlink" title="拷贝控制示例（单独成章）"></a>拷贝控制示例（单独成章）</h2><h2 id="动态内存管理类（单独成章）"><a href="#动态内存管理类（单独成章）" class="headerlink" title="动态内存管理类（单独成章）"></a>动态内存管理类（单独成章）</h2><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准中有可以移动而非拷贝的能力。很多时候对象拷贝完立刻被销毁了，移动可以大大提升性能。移动的另一个原因是源于IO类或unique_ptr这样的类包含不能被共享的资源，所以可以移动不能拷贝。</p>
<p><em>标准库容器、string和shared ptr类既支持移动也支持拷贝。IO类和unique ptr类可以移动但不能拷贝。</em></p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>符号为&amp;&amp;，它必须绑定到右值且只能绑定到一个将要销毁的对象，所以可以自由的移动到另一个对象中。</p>
<p>回忆左值和右值：一般而言，一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值。</p>
<p>右值引用也不过是对象的另一个名字，对于常规引用，我们可以称之为左值引用。</p>
<p>区别：我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;<span class="keyword">int</span> &amp;r n i;	<span class="comment">//正确:r引用i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;			<span class="comment">//错误:不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;		<span class="comment">//错误:i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>;<span class="comment">//正确:我们可以将一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;		<span class="comment">//正确:将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。<ul>
<li>我们可以将一个左值引用绑定到这类表达式的结果上。</li>
</ul>
</li>
<li>返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。<ul>
<li>我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const的左值引用或者一个右值引用绑定到这类表达式上。</li>
</ul>
</li>
</ul>
<h4 id="左值持久：右值短暂"><a href="#左值持久：右值短暂" class="headerlink" title="左值持久：右值短暂"></a>左值持久：右值短暂</h4><p>考察左值和右值表达式的列表，两者相互区别之处就很明显了:左值有持久的状态,而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。所以</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<h4 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h4><p>变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是,我们不能将一个右值引用绑定到一个右值引用类型的变量上,这有些令人惊讶:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;<span class="comment">//正确:字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">//错误:表达式rr1是左值!</span></span><br></pre></td></tr></table></figure>

<p>其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。</p>
<h4 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h4><p>虽然不能将右值引用绑定到左值，但可以显示将左值转换为对应右值引用类型，我们可以调用move来获得绑定到左值上的右值引用，在头文件utility中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span> (rr1); l l ok</span><br></pre></td></tr></table></figure>

<p>move对左值使用之后，可以像右值一样处理，但之后除了赋值或者销毁它外，但不能使用该对象的值。且应该直接使用std::move。</p>
<h3 id="移动构造和移动赋值函数"><a href="#移动构造和移动赋值函数" class="headerlink" title="移动构造和移动赋值函数"></a>移动构造和移动赋值函数</h3><p>我们可以为自己的类定义移动操作，他们就是从给定对象窃取而不是拷贝资源。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态—–销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源—–这些资源的所有权已经归属新创建的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strVec::<span class="built_in">strVec</span> (strVec &amp;&amp;s) <span class="keyword">noexcept</span><span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line"><span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">	: <span class="built_in">elements</span> (s.elements), <span class="built_in">first_free</span> (s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">	s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与拷贝构造函数不同，移动构造函数不分配任何新内存;它接管给定的Strvec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。strVec的析构函数在first_free 上调用deallocate。如果我们忘记了改变s.first free，则销毁移后源对象就会释放掉我们刚刚移动的内存。</p>
<h4 id="移动操作与异常"><a href="#移动操作与异常" class="headerlink" title="移动操作与异常"></a>移动操作与异常</h4><p>由于移动操作不分配任何资源，所以不会抛出任何异常，我们应该将此事通知给标准库，提升一些性能消耗。</p>
<p>方法就是在小括号之后冒号之前加上noexcept</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strvec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Strvec</span>(strvec&amp; &amp;)<span class="keyword">noexcept</span>; <span class="comment">//移动构造函数//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">	StrVec::<span class="built_in">StrVec</span> (StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/*成员初始化器*/</span>&#123;<span class="comment">/*构造函数体*/</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p>它与移动构造函数一个，应该标记为noexcept：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//直接检测自赋值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">		<span class="built_in">free</span>();	<span class="comment">//释放已有元素</span></span><br><span class="line">		elements = rhs.elements; <span class="comment">//从rhs接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">		cap = rhs.cap;</span><br><span class="line">		<span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">		rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多了一步操作就是检测this与rhs地址是否相同，也就是是否是同一个对象（这也是赋值运算需要重点考虑的：将自身赋予自身时能否不出错）。如果相同什么都不用做。</p>
<h4 id="移后源可以析构"><a href="#移后源可以析构" class="headerlink" title="移后源可以析构"></a>移后源可以析构</h4><p>编写移动操作必须保证移后对象可析构，在strVec中，将移后源对象的指针成员设置为nullptr来实现。</p>
<h4 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h4><p>编译器不会为某些类生成合成的移动函数，如果没有移动函数，类会使用对应的拷贝操作来代替移动。</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasx合成移动操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;			<span class="comment">//内置类型可以移动</span></span><br><span class="line">	std::string s;	<span class="comment">//string定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasx</span> &#123;</span></span><br><span class="line">	X mem;			<span class="comment">//×有合成的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">X x,x2 = std::<span class="built_in">move</span>(x) ;<span class="comment">//使用合成的移动构造函数</span></span><br><span class="line">hasx hx,hx2 = std::<span class="built_in">move</span> (hx) ;<span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>移动操作只有当我们显示要求编译器生成=default的移动操作而却不是所有成员都可以移动时才会将移动操作定义为删除的函数。</p>
<h4 id="移动右值，拷贝左值"><a href="#移动右值，拷贝左值" class="headerlink" title="移动右值，拷贝左值"></a>移动右值，拷贝左值</h4><p>如果一共类既有移动函数也有拷贝构造函数，那么会根据匹配规则使用，如在strvec类中，拷贝构造函数接受一个 const strvec的引用。因此，它可以用于任何可以转换为strVec的类型。而移动构造函数接受一个strVec&amp;&amp;，因此只能用于实参是（非static）右值的情形:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2 ;</span><br><span class="line">v1 = v2;					<span class="comment">// v2是左值;使用拷贝赋值</span></span><br><span class="line"><span class="function">Strvec <span class="title">getvec</span><span class="params">(istream &amp;)</span></span>;	<span class="comment">// getvec返回一个右值</span></span><br><span class="line">v2 = <span class="built_in">getvec</span> (cin) ;			<span class="comment">// getVec (cin)是一个右值;使用移动赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="如果没有移动构造，会调用拷贝"><a href="#如果没有移动构造，会调用拷贝" class="headerlink" title="如果没有移动构造，会调用拷贝"></a>如果没有移动构造，会调用拷贝</h4><p>由于不会默认合成移动构造，所以用拷贝代替，且是绝对安全的</p>
<h4 id="拷贝赋值和移动赋值合并"><a href="#拷贝赋值和移动赋值合并" class="headerlink" title="拷贝赋值和移动赋值合并"></a>拷贝赋值和移动赋值合并</h4><p>如果为类添加一个移动构造函数，实际上也会获得移动赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//添加的移动构造函数</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : <span class="built_in">ps</span> (p.ps), <span class="built_in">i</span>(p.i)&#123;p.ps = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">//赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">						&#123; <span class="built_in">swap</span> (*<span class="keyword">this</span>, rhs); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="comment">//其他成员的定义，同13.2.1节（第453页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<strong>左值被拷贝，右值被移动</strong>。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。<br>例如，假定hp和 hp2都是HasPtr对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp = hp2; <span class="comment">// hp2是一个左值;hp2通过拷贝构造函数来拷贝</span></span><br><span class="line">hp = std::<span class="built_in">move</span> (hp2);<span class="comment">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>

<p><strong>建议:更新三/五法则</strong><br>所有五个拷贝控制成员应该看作一个整体:一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义持贝构造函数、拷贝赋值运算符和析构函数才能正确工作。一般来说拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十二章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-23T00:00:00+08:00">2022-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:57:32" itemprop="dateModified" datetime="2022-03-04T12:57:32+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部static对象（就是局部对象加上static）、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，在其定义的程序块运行时才存在: static 对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间( free store)或堆(heap)。程序用堆来存储动态分配(dynamically allocate)的对象一即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>在C++中，动态内存的管理是通过一对运算符来完成的: <strong>new</strong>，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化; <strong>delete</strong>, 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
<p>新标准提供了两个智能指针类型类管理动态对象。他们行为类似常规指针，却可以自动的释放锁指向的对象，这两种指针的区别在于管理底层指针的方式：</p>
<p><strong>shared_ ptr</strong>允许多个指针指向同-一个对象; <strong>unique_ ptr</strong>则“独占”所指向的对象。标准库还定义了一个名为<strong>weak_ ptr</strong>的伴随类，它是一种弱引用，指向shared_ ptr所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>创建时我们也需要提供指向的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;				<span class="comment">// shared_ _ptr, 可以指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="keyword">int</span>&gt;&gt; p2;			<span class="comment">// shared_ ptr， 可以指向int的list</span></span><br></pre></td></tr></table></figure>

<p>默认初始化的指针中保存着一个空指针，</p>
<p>智能之后着呢使用方式与普通指针类似，解引用返回指向的对象，在if使用，是检测它是否为空：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果p1不为空，检查它是否指向一个空string</span></span><br><span class="line"><span class="keyword">if</span> (p1 &amp;&amp; pl-&gt;<span class="built_in">empty</span>())</span><br><span class="line">	*p1 = <span class="string">&quot;hi&quot;</span>; 			<span class="comment">//如果p1指向一个空string,解引用p1,将一个新值赋予string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/27/QGMjaLHzpiNKeFV.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/27/UYdeStwyJBpqVKG.png" alt="image.png"></p>
<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><p>他是最安全的分配和使用动态内存的方法，函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，一样要给出创建对象类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向一个值为42的int的shared_ ptr</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="comment">// p4指向一个值为&quot;999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="number">10</span>， <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line"><span class="comment">// p5指向一个值初始化的(参见3.3.1节，第88页)int,即，值为0</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;() ;</span><br></pre></td></tr></table></figure>

<p>通常使用auto来指向它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;() ;</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr拷贝和赋值"><a href="#shared-ptr拷贝和赋值" class="headerlink" title="shared_ptr拷贝和赋值"></a>shared_ptr拷贝和赋值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>

<p>每一个shared_ptr都会有一个关联的计数器，为引用计数。拷贝一个shared_ptr、作为参数传递给函数或者作为返回值就会递增，给shared_ptr赋予新值或者它被销毁计数器会递减。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// r指向的int只有一个引用者</span></span><br><span class="line">r = q;	<span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line">		<span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line">		<span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line">		<span class="comment">// r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr销毁管理对象"><a href="#shared-ptr销毁管理对象" class="headerlink" title="shared_ptr销毁管理对象"></a>shared_ptr销毁管理对象</h4><p>当指向一个对象的最后一个智能指针被销毁，指针的析构函数会递减指向对象的析构函数的引用计数，计数为0，指针的析构函数会销毁对象，释放内存。</p>
<p>且动态对象不再被使用时，shared_ptr类会自动的释放对象，特性使得动态内存的使用变得容易，例如在函数创建智能指针在离开作用域后会自动的释放掉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory 返回一个shared_ ptr, 指向一个动态分配的对象</span></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function">	<span class="comment">//恰当地处理arg</span></span></span><br><span class="line"><span class="function">	<span class="comment">// shared_ ptr负责释放内存</span></span></span><br><span class="line"><span class="function">	<span class="keyword">return</span> make_shared&lt;Foo&gt; <span class="params">(arg)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function">	shared_ptr&lt;Foo&gt; P </span>= <span class="built_in">factory</span>(arg) ;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">&#125; 	<span class="comment">// p离开了作用城，它指向的内存会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<h4 id="使用了动态生存期的资源的类"><a href="#使用了动态生存期的资源的类" class="headerlink" title="使用了动态生存期的资源的类"></a>使用了动态生存期的资源的类</h4><p>程序使用动态内存出于以下三种原因之一:</p>
<ol>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ol>
<p>目前使用的类分配资源都与对应对象生存期一致。例如每个vector拥有自己的元素，当拷贝一个vector时，原vector和副本vector是相互分离的。</p>
<p>如果我们希望有一个类，当它进行拷贝时，不是拷贝其中成员，而是不同对象之间共享相同的元素。所以当两个对象共享底层数据，当其中一个被销毁，我们不能单方面的销毁底层数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;string&gt; bl; <span class="comment">// 空Blob</span></span><br><span class="line">&#123; 	<span class="comment">//新作用域</span></span><br><span class="line">	Blob&lt;string&gt; b2 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">	bl = b2;<span class="comment">//bl和b2共享相同的元素</span></span><br><span class="line">&#125; 	<span class="comment">// b2被销毁了，但b2中的元素不能销毁</span></span><br><span class="line">	<span class="comment">// bl指向最初由b2创建的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="定义StrBlob"><a href="#定义StrBlob" class="headerlink" title="定义StrBlob"></a>定义StrBlob</h4><p>这里想要实现一个StrBlob类管理string元素，如果我们在类内直接使用一个vector来保存元素，那么当多个对象中的一个被销毁时就会把底层vector销毁，所以这里使用vector保存在动态内存中。</p>
<p>为了实现数据共享，我们为StrBlob设置一个shared_ptr来管理动态内存分配的vector。该指针可以记录有多少个StrBlob共享相同的vector。</p>
<p>还需要提供一些操作，当访问一个不存在的元素，会抛出异常，且有一个默认构造和单一构造：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrB1ob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="built_in">StrBlob</span>() ;</span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il) ;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>() ; &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> std: :string &amp;t)</span> </span>&#123;data-&gt;<span class="function">push_ <span class="title">back</span><span class="params">(t)</span></span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string&amp; <span class="title">front</span> <span class="params">()</span> </span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">back</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std::string &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="StrBlob构造函数"><a href="#StrBlob构造函数" class="headerlink" title="StrBlob构造函数"></a>StrBlob构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrBlob::<span class="built_in">StrB1ob</span> (): <span class="built_in">data</span> (make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span> (initializer_list&lt;string&gt; il) :</span><br><span class="line"><span class="built_in">data</span> (make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问成员函数"><a href="#元素访问成员函数" class="headerlink" title="元素访问成员函数"></a>元素访问成员函数</h4><p>由于操作访问函数需要先检查存不存在，所以定义一个私有的工具函数check：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="keyword">const</span> string &amp;msg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(i &gt;= data-&gt;size())</span>	</span></span><br><span class="line"><span class="function">	<span class="keyword">throw</span> <span class="title">out_of_range</span><span class="params">(msg)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他操作首先调用check，如成功则继续下一步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">StrBlob::front</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果vector为空，check 会抛出一个异常</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;front on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span> () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;back on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>) ;</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还应对front和back的const版本进行重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string&amp; <span class="title">StrBlob::front</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果vector为空，check 会抛出一个异常</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;front on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span> () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;back on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StrBlob的拷贝、赋值和销毁"><a href="#StrBlob的拷贝、赋值和销毁" class="headerlink" title="StrBlob的拷贝、赋值和销毁"></a>StrBlob的拷贝、赋值和销毁</h4><p>该类型对象被拷贝’赋值或者销毁时，执行相应操作的是shared_ptr成员而不是vector，直到最后一个指向vector的指针对象被销毁。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>还可以使用new和delete来分配内存，但非常容出错。</p>
<h4 id="使用new动态分配内存和初始化对象"><a href="#使用new动态分配内存和初始化对象" class="headerlink" title="使用new动态分配内存和初始化对象"></a>使用new动态分配内存和初始化对象</h4><p>new分配的内存是无名的，返回一个指向该对象的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; 			<span class="comment">// pi指向一个动态分配的、未初始化的无名对象</span></span><br><span class="line"><span class="comment">// 默认情况下，动态分配内存是默认初始化的，意味着内置类型或组合类型的值是未定义的。</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string; 	<span class="comment">//初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;			<span class="comment">// pi指向一个未初始化的int</span></span><br></pre></td></tr></table></figure>

<p>也可以使用列表初始化，或值初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);			<span class="comment">// pi指向的对象的值为1024</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>， <span class="string">&#x27;9&#x27;</span>);	<span class="comment">// *ps 为&quot;999999999&quot;</span></span><br><span class="line"><span class="comment">// vector 有10个元素，值依次从0到9</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">string *ps1 = <span class="keyword">new</span> string;			<span class="comment">//默认初始化为空string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>() ;			<span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pil = <span class="keyword">new</span> <span class="keyword">int</span>;					<span class="comment">//默认初始化; *pi1 的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();					<span class="comment">//值初始化为0; *pi2为0</span></span><br></pre></td></tr></table></figure>

<p>建议对动态分配的对象进行初始化操作。</p>
<p>如果提供了一个括号包围的初始化器，可以使用auto自动接管动态内存，但括号内必须仅有单一初始化器才可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span> (obj) ;				<span class="comment">// p指向一个与obj类型相同的对象</span></span><br><span class="line"><span class="comment">//该对象用obj进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125; ;				<span class="comment">// 错误:括号中只能有单个初始化器</span></span><br></pre></td></tr></table></figure>

<h4 id="动态分配const对象"><a href="#动态分配const对象" class="headerlink" title="动态分配const对象"></a>动态分配const对象</h4><p>一个动态内存的const对象必须进行初始化，对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显示初始化。new返回的也是一个const指针。</p>
<h4 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h4><p>当程序用光了所有可用内存，new就会失败，会抛出一个bad_alloc的异常，可以改变new的方式来阻止异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>; <span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p>这种new为<strong>定位new</strong>，这种形式允许我们传递额外参数，nothow就是告诉它不能抛出异常。以上类型都在头文件new中。</p>
<h4 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h4><p>我们使用delete来释放内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure>

<p>但传递给delete的指针必须是指向动态分配的内存或空指针，其他行为是未定义的。</p>
<p>const对象的值不能被改变，但是本身可以销毁，同样delete指向它的指针。</p>
<h4 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h4><p>如果不使用智能指针，那么必须显示的释放它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory 返回一个指针，指向一个动态分配的对象</span></span><br><span class="line"><span class="function">Foo* <span class="title">factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//视情况处理arg</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>(arg);	 <span class="comment">// 调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Foo *p = <span class="built_in">factory</span>(arg) ;	<span class="comment">//使用p但不delete它</span></span><br><span class="line">&#125;<span class="comment">//p离开了它的作用域，但它所指向的内存没有被释放!</span></span><br></pre></td></tr></table></figure>

<p>所以必须在use_factory中delete掉这个p，或者return出去让外部释放。</p>
<p><em>坚持使用智能指针，避免所有这些问题。</em></p>
<h4 id="delete之后重置指针"><a href="#delete之后重置指针" class="headerlink" title="delete之后重置指针"></a>delete之后重置指针</h4><p>delete指针之后，指针值就无效了，虽然指针已经无效，但有些仍保存着地址，为<strong>空悬指针</strong>：即指向一块曾经保存数据对象但现在已经无效的内存指针。</p>
<p>它和未初始化指针很像，解决办法是，在指针即将离开其作用域之前释放它所关联的内存，这样没有机会继续使用，也可以在delete之后给其赋值为nullptr。</p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>我们可以用new返回的指针来初始化智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">double</span>&gt; p1; 			<span class="comment">//shared_ ptr可以指向一个double</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; 	<span class="comment">//p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>接受参数的智能指针是explicit的，因此我们不能将一个内置指针隐式转换为智能指针，必须使用直接初始化形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">1024</span>);		<span class="comment">// 错误:必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;			<span class="comment">// 正确:使用了直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p) ; <span class="comment">// 错误:隐式转换为shared ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">shared_ ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> shared_ ptr&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p)) ;<span class="comment">//正确:显式地用int*创建shared_ ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可混用普通与智能指针"><a href="#不可混用普通与智能指针" class="headerlink" title="不可混用普通与智能指针"></a>不可混用普通与智能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>))</span> </span>;</span><br><span class="line"><span class="comment">//危险: x是一个普通指针，不是一个智能指针</span></span><br><span class="line"><span class="built_in">process</span>(x); <span class="comment">//错误:不能将int*转换为一个shared_ ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(shared_ptr&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">// 合法的，但内存会被释放!</span></span><br><span class="line"><span class="keyword">int</span> j = *x;<span class="comment">//未定义的:x是一个空悬指针!</span></span><br></pre></td></tr></table></figure>

<p>将临时的shared_ptr传递给函数，在调用结束后就会被销毁，则x变为空悬指针。</p>
<p>当将一个shared_ptr绑定到一个 普通指针时，我们就将内存的管理责任交给了这个shared_ptr.-旦这样做了 ，我们就不应该再使用内置指针来访问shared__ptr所指向的内存了。</p>
<h4 id="也不要使用get初始化另一个智能指针或者为智能指针赋值"><a href="#也不要使用get初始化另一个智能指针或者为智能指针赋值" class="headerlink" title="也不要使用get初始化另一个智能指针或者为智能指针赋值"></a>也不要使用get初始化另一个智能指针或者为智能指针赋值</h4><p>智能指针定义了名为get的函数，返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况二设计的：是为了不能使用智能指针的代码使用，但此指针不能delete。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//引用计数为1</span></span><br><span class="line"><span class="keyword">int</span> *q = p.<span class="built_in">get</span>(); <span class="comment">//正确:但使用q时要注意，不要让它管理的指针被释放</span></span><br><span class="line">&#123; <span class="comment">//新程序块</span></span><br><span class="line"><span class="comment">//未定义:两个独立的shared_ptr指向相同的内存</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; (q) ;</span><br><span class="line">&#125; <span class="comment">//程序块结束，q被销毁，它指向的内存被释放</span></span><br><span class="line"><span class="keyword">int</span> foo = *p; <span class="comment">//未定义: p指向的内存已经被释放了</span></span><br></pre></td></tr></table></figure>

<h4 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h4><p>使用reset将一个新指针赋予它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>) ;		<span class="comment">//错误:不能将一个指针赋予shared_ ptr</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">1024</span>)) ;	<span class="comment">//正确: p指向一个新对象</span></span><br></pre></td></tr></table></figure>

<p>通常与unique一起使用，控制多个shared_ptr共享的对象，检查自己是当前对象仅有的用户，如果不是，在改变之前要做一次新的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">	p.<span class="built_in">reset</span> (<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">// 我们不是唯一用户;分配新的拷贝</span></span><br><span class="line">*p += newVal; <span class="comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>

<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>在函数中使用智能指针，即使函数发生了异常，局部对象也会被销毁，而如果使用new，则在delete之前出现异常不会自动释放。</p>
<h4 id="智能指针指针和哑类"><a href="#智能指针指针和哑类" class="headerlink" title="智能指针指针和哑类"></a>智能指针指针和哑类</h4><p>有一些为C和C++两种语言设计的类，通常要求用户显示的释放所使用的任何资源。我们可以使用管理动态内存类似的技术管理不具有良好定义的析构函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span>						<span class="comment">//表示我们正在连接什么</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span>						<span class="comment">//使用连接所需的信息</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span> <span class="params">(destination*)</span> </span>;		<span class="comment">//打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connection)</span> </span>;			<span class="comment">//关闭给定的连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/*其他参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获得一个连接;记住使用完后要关闭它</span></span><br><span class="line">	connection C = <span class="built_in">connect</span>(&amp;d) ;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//如果我们在f退出前忘记调用disconnect,就无法关闭c了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果connection没有析构函数，就会造成内存泄漏，可以使用shared_ptr保证connection被正确关闭。</p>
<h4 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h4><p>首先定义一个函数来代替delete，这个<strong>删除器</strong>函数必须能够完成对shared_ptr保存的指针进行释放的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span> <span class="params">(connection *p)</span> </span>&#123; <span class="built_in">disconnect</span>(*p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(destination &amp;d <span class="comment">/*其他参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	connection C = <span class="built_in">connect</span> (&amp;d) ;</span><br><span class="line">	<span class="function">shared_ptr&lt;connection&gt; <span class="title">P</span><span class="params">(&amp;C, end_connection)</span> </span>;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//当f退出时(即使是由于异常而退出), connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当p被销毁时，他会使用end_connection来代替delste，从而确保链接关闭。</p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的<br>前提下。为了正确使用智能指针，我们必须坚持一些基本规范:</p>
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针。</li>
<li>不delete get()返回的指针。</li>
<li>不使用get()初始化或reset另一个智能指针。</li>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr“拥有”它所指的对象，且只能有一个unique_ptr指向给定对象，指针被销毁时对象也会被销毁。定义它时，没有make_shared类似的函数，需要绑定一个new返回的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ ptr &lt;<span class="keyword">double</span>&gt; p1; <span class="comment">//可以指向一个double的unique_ ptr</span></span><br><span class="line"><span class="function">unique_ ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>且不支持拷贝或赋值操作</p>
<p><img src="https://s2.loli.net/2022/02/04/UGd3SAoe1xhXtra.png" alt="image.png"></p>
<p>但可以通过调用release或reset将指针转移所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有权从p1 (指向string Stegosaurus)转移给p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">// release 将p1置为空</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">//将所有权从p3转移给p2</span></span><br><span class="line">p2.<span class="built_in">reset</span> (p3.<span class="built_in">release</span>()); <span class="comment">// reset 释放了p2原来指向的内存</span></span><br></pre></td></tr></table></figure>

<p>release成员返回unique_ptr当前保存的指针并置空，并且切断了它和原指针的联系，如果不移交给智能指针，一定要delete。</p>
<p>reset成员接受可选指针，然后重新指向给定指针。</p>
<h4 id="函数中的unique-ptr"><a href="#函数中的unique-ptr" class="headerlink" title="函数中的unique_ptr"></a>函数中的unique_ptr</h4><p>我们可以拷贝或赋值一个精要呗销毁的unique_ptr，如函数返回它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//正确:从int*创建一个unique_ ptr&lt;int&gt;</span></span><br><span class="line"><span class="keyword">return</span> unique_ ptr&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p) ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以返回一个局部对象的拷贝:</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (p) )</span> </span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种特殊的拷贝，将在之后介绍它。</p>
<h4 id="传递删除器"><a href="#传递删除器" class="headerlink" title="传递删除器"></a>传递删除器</h4><p>与shared_ptr类似，可以重载删除器，一样需要提供删除器类型，在创建或reset时提供指定类型的可调用的删除器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT, delT&gt; <span class="title">P</span> <span class="params">(<span class="keyword">new</span> objT, fcn)</span> </span>;</span><br></pre></td></tr></table></figure>

<p>用unique_ptr代替shared_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/*其他需要的参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	connection c = <span class="built_in">connect</span> (&amp;d); <span class="comment">//打开连接</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接将会关闭</span></span><br><span class="line">	<span class="function">unique_ptr&lt;connection, <span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">P</span><span class="params">(&amp;C， end_connection)</span> </span>;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//当f退出时(即使是由于异常而退出), connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中我们使用了decltype来指明函数指针类型。由于decltype (end_ connection) 返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>它是一种不控制所指向对象生存期的智能指针，它指向由一个shared（后面都简写）管理的对象将weak绑定到shared不会增加shared的引用计数，计数归0，即使有weak对象也会被释放。weak名字意为这种指针“弱”共享对象。</p>
<p><img src="https://s2.loli.net/2022/02/04/H8pSNcUh6Z9yQzO.png" alt="image.png"></p>
<p>创建weak时需要用shared初始化它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> P = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; <span class="comment">// wp弱共享p; p的引用计数未改变</span></span><br></pre></td></tr></table></figure>

<p>因为weak若共享特性，它指向的对象可能不存在，所以在访问时必须调用lock判断，它返回一个指向共享对象的shared：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">//如果np不为空则条件成立</span></span><br><span class="line"><span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核查指针类"><a href="#核查指针类" class="headerlink" title="核查指针类"></a>核查指针类</h4><p>如果将StrBolb类定义一个伴随指针，保存一个weak_ptr，指向StrBolob的data成员，使用weak不会影响StrBlob指向vector的生存期，但可以阻止用户访问不存在的vector。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于访问一个不存在元素的尝试，StrBlobPtr抛出一个异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StrBlobPtr</span>():<span class="built_in">curr</span> (<span class="number">0</span>) &#123; &#125;</span><br><span class="line">	<span class="built_in">StrBlobPtr</span>(StrB1ob &amp;a， <span class="keyword">size_t</span> sz = <span class="number">0</span>) :</span><br><span class="line">	<span class="built_in">wptr</span>(a.data)，<span class="built_in">curr</span>(sz) &#123; &#125;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">deref</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">StrBlobPtr&amp; <span class="title">incr</span><span class="params">()</span></span>; <span class="comment">// 前缀递增</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check返回一个指向vector的shared_ptr</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">	<span class="built_in">check</span>(std::<span class="keyword">size_t</span>，<span class="keyword">const</span> std::string&amp;) <span class="keyword">const</span> ;</span><br><span class="line">	<span class="comment">//保存一个weak_ptr,意味着底层vector可能会被销毁</span></span><br><span class="line">	std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">	std::<span class="keyword">size_t</span> curr; <span class="comment">// 在数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此类需要注意不能将StrBlobPtr绑定到一个const StrBlob对象是因为构造函数只接受非const对象的引用</p>
<p>check函数也与之前不同需要检查指向的vector是否还存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;std: :vector&lt;std: :string&gt;&gt;</span><br><span class="line">StrBlobPtr::<span class="built_in">check</span>(std::<span class="keyword">size_t</span> i, <span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> ret = wptr.<span class="built_in">lock</span>(); <span class="comment">// vector还存在吗?</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">&quot;unbound StrBlobPtr&quot;</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= ret-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span> (msg) ;</span><br><span class="line">	<span class="keyword">return</span> ret; <span class="comment">// 否则，返回指向vector的shared_ptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><p>现在我们将定义deref和incr的函数来解引用和递增StrBlobPtr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">StrBlobPtr::deref</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> (*p)[curr]; <span class="comment">// (*p) 是对象所指向的vector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前缀递增:返回递增后的对象的引用</span></span><br><span class="line"><span class="function">StrBlobPtr&amp; <span class="title">StrBlobPtr::incr</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果curr已经指向容器的尾后位置，就不能递增它</span></span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot; increment past end of StrBlobPtr&quot;</span>) ;</span><br><span class="line">	++curr; <span class="comment">//推进当前位置</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外为了访问data成员需要声明StrBlob的friend</span></span><br><span class="line"><span class="comment">//对于StrBlob 中的友元声明来说， 此前置声明是必要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line">	<span class="comment">//其他成员与12.1.1节(第405页)中声明相同</span></span><br><span class="line">	<span class="comment">//返回指向首元素和尾后元素的StrBlobPtr</span></span><br><span class="line">	<span class="function">StrBlobPtr <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">StrBlobPtr</span>(*<span class="keyword">this</span>) ; &#125;</span><br><span class="line">	<span class="function">StrBlobPtr <span class="title">end</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">auto</span> ret = <span class="built_in">StrBlobPtr</span>(*<span class="keyword">this</span>， data-&gt;<span class="built_in">size</span>()); <span class="keyword">return</span> ret;&#125;</span><br><span class="line">    <span class="comment">//这里就是</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>如果需要可变数量的对象时，可以使用在StraBlob中采取的方法。</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用get_size确定分配多少个int</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">get_size</span>()]; <span class="comment">// pia指向第一个int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用一个表示数组类型的类型别名分配：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];	<span class="comment">// arrT表示42个int的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;		<span class="comment">//分配一个42个int的数组; p指向第一个int</span></span><br></pre></td></tr></table></figure>

<p>最后的代码等于<code>int *P new int[42];</code></p>
<p>在分配后得到元素类型的指针，所以不能使用begin或end，不可以用范围for来处理动态数组的元素</p>
<p><strong>要记住我们所说的动态数组并不是数组类型，这是很重要的。</strong></p>
<h4 id="初始化动态分配的数组"><a href="#初始化动态分配的数组" class="headerlink" title="初始化动态分配的数组"></a>初始化动态分配的数组</h4><p>可以使用默认初始化或者值初始化（跟一对空括号）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];				<span class="comment">// 10 个未初始化的int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]() ;		<span class="comment">// 10个值初始化为0的int</span></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>] ;		<span class="comment">// 10个空string .</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>](); 	<span class="comment">// 10 个空string</span></span><br></pre></td></tr></table></figure>

<p>还可以提供初始化器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10个int分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//10个string,前4个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>]&#123;<span class="string">&quot;a&quot;</span>， <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>) &#125;;</span><br></pre></td></tr></table></figure>

<p>与内置初始化一样，初始化器会初始化开始部分的元素，剩余执行值初始化。</p>
<p>我们不可以在括号内给出初始化器，且不能用auto分配数组。</p>
<h4 id="动态分配空数组"><a href="#动态分配空数组" class="headerlink" title="动态分配空数组"></a>动态分配空数组</h4><p>可以用任意表达式唉确定分配相对数目</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = <span class="built_in">get_size</span>(); 	<span class="comment">//get_size 返回需要的元素的数目</span></span><br><span class="line"><span class="keyword">int</span>* P = <span class="keyword">new</span> <span class="keyword">int</span>[n];		<span class="comment">//分配数组保存元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>* q = p; q != p + n; ++q) .</span><br><span class="line">	<span class="comment">/*处理数组*/</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即使为0，也能够正常运作</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">0</span>] ;			<span class="comment">//错误:不能定义长度为0的数组.</span></span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]; <span class="comment">// 正确:但cp不能解引用</span></span><br></pre></td></tr></table></figure>

<p>cp可以就像尾后迭代器一样使用</p>
<h4 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> P;		<span class="comment">// p必须指向一个动态分配的对象或为空</span></span><br><span class="line"><span class="keyword">delete</span> [] pa; 	<span class="comment">//pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure>

<p>释放元素是按逆序销毁，且方括号是必须的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>] ;		<span class="comment">// arrT是42个int的数组的类型别名</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;			<span class="comment">//分配一个42个int的数组; p指向第一个元素</span></span><br><span class="line"><span class="keyword">delete</span> [] p;				<span class="comment">//方括号是必需的，因为我们当初分配的是一个数组</span></span><br></pre></td></tr></table></figure>

<h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><p>标准库提供了一个可以管理new分配的数组的unique版本。但必须在对象后跟一对空方括号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//up指向一个包含10个未初始化int的数组</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">up</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span> </span>;</span><br><span class="line">up.<span class="built_in">release</span>(); <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>

<p>当一个unique指向一个数组时，我们可以使用下标运算来访问数组中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="number">10</span>; ++i)</span><br><span class="line">	up[i] = i; <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/04/Swc3g5LlOX2bQsx.png" alt="image.png"></p>
<p>与unique不同的是shared不支持管理动态数组。如果希望使用shared管理动态数组需要自定义删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr，必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]， [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] P; &#125;)</span> </span>;</span><br><span class="line">sp.<span class="built_in">reset</span>(); <span class="comment">//使用我们提供的lambda释放数组，它使用delete []</span></span><br></pre></td></tr></table></figure>

<p>这里直接传递一个lambda表达式作为删除器。如果不提供删除器，则后果与delete不加[]一样。此外他也不支持下标运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ ptr未定义下标运算符，并且不支持指针的算术运算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="number">10</span>; ++i)</span><br><span class="line">	* (sp.<span class="built_in">get</span>() + i) = i; <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure>

<p>所以只能使用get获取内置指针来访问数组元素</p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些缺陷：因为它将内存分配与对象构造组合在一起，所以会导致不必要的浪费：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string *<span class="keyword">const</span> P = <span class="keyword">new</span> string[n]; <span class="comment">// 构造n个空string</span></span><br><span class="line">string s;</span><br><span class="line">string *q = P;		<span class="comment">// q指向第一个string</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; s &amp;&amp; q != P + n)</span><br><span class="line">	*q++ = s;			<span class="comment">//赋予*q一个新值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> size = q - P;		<span class="comment">//记住我们读取了多少个string</span></span><br><span class="line"><span class="comment">//使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// P指向一个数组;记得用delete[]来释放</span></span><br></pre></td></tr></table></figure>

<p>这里创建了n个string，但可能并不需要这么多，所以造成了浪费。</p>
<h4 id="新的方法allocalltor"><a href="#新的方法allocalltor" class="headerlink" title="新的方法allocalltor"></a>新的方法allocalltor</h4><p>它定义在头文件memory中，帮助我们将内存分配和对象构造分开。分配时需要给出类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;				<span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> P = alloc.<span class="built_in">allocate</span> (n) ;		<span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/04/CaKVzphwGWYIXc4.png" alt="image.png"></p>
<h4 id="分配未构造的内存"><a href="#分配未构造的内存" class="headerlink" title="分配未构造的内存"></a>分配未构造的内存</h4><p>使用alloc.construct构造对象，额外的参数用于调用对象的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; 						<span class="comment">//q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);				<span class="comment">//*q为空字符串</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++，<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);		<span class="comment">//*q为cccccccccc  </span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hi&quot;</span>);			 <span class="comment">//*q为hi !</span></span><br></pre></td></tr></table></figure>

<p>在没有构造的情况下访问内存试错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *p &lt;&lt;endl; <span class="comment">//正确:使用string的输出运算符</span></span><br><span class="line">cout &lt;&lt; *q &lt;&lt;endl; <span class="comment">//灾难:q指向未构造的内存!</span></span><br></pre></td></tr></table></figure>

<p>当用完对象后，必须对每个构造元素调用destroy来销毁它们。接受一个指针对指向对象执行析构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">	alloc.<span class="built_in">destroy</span>(--q);<span class="comment">//释放我们真正构造的string</span></span><br></pre></td></tr></table></figure>

<p>销毁元素后可以重新使用内存，也可以归还系统</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n) ;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，第二个大小参数必须与调用allocate时一样。</p>
<h4 id="拷贝和填充未初始化内存"><a href="#拷贝和填充未初始化内存" class="headerlink" title="拷贝和填充未初始化内存"></a>拷贝和填充未初始化内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配比vi中元素所占用空间大一倍的动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p = alloc.<span class="built_in">allocate</span>(vi.<span class="built_in">size</span> () * <span class="number">2</span>);</span><br><span class="line"><span class="comment">//通过拷贝vi中的元素来构造从p开始的元素</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">uninitialized_copy</span> (vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), p);</span><br><span class="line"><span class="comment">//将剩余元素初始化为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(g, vi.<span class="built_in">size</span>() , <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用标准库：文本查询程序"><a href="#使用标准库：文本查询程序" class="headerlink" title="使用标准库：文本查询程序"></a>使用标准库：文本查询程序</h2><p>此部分将单独作为一章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/01/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十一章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-10T00:00:00+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-07 23:11:24" itemprop="dateModified" datetime="2022-02-07T23:11:24+08:00">2022-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>关联容器</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/f8ba18e3b76e063e.png"></p>
<h2 id="使用关联容器-1"><a href="#使用关联容器-1" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现的次数</span></span><br><span class="line">map&lt;string，<span class="keyword">size_t</span> &gt; word_count; <span class="comment">// string到size_t 的空map</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">	++word_count[word] ;				<span class="comment">//提取word的计数器并将其加1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_ count) <span class="comment">// 对map中的每个元素</span></span><br><span class="line">	<span class="comment">//打印结果</span></span><br><span class="line">	cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs”&lt;&lt; w.second &lt;&lt; ((w.second&gt;1)?”times&quot;</span>:”time<span class="string">&quot;) &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计输入中每个单词出现的次数</span></span><br><span class="line">map&lt;string，<span class="keyword">size_t</span> &gt; word_count; 	<span class="comment">// string 到size_ t的空map .</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;The&quot;</span>, <span class="string">&quot;But&quot;</span>, <span class="string">&quot;And&quot;</span>， <span class="string">&quot;Or&quot;</span>， <span class="string">&quot;An&quot;</span>, <span class="string">&quot;A&quot;</span>,</span><br><span class="line">						<span class="string">&quot;the&quot;</span>，<span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span>， <span class="string">&quot;or&quot;</span>， <span class="string">&quot;an&quot;</span>， <span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">	<span class="comment">//只统计不在exclude中的单词</span></span><br><span class="line">	<span class="keyword">if</span> (exclude. <span class="built_in">find</span> (word) == exclude.<span class="built_in">end</span>() )</span><br><span class="line">	++word_ count [word]; 			<span class="comment">// 获取并递增word的计数器</span></span><br></pre></td></tr></table></figure>

<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string，size_ t&gt; word_ count; <span class="comment">//空容器</span></span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;a&quot;</span>,</span><br><span class="line">						<span class="string">&quot;The&quot;</span>, <span class="string">&quot;But&quot;</span>， <span class="string">&quot;And&quot;</span>， <span class="string">&quot;Or&quot;</span>, <span class="string">&quot;An&quot;</span>， <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//三个元素; authors将姓映射为名</span></span><br><span class="line">map&lt;string，string&gt; authors = &#123; &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">								&#123; <span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">								&#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="初始化multimap或multiset"><a href="#初始化multimap或multiset" class="headerlink" title="初始化multimap或multiset"></a>初始化multimap或multiset</h4><p>multi容器允许多个元素具有相同的关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个有20个元素的vector,保存0到9每个整数的两个拷贝</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">	ivec.<span class="function">push_ <span class="title">back</span><span class="params">(i)</span> </span>;</span><br><span class="line">	ivec.<span class="function">push_ <span class="title">back</span><span class="params">(i)</span></span>; 		<span class="comment">// 每个数重复保存一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iset包含来自ivec的不重复的元素; miset包含所有20个元素</span></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span> <span class="params">(ivec. cbegin()，ivec.cend())</span> </span>;</span><br><span class="line"><span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span> <span class="params">(ivec.cbegin()，ivec.cend())</span> </span>;</span><br><span class="line">cout &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">//打印出20</span></span><br><span class="line">cout &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">//打印出10</span></span><br><span class="line">cout &lt;&lt; miset.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">// 打印出 20</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器中的关键字类型必须定义比较元素的方法。</p>
<h4 id="使用关键字类型比较函数"><a href="#使用关键字类型比较函数" class="headerlink" title="使用关键字类型比较函数"></a>使用关键字类型比较函数</h4><p>可以指定一个比较函数来进行比较，需要在容器定义时紧跟着关键字类型给出。</p>
<p>当使用Sales_data类时因为没有&lt;运算符，所以我们需要自己定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span> <span class="params">(<span class="keyword">const</span> Sales_data &amp;<span class="number">1</span>hs， <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后定义容器时传入该函数,需要提供想要使用的操作的指针：</span></span><br><span class="line"><span class="comment">//bookstore中多条记录可以有相同的ISBN</span></span><br><span class="line"><span class="comment">// bookstore中的元素以ISBN的顺序进行排列</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">dec1type</span><span class="params">(compareIsbn)</span>*&gt;</span></span><br><span class="line"><span class="function">	<span class="title">bookstore</span> <span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用decltype指出自定义操作的类型，必须加上*指出给定的函数指针。</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在头文件utility中，一个pair保存两个数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;				<span class="comment">//保存两个string</span></span><br><span class="line">pair&lt;string, size_ t&gt; word_ count;		<span class="comment">//保存一个string和一个size_ t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="keyword">int</span>&gt;&gt; line;			<span class="comment">//保存string和vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用列表初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; author&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Joyce&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>成员均为public使用first和second进行访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot;occurs&quot;</span> &lt;&lt; w.second&lt;&lt; ( (w.second &gt; <span class="number">1</span>)? ”time s: ”time<span class="string">&quot; ) &lt;&lt; endl ;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.bmp.ovh/imgs/2022/01/7b5d5c1283d78be6.png"></p>
<h4 id="返回pair的函数"><a href="#返回pair的函数" class="headerlink" title="返回pair的函数"></a>返回pair的函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string，<span class="keyword">int</span>&gt; <span class="title">process</span> <span class="params">(vector&lt;string&gt; &amp;V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理v</span></span><br><span class="line">	<span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;v. <span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>()&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pair&lt;string， <span class="keyword">int</span>&gt;();			 <span class="comment">//隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else中返回的是一个空pair</p>
<p>早期版本中不可以列表初始化返回则必须显示构造或使用make_pair来生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">	<span class="keyword">return</span> pair&lt;string，<span class="keyword">int</span>&gt; (v.<span class="built_in">back</span>()，v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">	<span class="keyword">return</span> make_ <span class="built_in">pair</span> (V.<span class="built_in">back</span>()，v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<h2 id="关联容器的操作"><a href="#关联容器的操作" class="headerlink" title="关联容器的操作"></a>关联容器的操作</h2><p><img src="https://i.bmp.ovh/imgs/2022/01/9a7c9a3c2375955d.png"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用关联容器得到迭代器得到一个value_type，对于map得到一个pair，first成员中保存的是const关键字，它是不可以更改的，second保存值。而set中value_type与value_type是一样的。</p>
<h4 id="遍历关联容器"><a href="#遍历关联容器" class="headerlink" title="遍历关联容器"></a>遍历关联容器</h4><p>使用迭代器遍历容器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得一个指向首元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">cbegin</span>() ;</span><br><span class="line"><span class="comment">//比较当前迭代器和尾后迭代器.</span></span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.<span class="built_in">cend</span>() ) &#123;</span><br><span class="line">	<span class="comment">//解引用迭代器，打印关键字-值对</span></span><br><span class="line">	cout &lt;&lt; map_it-&gt;first &lt;&lt; ”occurs” &lt;&lt; map_it-&gt;second &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; endl;</span><br><span class="line">	++map_it; <span class="comment">// 递增迭代器，移动到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的函数为升序排列。</p>
<h4 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h4><p>通常不对关联容器使用泛型算法，关键字的const特性意味着不可以重排或修改元素，set中的元素时const的，所以只可以使用只读的算法，推荐使用容器内部的find，它会比泛型算法快得多，泛型find使用的是顺序搜索。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用insert添加一个元素或元素范围，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set容器</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;				<span class="comment">// ivec有8个元素</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; set2										<span class="comment">//空集合</span></span><br><span class="line">set2.<span class="built_in">insert</span>(ivec.<span class="built_in">cbegin</span>()，ivec.<span class="built_in">cend</span>());				<span class="comment">//set2有4个元素</span></span><br><span class="line">set2.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;);						<span class="comment">// set2现在有8个元素</span></span><br><span class="line"><span class="comment">//insert可以接受一对迭代器，也可以接受一个初始化列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map容器</span></span><br><span class="line"><span class="comment">//向word_count插入word的4种方法</span></span><br><span class="line">word_count.<span class="built_in">insert</span> (&#123;word, <span class="number">1</span>&#125;) ;</span><br><span class="line">word_count.<span class="built_in">insert</span> (<span class="built_in">make_pair</span>(word, <span class="number">1</span>)) ;</span><br><span class="line">word_count.<span class="built_in">insert</span> (pair&lt;string, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>)) ;</span><br><span class="line">word_count.<span class="built_in">insert</span> (map&lt;string，<span class="keyword">size_t</span>&gt;::<span class="built_in">value_type</span> (word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.bmp.ovh/imgs/2022/01/a8fe3a59d436ac0b.png"></p>
<h4 id="检测insert返回值"><a href="#检测insert返回值" class="headerlink" title="检测insert返回值"></a>检测insert返回值</h4><p>insert返回值依赖容器类型和参数，对于map和set，添加单一元素返回的是一个pair，first指向给定的关键字元素，second是bool值，指出插入成功还是失败（已存在）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现次数的一种更烦琐的方法</span></span><br><span class="line">map&lt;string，<span class="keyword">size_t</span>&gt; word_count; <span class="comment">// 从string到size_t的空map.</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word) &#123;</span><br><span class="line">	<span class="comment">//插入一个元素，关键字等于word, 值为1;</span></span><br><span class="line">	<span class="comment">//若word已在word_ count中，insert什么也不做</span></span><br><span class="line">	<span class="keyword">auto</span> ret = word_count.<span class="built_in">insert</span> (&#123;word, <span class="number">1</span>&#125;) ;</span><br><span class="line">	<span class="keyword">if</span> (!ret.second)				<span class="comment">// word已在word_ count中</span></span><br><span class="line">		++ret.first-&gt;second; 		<span class="comment">//递增计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="展开递增语句"><a href="#展开递增语句" class="headerlink" title="展开递增语句"></a>展开递增语句</h4><p><code>++ret.first-&gt;second;</code>这句话就代表增加插入的那个元素中的second++。</p>
<h4 id="multi容器添加元素"><a href="#multi容器添加元素" class="headerlink" title="multi容器添加元素"></a>multi容器添加元素</h4><p>这种容器可以包含多个相同的关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mul timap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">//插入第一个元素，关键字为Barth， John</span></span><br><span class="line">authors.<span class="built_in">insert</span> (&#123;<span class="string">&quot;Barth，John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//正确:添加第二个元素，关键字也是Barth， John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;) ;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://s2.loli.net/2022/01/22/QuvPl6JZYehS3fg.png" alt="image.png"></p>
<p>erase可以接受一个迭代器或者是一对迭代器来删除一个或一个范围的元素。还可以接受一个key_type，删除所匹配的关键字元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一个关键字，返回删除的元素数量</span></span><br><span class="line"><span class="keyword">if</span> (word_count.<span class="built_in">erase</span> (removal_word) )</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ok:”&lt;&lt; removal_word &lt;&lt; ”removed\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;oops: ”&lt;&lt; removal_ word &lt;&lt; ”not found! \n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是multi容器，可能删除多个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cnt = authors.<span class="built_in">erase</span> (<span class="string">&quot;Barth，John&quot;</span>) ;</span><br></pre></td></tr></table></figure>

<p>上面authors中添加了两个相同的元素，则cnt等于2。</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和unordered_map具有下标运算和at函数，set中不可以使用。</p>
<p>map通过下标运算，接受一个索引（即关键字）获取与之关联的值，但不同的是，如果没有此关键字，会创建一个关键字，并将对应的值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map &lt;string， <span class="keyword">size_t</span>&gt; word_count; / / empty map</span><br><span class="line"><span class="comment">//插入一个关键字为Anna的元素，关联值进行值初始化;然后将1赋予它</span></span><br><span class="line">word_count [<span class="string">&quot;Anna&quot;</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在word_ _count中搜索关键字为Anna的元素，未找到。</li>
<li><em>将一个新的关键字-值对插入到word</em> _count中。关键字是-一个const string，保存Anna。值进行值初始化，在本例中意味着值为0。</li>
<li>提取出新插入的元素，并将值1赋予它。</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/22/7R2B1iaJbqvftP4.png" alt="image.png"></p>
<h4 id="使用下标操作的返回值"><a href="#使用下标操作的返回值" class="headerlink" title="使用下标操作的返回值"></a>使用下标操作的返回值</h4><p>通常解引用的一个迭代器的类型与下标运算返回的类型是一样的，但map不同，会得到有个mappped_type对象，且为左值。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>count可以统计元素个数，对于不允许重复元素存在的容器，推荐使用find。</p>
<h4 id="map使用find代替下标操作"><a href="#map使用find代替下标操作" class="headerlink" title="map使用find代替下标操作"></a>map使用find代替下标操作</h4><p>map容器的下标操作如果关键字不存在，则会插入这个新的关键字，所以在只是想知道有没有这个关键字时可以用find代替。</p>
<h4 id="multi容器查找元素"><a href="#multi容器查找元素" class="headerlink" title="multi容器查找元素"></a>multi容器查找元素</h4><p><strong>方法一：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string search_ <span class="title">item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span> </span>;		<span class="comment">//要查找的作者</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors. <span class="built_in">count</span> (search_ item) ;	<span class="comment">//元素的数量</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors. <span class="built_in">find</span> (search_ item) ;		<span class="comment">//此作者的第一本书</span></span><br><span class="line"><span class="comment">//用一个循环查找此作者的所有著作</span></span><br><span class="line"><span class="keyword">while</span> (entries) &#123;</span><br><span class="line">	cout &lt;&lt; iter-&gt;second &lt;&lt; endl ;				<span class="comment">//打印每个题目</span></span><br><span class="line">	++iter;										<span class="comment">//前进到下一本书</span></span><br><span class="line">	--entries;									<span class="comment">//记录已经打印了多少本书</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<p>lower_bound和up_bound分别返回匹配的第一个位置和最后一个位置的后一个位置。不存在则返回可插入位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authors 和search_ item 的定义，与前面的程序一样</span></span><br><span class="line"><span class="comment">//beg和end表示对应此作者的元素的范围.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors. <span class="built_in">lower_bound</span> (search_item) ,</span><br><span class="line">		  end = authors.<span class="built_in">upper_bound</span> (search_item) ;</span><br><span class="line">		  beg != end; ++beg)</span><br><span class="line">	cout &lt;&lt; beg-&gt;second &lt;&lt; endl; <span class="comment">//打印每个题目</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong></p>
<p>equal_range函数接受关键字，返回pair。若关键字存在则第一个指向第一个与之匹配的位置，第二个是最后一个与之匹配位置的后一个位置。若不存在则返回可插入位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authors 和search_item的定义， 与前面的程序一样</span></span><br><span class="line"><span class="comment">// pos保存迭代器对，表示与关键字匹配的元素范围</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span> (search_item) ;</span><br><span class="line">	 pos.first != pos.second; ++pos.first)</span><br><span class="line">	cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; <span class="comment">//打印每个题目</span></span><br></pre></td></tr></table></figure>

<h3 id="单词转换map（跳）"><a href="#单词转换map（跳）" class="headerlink" title="单词转换map（跳）"></a>单词转换map（跳）</h3><h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><h4 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h4><p>unordered_map或者unordered_set，他们都有与前面类似的操作，通常可以用一个无序容器替换对应的有序容器，但顺序会与有序容器不同。</p>
<h4 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h4><p>无序容器在储存上为一组桶，无序容器使用一个哈希函数将所有元素映射到桶中，容器将具有一个特定的哈希值的所有元素保存在相同的桶中，访问时先按照哈希值找到对应的桶，再在桶中找对应的元素。因此容器性能依赖哈希函数的质量和桶的数量和大小。</p>
<p>最理想的情况应该是哈希函数将所有元素尽可能的均匀的分配到每个桶中。</p>
<p><img src="https://s2.loli.net/2022/01/27/eTFbRU5lHPOVKfp.png" alt="image.png"></p>
<h4 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h4><p>默认情况下，无序容器使用关键字类型的==运算符来比较元素，还使用一个hash<key_ type> 类型的对象来生成每个元素的哈希值。例如当我们想要将一个int值使用哈希函数，就是hash<int>,</p>
<p>但是我们不能直接定义关键字类型为自定义类类型的无序容器。可以不直接使用哈希模板而是使用自己的hash版本。例如Sale_data用作关键字，我们需要提供函数来代替==运算符和哈希计算函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_ data &amp;sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hash&lt;string&gt;() (sd. <span class="built_in">isbn</span>()) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs， <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SD_multiset = unordered multiset&lt;Sales_data,</span><br><span class="line">					<span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">//参数是桶大小、哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span> </span>;</span><br></pre></td></tr></table></figure>

<p>如果类内具有==运算符，可以只重载哈希函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用FooHash生成哈希值; Foo必须有==运算符</span></span><br><span class="line"><span class="function">unordered_set&lt;Foo, <span class="title">decltype</span> <span class="params">(FooHash)</span>*&gt; <span class="title">fooSet</span> <span class="params">(<span class="number">10</span>，FooHash)</span></span>;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  



<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz',
      appKey     : '6k9HROMoqf6vzPadEMksx26r',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>