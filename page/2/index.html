<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="祥瑞客栈">
<meta property="og:url" content="http://mackrui.com/page/2/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Collider">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mackrui.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">39</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/03/09/%E5%85%89%E8%BF%BD1.9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/%E5%85%89%E8%BF%BD1.9/" class="post-title-link" itemprop="url">磨砂（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-09T00:00:00+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:53:27" itemprop="dateModified" datetime="2022-04-02T16:53:27+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/09/%E5%85%89%E8%BF%BD1.9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/09/%E5%85%89%E8%BF%BD1.9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h2><p>看到标题，我们就知道上一章画面太暗的罪魁祸首是谁了吧，生成反射光线的起点是碰撞点，但是因为浮点数并不能精确的等于某个数，比如<code>double d = 0;</code>，实际的项目运行过程中，d不会精确等于0，而是会等于诸如-0.00000083之类的逼近0的小数。</p>
<p>浮点数精度问题会导致一部分光线的起点在球的内部，这样发射光线，光线会和球的内壁碰撞，然后在球内反复弹射，耗尽自己的一生。</p>
<p>虽然可以通过微移光线起点的方式来解决，但是这样会把问题复杂化。别忘了我们在写hit函数的时候，留有限制t的参数t_min和t_max。我们完全可以使用t_min的限制，让光线自动忽略那些和发射点很近的物体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>图片变得正常了！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309090857497.png" alt="image-20220309090857497"></p>
<h2 id="伽马矫正"><a href="#伽马矫正" class="headerlink" title="伽马矫正"></a>伽马矫正</h2><p><strong>人的眼睛并不是精准的机器，它对亮度的感知和实际能量的功率是不成线性函数关系的，而是幂函数关系，这个函数的指数通常为2.2，称为Gamma值。</strong></p>
<p>也就是说，如果光线真的是每次碰撞到物体都衰减一半的能量，那对于百分之50功率的灰色，人眼实际感受到的亮度为$\sqrt[2.2]{0.5}=0.77297$，是一种偏向于白色的淡灰色。</p>
<p>而人眼中的中灰色，实际上是功率只有<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/13a269c1c59350ec073ea90c7f4516bd.svg" alt="img">。</p>
<p>为了适应人眼去纠正光线的能量，让它符合人眼生物学中的颜色，这叫做<strong>伽马矫正</strong>。为了方便，我们并不需要那么精准，我们使用”Gamma 2”矫正，即直接对最后的颜色值开方，在write_color函数中，有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gamma矫正（Gamma = 2.0）。</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的图像看起来会更亮了，也更接近真实世界我们看到的漫反射材质</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309091636573.png" alt="image-20220309091636573"></p>
<h2 id="更真实的漫反射"><a href="#更真实的漫反射" class="headerlink" title="更真实的漫反射"></a>更真实的漫反射</h2><p>之前的随机的向量更倾向于接近法线，并不能做到完全随机，接下来介绍一种单位球表面随机选点模型——又称真实兰伯特模型（true Lambertian），它是最贴合现实世界物理规律的漫反射材质的反射方向的模型。</p>
<p>很简单，我们只需要把体积的随机改成面积的随机即可，我们在单位球的表面随机选点。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309132029289.png" alt="image-20220309132029289"></p>
<p>所以在vec3.h文件中加入全局函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unit_vector</span>(<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改ray_color函数中的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 这次改为在球面上取点。</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以得到这张图片：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309132224913.png" alt="image-20220309132224913"></p>
<h2 id="半球选点模型"><a href="#半球选点模型" class="headerlink" title="半球选点模型"></a>半球选点模型</h2><p>这一种最容易想到的模型（我脑海里也是第一时间想到这个），很多早期的光线追踪论文使用的是这样一种模型。</p>
<p>在以碰撞点P为球心的单位半球内找点，取点半球和表面法线在面的同侧。继续添加一个vec3.h的全局函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="keyword">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该向量和法线夹角为锐角，即在面的同侧，接受它，否则取反。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>) </span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时更改ray_color中的调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309092409576.png" alt="image-20220309092409576"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol>
<li>利用这一节的代码加工一下我们就可以制作各种各样的有趣的图片了：<ol>
<li>太极<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309204931529.png" alt="image-20220309204931529"></li>
<li>炽日<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309204955574.png" alt="image-20220309204955574"></li>
<li>蛋灯<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309205203309.png" alt="image-20220309205203309"></li>
</ol>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第8.3节到8.6节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/03/03/%E5%85%89%E8%BF%BD1.8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/%E5%85%89%E8%BF%BD1.8/" class="post-title-link" itemprop="url">磨砂（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-03T00:00:00+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:54:26" itemprop="dateModified" datetime="2022-04-02T16:54:26+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/03/%E5%85%89%E8%BF%BD1.8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/03/%E5%85%89%E8%BF%BD1.8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我们一直在画一些看起来完全不真实的东西，但从现在开始我们可以来实现更加真实的物体了。</p>
<h3 id="漫反射原理"><a href="#漫反射原理" class="headerlink" title="漫反射原理"></a>漫反射原理</h3><p>例如土墙、手机壳、木制桌面等等这些表面有很多微小凹凸的材质叫做漫反射材质，它们会吸收一部分光线，并且把剩余的光线朝随机方向反射出去，因为光线被反射到了不同的方向，自然不会出现某一个方向能接收到很亮的光线，也就不会有高光点存在。它们一般会吸收特定颜色的光，比如红色的砖块，它会吸收不是红色的光线，而把红色的光线按照随机方向反弹回去。</p>
<p><img src="http://cdn.jsdelivr.net/gh/endlesscollider/imageBed/image-20220307205949767.png" alt="image-20220307205949767"></p>
<h2 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h2><p>现在暂时还没有光源，我们不妨假设<strong>“蓝天”就是光源</strong>，光的能量都是从蓝天上来的。</p>
<p>我们再假设任何物体对各种颜色光线的吸收率都是一样的，是<strong>1：1</strong>。光线碰撞到物体后，都会吸收掉每种光的一半的能量，然后反射一半。</p>
<p>又因为我们是逆光路取色，有以下n种情况：</p>
<ol>
<li>从相机射出一根光线，这根光线没有碰到任何物体，即它射中了“蓝天”，那逆光路顺过来看看这意味着<strong>相机直接望到了蓝天，蓝天发出的光没有经过任何弹射直接进入了相机。</strong></li>
<li>从相机射出一根光线，这根光线碰到了一颗球，然后经过随机弹射之后，再也没有射中任何物体，朝无穷远处射出，即，它经过一次弹射之后射中了蓝天。逆光路顺过来看看这意味着<strong>光线从蓝天射出打到了物体上并且弹到我们的眼睛里。</strong>因为这个物体的能量吸收和反射的比率是1：1，所以这根光线只有一半的能量了。</li>
<li>我们从相机射出一根光线，这根光线碰到了一颗球，然后经过随机弹射之后，它又碰到了一颗球，逆光路顺过来看<strong>光线从蓝天射出打到了一颗球上，反射到了另外一颗球上，再反射到我们的眼睛里，没错，这根光线只剩四分之一的能量了。</strong></li>
<li>…… </li>
</ol>
<p>那么光线在空间中弹射了n-1次，它的能量只剩<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/bb01c00e8b77357ff3732c4f3f3eb9bb.svg" alt="img">。</p>
<p>从相机中射出一根光线之后，只要碰撞到物体，就从这个碰撞点朝随机方向发射一根光线，然后把这根光线取到的颜色乘以0.5并返回。</p>
<p>我们的取色函数叫<code>ray_color(const ray&amp; r, const hittable&amp; world)</code>，我们这个函数的返回值应该写什么呢？应该是<code>return 0.5 * ray_color(newRay,world)</code>，没错，这是一个递归，函数会疯狂的调用自己，直到某根随机反射光线射中了“蓝天”，再一层一层地返回。</p>
<h2 id="随机光线"><a href="#随机光线" class="headerlink" title="随机光线"></a>随机光线</h2><p>之前遗留的最后一个问题是如何随机发射一根光线呢？</p>
<p>这个问题并不像表面看上去那么简单，使用什么模型可以更加真实的模拟漫反射呢？最简单的模型是单位球体积内随机选点模型，如图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307211216029.png" alt="image-20220307211216029"></p>
<p>碰撞点是<strong>P</strong>，法线为<strong>N</strong>（单位化），在以（<strong>P+N</strong>）这个点为球心的单位球内随机寻找一点<strong>S</strong>，然后以<strong>S</strong>减去<strong>P</strong>为光线的反射方向向量就是最终我们需要的向量。这个<strong>S</strong>点是<strong>P</strong>点坐标+<strong>N</strong>向量+一个由球心指向球内随机点的向量三部分组成。</p>
<p><strong>r</strong>向量是相机观察方向，因为我们的漫反射和视角方向无关，不用去管它。</p>
<p>在vec3文件中写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里函数都是static的，就表示它属于整个类而不属于某个特定的对象，我们可以使用上面的函数直接调用vec3类构造生成一个三个分量都在[0,1)或者[min,max)内随机的随机vec3。</p>
<p>random() 函数生成的vec3可不是在单位球内的，它的XYZ轴都是在[0,1)之间的，它是一个在<strong>单位立方体</strong>内的点或者向量，我们得做一个简单的处理，让它的随机值最终落于单位球内。</p>
<p>再在vec3.h文件中vec3的类外写一个<strong>全局</strong>函数，它只有四句代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 先来个中心在原点，边长为2的立方体内的点。</span></span><br><span class="line">        <span class="keyword">auto</span> p = vec3::<span class="built_in">random</span>(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果发现这个vec3的长度（它离原点的距离）大于1，即表示它是落于立方体内且落于球外的。</span></span><br><span class="line">        <span class="comment">// 直接让他暴力再随机一次。</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个位于单位球内的点。</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用了一个很暴力的方法：<strong>拒绝算法（rejection method）</strong>，直接让他疯狂的循环，只要点不落于单位球内，我们就让他一直随机到单位球内为止。</p>
<p>接着更新着色代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由三部分组成的S点坐标。</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创造新的光线并开启下一轮递归。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么将它写在这里，有一个原则就是<strong>对于不自信的内容，先写到表层实现需求，再抽象到底层维护框架</strong>。所以这里不要在意它污染了main函数（对所有的物体都采用了漫反射）。</p>
<h2 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h2><p>到这里运行程序法线根本无法运行：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307213818888.png" alt="image-20220307213818888"></p>
<p>之前设置的递归终止条件是光线射入蓝天，但是如果光线没有射到蓝天而是一直在夹缝里不停的弹跳，就会导致系统栈溢出。为此因为引入一个光线弹射次数的上限值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果次数消耗殆尽，直接终止递归，我们的系统栈可耗不起了！</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="comment">//每一轮新的递归，我们把光线可弹射次数减一。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给定光线最大弹射次数。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line"></span><br><span class="line">        ...            </span><br><span class="line">        <span class="comment">//更改ray_color调用代码。</span></span><br><span class="line">        pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们应该可以得到一张带有漫反射材质的图了：<br><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307214423049.png" alt="image-20220307214423049"></p>
<p>非常的暗的图片，但确实可以看到漫反射的细节，如果我们只看上方小球的球顶，常识告诉我们，光线打到这里，很大概率能反弹到蓝天上，也就是说，它的颜色应该趋向于蓝天的颜色衰减了一半之后的某种蓝色。而图像并非如此。</p>
<p>另一种方法也可以佐证，用文本模式打开ppm文件，可以看到上边右图中的RGB值，它们都是很靠近黑色的值，我们的程序似乎就没生成过只弹射一次就碰到蓝天的光线，这个问题在下一章得到一个非常巧妙且完美的解决办法。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol>
<li><p>可以证明单位球体积随机选点模型的代码取到的点一定是随机的吗？</p>
<p>首先如果没有单位球的限制，在单位立方体内部的点，它们必然是均匀的，因为随机的三个标量都足够均匀。</p>
<p>现在加上单位球的限制，进行n次独立实验（n足够大），我们把这n次实验的结果按照随机几次才得出结果再分成m堆。</p>
<p>首先是最大的那一堆，这一堆中的点都是只随机一次就落在了单位球内的，有$\frac{\frac{4}{3}\prod}{8}*n$个点在这个堆里（球的体积比上立方体体积）。这些点必然均匀。因为咱们的随机点肯定均匀分布于立方体，也必然均匀分布于立方体中的球内。</p>
<p>接下来看看第二大的那个堆，这个堆里的点都是第一次随机到了球外，第二次随机到了球内的，这部分的点有$(\frac{\frac{4}{3}\prod}{8})(\frac{8-\frac{4}{3}\prod}{8})*n$个。如果只针对这一批点来说，肯定也是均匀分布于球内（因为我们采用的算法并没有改变）。</p>
<p>以此类推我们就能得出整体必然均匀的结论。</p>
</li>
<li><p>如果光线是从球内打到球的内壁上，我们代码能正确的运转吗？</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第8.1节到8.3节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/03/01/%E5%85%89%E8%BF%BD1.7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/%E5%85%89%E8%BF%BD1.7/" class="post-title-link" itemprop="url">抗锯齿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-01T00:00:00+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:53:41" itemprop="dateModified" datetime="2022-04-02T16:53:41+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/01/%E5%85%89%E8%BF%BD1.7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/01/%E5%85%89%E8%BF%BD1.7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>仔细观察前面生成的图片，在物体的交界处呈现的是锯齿状，哪怕分辨率非常大，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">1600</span>;</span><br></pre></td></tr></table></figure>

<p>得到这样的图像</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307193903032.png" alt="image-20220307193903032"></p>
<p>放大边缘，可以看到依然如此，为了解决这个问题，先看抗锯齿的本质。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307193945194.png" alt="image-20220307193945194"></p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>其实这个问题之前讨论过，相机只对着每个像素的左上角发射光线，那左上的带回的颜色可以代表整个像素吗？当然不行，所以最好的解决办法就是在这个像素内多发射几次光线，然后取颜色的平均值，即提高<strong>采样率</strong>。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307194536541.png" alt="image-20220307194536541"></p>
<p>比如上图中我们可以在一个像素内采样四次，得到的图像就会准确的多。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>在这里我们就需要用到随机数，其实光线追踪的很多地方都会用到它，首先回忆一下C语言中的随机数，在rtweekend.h中加入内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rand()会返回一个0~RAND_MAX之间的随机数，所以下面这个式子返回的随机数值范围是[0,1)。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围在[min,max)的随机数。</span></span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，我们有更强大的随机数算法，那就是mt19937，它的随机性好，在计算机上容易实现，占用内存较少，所以这里选用mt19937随机数，可以把上面代码中random_double函数改掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置随机范围0到1</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//创建随机数对象</span></span><br><span class="line">    <span class="keyword">static</span> std::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装相机"><a href="#封装相机" class="headerlink" title="封装相机"></a>封装相机</h2><p>这是一个封装我们的相机的好机会。在开始多次采样之前，我们先把相机处理完，让main函数中少一点乱七八糟的代码。</p>
<p>我们可以把在main函数中渲染循环外对相机的所有操作都移动到相机类的构造函数里，然后创建一个类内函数专门用来发射光线，这样设计下来，在main函数中所剩的代码最为清爽。</p>
<p>创建camera.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>() &#123;</span><br><span class="line">            <span class="comment">//暂时全部写死，代码保持和之前在main函数中的一致。</span></span><br><span class="line">            <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">            <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">			</span><br><span class="line">            origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//发射光线的函数，吃xy轴的偏移，吐出一根从原点射往指定方向的光线。</span></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">//这些参数我们没有暴露的必要。之后我们制作高级相机的时候，再考虑要不要把它们的权限放开。</span></span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="修改颜色类"><a href="#修改颜色类" class="headerlink" title="修改颜色类"></a>修改颜色类</h2><p>因为现在需要多次采样，原color类中的write_color函数也需要修改，为了用户更方便的使用main函数中，颜色只管叠加，其余交给write_color处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除以采样次数</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保最终的值是在[0,255]之间，换句话说，我们需要确保r,g,b都在[0,1]之间。</span></span><br><span class="line">    <span class="comment">//这个clamp函数在之后给出。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先需要把处理传进来的颜色除以采样数，还需要将每个通道的颜色映射到0到255的范围内。其中clamp函数是为了确保传入的值在特定区间内，比如这里如果传入的值大于1，就会导致颜色无法显示。所以还是在这个文件中写入函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">clamp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成果验收"><a href="#成果验收" class="headerlink" title="成果验收"></a>成果验收</h2><p>接下来只要替换相机，渲染循环中再加一层for即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们必须要一些参数来告诉程序需要生成什么样的图片，这部分代码逻辑上和摄像机没有关系，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="comment">// 采样次数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要一个构造函数，我们就可以把相机安排妥当。</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//多了一层循环哦。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 随机数出场了，u和v每次都会随机加上一个[0,1)的数，然后除以image的长宽之后，</span></span><br><span class="line">                <span class="comment">// 就会落到一个像素内的随机位置。</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height<span class="number">-1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调用摄像机中封好的函数创造射线。</span></span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                <span class="comment">// 无脑颜色累加即可。</span></span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//最终的绘制颜色代码中，再做最终除法。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漫长等待后我们得到了一个更加“圆润”的球</p>
<p><img src="http://cdn.jsdelivr.net/gh/endlesscollider/imageBed/image-20220307202558937.png" alt="image-20220307202558937"></p>
<p>强大的力量都需要代价，代价就是比原来要多花100倍的时间。但是多次采样是我们渲染效果真实感的保障，并且多次采样在后面还有着更为广泛的应用。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这一节代码在这个场景下我认为是可以优化的，比如我们是没有必要在非物体的边缘做100次的采样，这些地方发射一次又或是多次带回来的结果也没有什么不同，所以这里可以在一个像素内先少量采样，如果它们返回的t值不同，则说明这个像素处于物体交界处，需要多次采样来抗锯齿。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第7节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/28/%E5%85%89%E8%BF%BD1.6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E5%85%89%E8%BF%BD1.6/" class="post-title-link" itemprop="url">物体列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-28T00:00:00+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:53:48" itemprop="dateModified" datetime="2022-04-02T16:53:48+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/28/%E5%85%89%E8%BF%BD1.6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/28/%E5%85%89%E8%BF%BD1.6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了物体类，我们可以创建单个物体了，但是如果场景物体非常的多，我们则需要一个数组储存它们，不仅如此我们在进行光线的碰撞检测的时候还需要依次调用它们碰撞函数，并且在创景变化或者程序结束的时候去释放内存等等。所以这些操作放在main函数中是不合适的，所以最好的办法是定义一个类去实现这些操作。创建hittable_list.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针！用它来帮我们管理物体列表，就不用担心内存泄漏问题了！</span></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//当创建物体列表的时候传入了某一个物体，我们直接调用add函数把这个物体加入列表。</span></span><br><span class="line">    	<span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//clear函数调用列表的clear函数清空列表。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    	<span class="comment">//add函数调用push_back把新物体的智能指针加入列表</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//声明我们需要override父类的hit函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//物体列表，使用vector去存每个物体的智能指针。</span></span><br><span class="line">        std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写之后的hit函数。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最开始，把能接受的最远位置设置成外部传进来的t_max。</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个物体做碰撞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line"> 		<span class="comment">//光线射到了这一堆物体里的某一个。</span></span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            <span class="comment">//光线有射中东西，把最终函数的返回值设定为true。</span></span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//光线虽然已经射中了一个东西了，但不确定射中的这个物体是不是离相机最近的。</span></span><br><span class="line">            <span class="comment">//范围缩小，然后继续遍历物体列表。</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每次有新的碰撞，就设定它的record为最终record。</span></span><br><span class="line">            <span class="comment">//遍历完成后，就可以找到最近的碰撞点并返回它的rec。</span></span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回这根光线是否有碰到物体列表中的任何物体。</span></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里面有两个C++非常中要的概念：智能指针和多态</p>
<p>1）智能指针。</p>
<p>C++11给我们提供的瑰宝，它的本质是维护一个指针和一个计数，当创建智能指针并让他指向一个对象的时候，引用计数为1，之后每有一个新的指向它的指针被创建，引用计数加1，一个指针被销毁或者不再指向它，引用计数会下降。引用计数为0则释放对象所占内存。</p>
<p>之前的类我们一直都在“造轮子”，这个物品列表类的作用是管理我们之前做好的“轮子”。通常<strong>C++中用于管理一些对象的类，一般都是通过指针去管理。</strong>对象之间的传输不仅会占据系统栈的内存，还需要付出因拷贝构造而消耗的时间。</p>
<p>况且通过指针管理对象还有另一层作用，那就是“多态”。</p>
<p>2）多态。</p>
<p>继承结构内的多态的一大实现条件就是<strong>基类指针指向子类对象</strong>。这是一个极其经典的场景，我们通过虚函数的重写，再通过基类指针定义某一个接口，在实际程序运行过程中无论来的是哪个子类对象，都可以精确的调到对应的虚函数。</p>
<p>在这个程序中，hit函数是如何完成多态的呢？我们的物品列表类只说明了这个列表里面的东西会是一个物体，即它存的是基类指针，hit函数中我们分别调用了列表中每一个指针指向对象的hit函数的，虽然此时并不知道它到底是个球，或者是其他的什么东西，我们只管调用它，多态会帮我们找到具体到底是那个函数并且调用到它。</p>
<p>把物品列表类设计成了物品类的子类还有更多的好处，举一个只有这样设计才能达成的疯狂的玩法！我们可以在这里进行无限层的嵌套！比如下面的某个物品列表：</p>
<p><em>-物品列表</em></p>
<p><em>-子物品列表1</em></p>
<p><em>-球1</em></p>
<p><em>-球2</em></p>
<p><em>-子物品列表2</em></p>
<p><em>-球3</em></p>
<p><em>-球4</em></p>
<p>现在给最外层的物品列表调用hit函数，我们问这个列表：“这根光线有没有和这一大堆东西碰撞呀，碰撞结果如何啊？”</p>
<p>最外层的列表说：“我给你看看把，我这里有俩玩意，但我不知道这俩玩意是啥，我帮你找他们问问（最外层列表只知道列表中有俩物体，它不知道这些物体到底是啥）”</p>
<p>紧接着程序开始按照名单给这俩小物品列表发消息：“嘿，你们是什么玩意啊？是球吗？我不管你们是不是球，上面发话了，要看看这根光线有没有和你们碰撞，碰撞情况如何啊？我把光线信息和上面要求的t的范围发给你了啊，再给你一个地址，你们俩把record填好啊！我不管了啊！”</p>
<p>好了，俩小物品列表收到消息也急了，它赶忙找它们下面的东西：“嘿！听的到么！我不管你们是谁，老板要求你们把这根光线…….(省略)”</p>
<p>最外层的物品列表只需要维护自己的closest_so_far，比较两个子物品列表给出的t的大小并选择最小的那个，而再下层的东西它完全不用去管。</p>
<p>这叫什么？递归！我们用“物品列表类是物品类的子类”这一设计，实现了一个精美的递归代码帮我们完成一个光线和一堆物品的碰撞。这也多亏了多态的支持。我无法想象如果我们没有多态，实现一个嵌套列表到底要多出几百倍的代码。</p>
<p>我画了一张类图在来帮助理解这部分代码：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1640711858250-599470c8-aca1-45dd-a55e-022902a5ac05.png" alt="img"></p>
<h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><p>现在还需要一些常量数字，比如无穷大。不然我们要怎么传最初始的t_max值呢？我们不能在一开始就限定它为10000，1000之类的。显得很不专业，况且，一些常量和一些换算之后还会有更多作用。我们先把我们能想到的写上，之后需要其他的再添加。</p>
<p>文件取名为rtweekend.h，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTWEEKEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTWEEKEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用C++帮我们定义好的double类型的无限值作为无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> infinity = std::numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="comment">// Π。 我们先把这个东西放在这，虽然暂时还没有什么用。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个角度值转弧度制的函数，嗯。。或许暂时也没有什么用。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="keyword">double</span> degrees)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这俩头文件可是我们的常客，之后用他们就直接包这个rtweekend文件就行了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>在main函数中写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新的光线取色函数中，我们加入了一个名为世界的物体对象，别看它是一个物体对象，我们一般会传入一个物体列表。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">//我们使用到了我们定义的无限大，并且剔除了负t</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">//没错，依然是元气弹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//蓝天...</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创造世界</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入俩个球</span></span><br><span class="line">    <span class="comment">//和以前一样</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    <span class="comment">//一个非常吓人的巨型球！</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机相关</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染循环（render loop）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line">            <span class="comment">//和原来没什么不同，也说明了作者的封装非常完美</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307133434367.png" alt="image-20220307133434367"></p>
<p>于是我们得到了在一片草原之上的元气弹，实际上只是球体所在位置及其表面法线的可视化。这通常是查看模型缺陷和特征的好方法。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第6.5节到第6.7节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/26/%E5%85%89%E8%BF%BD1.5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/26/%E5%85%89%E8%BF%BD1.5/" class="post-title-link" itemprop="url">物体类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-26T00:00:00+08:00">2022-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:53:54" itemprop="dateModified" datetime="2022-04-02T16:53:54+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/26/%E5%85%89%E8%BF%BD1.5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/26/%E5%85%89%E8%BF%BD1.5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>首先可以简化一些不必要的常数项，聊胜于无的优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="comment">//默认直接把2除掉</span></span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">    <span class="comment">//这个discriminant是之前的四分之一。</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//分子分母都是简化前的一半。</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (-half_b - <span class="built_in">sqrt</span>(discriminant) ) / a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>现在有了球，或许需要一个球类去描述它，但是未来可能还会有更多的其他种类的物体，最容易想到的方法是首先编写一个物体基类。</p>
<p>这个抽象基类需要抽象出所有物体的共性：</p>
<p>一个物体一定可以被光线感知到，它可以被光线照到，并且光线可以通过这次碰撞获取一些关于物体的信息。即，它需要一个抽象的<strong>碰撞函数</strong>，就和我们之前在main所在文件中写的球简易碰撞函数那样。这个函数的返回值设计成bool，即返回是否碰撞到。至于其他的碰撞信息，我们可以通过一个结构体返回，其中包括：</p>
<ol>
<li><strong>t值</strong>。除了判断t值可以确定是否碰撞到物体，t值在之后会有更大的作用，可以说，<strong>t值是光线和物体碰撞中最重要的信息之一，</strong>应当让外界知道这个值以方便其他的运算。</li>
<li><strong>法线</strong>。前面的元气弹就是使用了法线实现的效果，但是这还不是全部，法线的作用还有很多，比如镜面反射，比如通过法线去计算反射方向。总之，我们需要返回法线信息。</li>
<li><strong>碰撞点坐标</strong>。很多情况下都需要用到p点坐标，我们不希望每次用到的时候都去计算一遍，而且我们理应把这些计算放在更底层的地方，而且我们也不应该把这种底层计算放在用户看得到的地方。</li>
</ol>
<p>创建hittable.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把需要返回的数据封装成结构体，按照上面分析的，暂时我们需要这三个东西。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可碰撞物体类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//需要这样一个纯虚函数，所有继承自这个类的子类（如球），都需要实现这个函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在类中多了两个参数，分别为允许t的最小、最大值，有了它我们就可以剔除t小于0的情况（即物体在相机后后面的情况），同时它还有更多的用处。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于这个物体类来实现球类的代码，创建sphere.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//构造</span></span><br><span class="line">        <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">sphere</span>(point3 cen, <span class="keyword">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//声明要override纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//老代码</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发现方程没有根，直接退出。</span></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为我们引入了tmax和tmin，所以这里还需要格外的运算。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查较小的根</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        <span class="comment">//检查较大的根</span></span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封入结构体</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">//不用麻烦使用unit_vector函数，直接利用已经存好的半径进行单位化，实现加速。</span></span><br><span class="line">    rec.normal = (rec.p - center) / radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第40行开始的if语句非常的巧妙，因为只有在较小的根不满足<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/d87a46ba28d0db64bb2642603c553fba.svg" alt="img">的时候，才会检查较大的根，换句话说，如果较小的根在我们的许可范围内，我们会直接采纳他。一般来说，较小的根是光线和物体的首次交汇点，所以优先返回较小根是非常合理的。</p>
<p>那么什么场景才能用到较大的根呢？非常明显，是相机在物体的里面的时候，但这种情况也会导致之前计算的法线方向相反，接下来就来解决它。</p>
<h2 id="法线修正"><a href="#法线修正" class="headerlink" title="法线修正"></a>法线修正</h2><p>通过什么方式判断法线是否反了呢？可以注意到的是，法线与入射光线的夹角一定小于90度的，所以可以使用向量的点乘来进行判断，并且这部分判断可以直接放在hit_record内，同时在碰撞函数中调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//光线打到的是不是物体的外面？</span></span><br><span class="line">    <span class="keyword">bool</span> front_face;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个结构体内的函数，他判断法线的里外，并且在光线打到物体内面时取反法线。</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sphere.h中修改hit函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用这一个函数设置hit_record中的法线和front_face</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第6.2节到第6.4节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/25/%E5%85%89%E8%BF%BD1.4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/%E5%85%89%E8%BF%BD1.4/" class="post-title-link" itemprop="url">球</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-25T00:00:00+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:54:01" itemprop="dateModified" datetime="2022-04-02T16:54:01+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/25/%E5%85%89%E8%BF%BD1.4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/25/%E5%85%89%E8%BF%BD1.4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>接下来总要让一个对象让光线碰撞，这里选择使用最简单的物体：球<br>$$<br>X^2+Y^2+Z^2=R^2<br>$$<br>一个非常标准的球的数学表达式，这个公式表示以原点为球心，半径是R的球。所有坐标是（x,y,z）的点满足上面的表达式<strong>都在球上</strong>。接下来是点在球内和求外的公式：</p>
<p>$$<br>X^2+Y^2+Z^2&lt;R^2<br>$$</p>
<p>$$<br>X^2+Y^2+Z^2&gt;R^2<br>$$</p>
<p>假定球心为$(C_x,C_y,C_z)$<br>$$<br>(x-C_x)^2+(y-C_y)^2+(z-C_z)^2=r^2<br>$$<br>但是这个公式没有办法在我们的项目中使用，我们的底层使用的vec3类，更希望看到向量而不是标量表示，我们需要简单的改变一下这个公式。现在假设球形所在的坐标用<strong>C</strong>这个vec3类常量表示，即$C=(C_x,C_y,C_z)$。同样的令$P=(x,y,z)$有：<br>$$<br>(P-C)\cdot(P-C)=(x-C_x)^2+(y-C_y)^2+(z-C_z)^2<br>$$<br>上述式子的左侧是一个向量模的平方，右侧是一个距离公式。它们都表示P点和C点之间的距离的平方。所以有：</p>
<p>$$<br>(P-C)(P-C)=r^2<br>$$<br>所有满足这样要求的<strong>P</strong>——它到<strong>C</strong>点的距离为r，这样的点一定在以<strong>C</strong>为球心，r为半径的球上。</p>
<p>现在引入光线，如果光线曾在某一个时刻打在球上，则表示有一个t，使得$P(t)=A+tb$正好传播到了球的位置。带入它之后：<br>$$<br>(P(t)-C)\cdot(P(t)-C)=r^2<br>$$<br>展开：<br>$$<br>(A+tb-C)\cdot(A+tb-C)=r^2<br>$$<br>把左侧括号乘开，这里我们把$(A-C)$看作一个整体，再把右侧的移$r^2$到左侧。<br>$$<br>t^2b\cdot b+2tb\cdot(A-C)+(A-C)\cdot(A-C)-r^2 =0<br>$$<br>变成了一个t的一元二次方程。（b表示光线方向，A是光源位置，C是球心，全是常量）。</p>
<p><img src="https://s2.loli.net/2022/03/06/VImPT4rJxWjOvKF.png"></p>
<h2 id="碰撞函数"><a href="#碰撞函数" class="headerlink" title="碰撞函数"></a>碰撞函数</h2><p>在.cpp文件中main函数外写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简易的球的碰撞检测函数，吃球心，半径和一根光线，吐出光线是否击中球的bool值。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个oc就是上面函数里的(A-C).</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="comment">// 对应上面公式里的b的平方。即平方项的系数。</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 对应上面公式里的2*(A-C)点乘b，即一次项的系数</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// (A-C)点乘(A-C)减去r的平方，即常数项。</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="comment">//高中最爱的Δ，b的平方减4ac。</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="comment">//返回方程有没有根，即光线有没有碰撞到球体。</span></span><br><span class="line">    <span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果我们击中了这个球心在(0,0,1)且半径是0.5的球，就直接返回颜色为红色。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果没有击中的话你就继续画蓝天吧。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得到了一个不那么美丽的太阳！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223618931.png" alt="image-20220306223618931"></p>
<h2 id="可视化法线"><a href="#可视化法线" class="headerlink" title="可视化法线"></a>可视化法线</h2><p>如果我们得知光线和球的碰撞点为P，我们需要得到这一点的法线，它应该是从球心发射，穿过这一点指向球的外侧，所以是<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/3c59ca980a313e3ab91bf87f5db239c0.svg" alt="img">。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223737173.png" alt="image-20220306223737173"></p>
<p>这里需要考虑两个问题：</p>
<ul>
<li>它应该是单位向量吗？是的，它应该是，单位化法线可能会在某些方面为我们的渲染提供便利，但是不强制，并不要求法线一定是单位向量，如果必须是单位化的地方我们进行单位化即可。为了省去这一步骤这里选择永远单位化它。</li>
<li>之前我们给的hit_sphere函数的框架已经不足以满足我们获取法线的需要了，因为这里不仅仅需要了解球和光线是否碰撞，我们还得知道光线和球的第一个焦点的位置，因为只要不是极端的相切的情况，我们总能找到两个焦点，所以我们需要t较小的那个焦点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它不再返回bool，而是返回一个浮点数，表示光线第一次打在球上的时候的时间t。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Δ小于0，别看了，光线没打到球，直接返回一个负值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 求根公式，我们返回了较小的那个根。</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过得到的法线返回颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//如果光线击中了球。</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    	<span class="comment">//拿到法线，嘿嘿，我们之前写过很久的at函数终于派上用场了。我们这次单位化它。</span></span><br><span class="line">        vec3 N = <span class="built_in">unit_vector</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//返回法线可视化之后的颜色值，注意我们做了一个[-1,1]到[0,1]的映射。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*<span class="built_in">color</span>(N.<span class="built_in">x</span>()+<span class="number">1</span>, N.<span class="built_in">y</span>()+<span class="number">1</span>, N.<span class="built_in">z</span>()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没打中？继续画蓝天吧。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将hit_shpere函数的返回值由bool改为第一次碰撞的时间t，并在取色函数中通过时间t获取碰撞点，并计算出法线，最后将法线映射为颜色，最终我们可以看到一个元气弹！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307085406164.png" alt="image-20220307085406164"></p>
<h2 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h2><ol>
<li>在红太阳阶段的代码中如果将太阳放在相机后面会发生什么呢？</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223618931.png" alt="image-20220306223618931"></p>
<p>可以看到与放在相机前没有任何变化，我认为是主要是因为这段代码虽然判断了碰撞函数是否有解，但是忽略了t小于0 的情况，以至于放在相机前后没有区别，用第二段代码就没有任何问题。</p>
<ol start="2">
<li>元气弹的颜色遵循什么规律呢？</li>
</ol>
<p>按照代码逻辑应该是碰撞法线x,y,z分量分别对应r,g,b的值。那么应该是向右越来越红，向上越来越绿，由中心向外越来越蓝。</p>
<ol start="3">
<li>使用元气弹版本的代码，更改hit_sphere函数，这次返回较大的那个根，生成图片另外保存。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求根公式，这次返回较大的那个根。</span></span><br><span class="line"><span class="keyword">return</span> (-b + <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307092334496.png" alt="image-20220307092334496"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第5节和第6.1节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/23/%E5%85%89%E8%BF%BD1.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/%E5%85%89%E8%BF%BD1.3/" class="post-title-link" itemprop="url">光线、相机与天空</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-23T00:00:00+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:54:08" itemprop="dateModified" datetime="2022-04-02T16:54:08+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/23/%E5%85%89%E8%BF%BD1.3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/23/%E5%85%89%E8%BF%BD1.3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h2><p>如何将抽象的光线具体的表现出来并不困难，在初中物理的时候我们就使用一个点加上一个射线的方式来表示光线，于是我们可以用这样的公式描述它：<code>P(t)=A+t*b</code></p>
<p><img src="https://s2.loli.net/2022/03/05/s71P5mzYDjenywC.png" alt="image.png"></p>
<p><strong>A</strong>表示光线的原点（光源位置），<strong>b</strong>为一个单位向量表示一个方向，t则表示单位时间，通过给t取不同的值，我们可以得到沿路上所有的点的三维坐标，当然，这个值一般来说不会为负数，我们新建ray.h，输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//空构造。</span></span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//带参构造，显然我们需要一个原点和一个方向。</span></span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//通过这个函数拿取原点值。</span></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">		<span class="comment">//通过这个函数拿取方向值。</span></span><br><span class="line">    	<span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//这个函数就对应了上方数学公式中的P(t)，通过传入一个时间t，能得到当前光线传播到的坐标位置。</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>我们把“相机”固定在一个位置，并且固定一下它观察的方向。</p>
<p>接下来需要解决两个问题：</p>
<ol>
<li>光线从哪里射出呢？相机位置。按照常理来说，太阳发出的光线从物体上弹射了多次，最终会被摄像机（或者人眼）捕捉。相机位置应该是光线的终点才对啊，怎么会是起点呢？<strong>原因是我们需要逆光路取色，这是路径追踪的经典光线模型，重点是我们的光线和现实中的光线是反过来的，如果正向光路进行光线追踪会极其困难，几乎寸步难行。</strong></li>
<li>光线朝哪个方向射出呢？这就要引出一个“虚拟视口”的概念。它就像一个相框，摆在相机的前面，相机发射的密集光铺满相框，就得到图像，具体方法为：<strong>按照行优先的顺序，从左上角开始，一排一排的射出光线，射出光线的数目就是像素的数目，换句话说，我们对每一个像素都会射出一根光线</strong>。</li>
</ol>
<p>将相机位置定位（0，0，0）这个场景是这样的：</p>
<p><img src="https://s2.loli.net/2022/03/05/qhcP98ZAYve1SCt.png" alt="image.png"></p>
<p>假设图中的虚拟视口上有800个像素，每个像素长宽都是0.1，最终得到一张40*20的图片，我们只需要瞄准<strong>每一个像素的中心</strong>。</p>
<p>按照行优先左上角开始，发生的第一根光线应该是从（0，0，0）射向（-2+0.05，1-0.05，-1）方向。不必要求这个方向向量是一个单位向量，保持方向向量是单位向量并不能给项目提供更多便利。如此类推：第二个是（-2+0.15，1-0.05，-1）方向、第四十个是（-2+3.95，1-0.05，-1）方向、第八百个是（-2+3.95，1-1.95，-1）方向。</p>
<p>改写main函数，并且为其所在的文件添加一个全局函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个简单的决定光线所带回颜色的函数。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先把这个光线的方向向量单位化。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再根据这个单位化向量的y分量给他设定颜色，得保证t在[0,1]之间。</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 插值函数，t靠近0它就越靠近白色，越靠近1它就越靠近一种蓝色。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//图片数据，这次我们换一种角度去定义图片的长宽，我们定义一个长宽比，再把它的宽度定义出来。</span></span><br><span class="line">    <span class="comment">//长度就可以通过简单的计算得到。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟视口数据，我们保持它的高度（宽度）为2，长度同样通过长宽比得到。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//保持视口和实际图片的长宽比一致。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height; </span><br><span class="line">    <span class="comment">//这是视口离相机的距离，保持为1就好，我们暂时把它写死。</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相机位置</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//相机水平方向，即X轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//相机头顶方向，即Y轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个是虚拟视口左下角所在位置的坐标，在上面那个图片例子里，它就是（-2，-1，-1）。</span></span><br><span class="line">    <span class="comment">//注意因为长宽比不是2/1而是16/9，所以本例子里这个值和图片中的值不同。</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环（render loop）</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//这个uv就是当前像素位置的横纵坐标偏移。</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//创造射线。</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            <span class="comment">//通过全局函数取到本像素颜色。</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="comment">//写颜色到输出流。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/05/qt3BYcAd9NI5kvS.png" alt="image.png"></p>
<p>通过光线在y轴方向上的分量得到一种类似于蓝天的效果，这个图片也将在后来成为我们的背景。</p>
<h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><p>1：循环渲染射出光线瞄准的是哪里呢？仔细计算可以发现，是每个像素的左上角，并不是中心点，其实左上角又或是中心点这一点的颜色都不能代表整个像素的颜色，这个问题后续将会解决。</p>
<p>2：更改ray_color函数可以制作一些更加炫酷的背景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec = r.<span class="built_in">direction</span>() * <span class="number">1</span> - r.<span class="built_in">origin</span>(); </span><br><span class="line">    <span class="keyword">auto</span> absVec = <span class="built_in">vec3</span>(std::<span class="built_in">abs</span>(vec.<span class="built_in">x</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">y</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unit_vector</span>(absVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/05/OVRxAhGDbnywlYm.png" alt="image.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第4节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/21/%E5%85%89%E8%BF%BD1.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E5%85%89%E8%BF%BD1.2/" class="post-title-link" itemprop="url">点、向量、颜色</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T00:00:00+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:54:14" itemprop="dateModified" datetime="2022-04-02T16:54:14+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/21/%E5%85%89%E8%BF%BD1.2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/21/%E5%85%89%E8%BF%BD1.2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>既然是光追，肯定离不开点和方向于颜色，在大多数工程中，颜色和方向是四维的向量，但是对于这个工程，三位向量可以满足需求，我们定义一个类来表示它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止被重复引用，用ifndef去包裹所有代码。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要一些cmath类里面的数学函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精确引用，只需要开方函数就只引入最小的命名空间</span></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 空构造，默认构造一个（0，0，0）向量</span></span><br><span class="line">        <span class="built_in">vec3</span>() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 传入三个参数的构造。</span></span><br><span class="line">        <span class="built_in">vec3</span>(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义x，y，z分量。这样就可以用 向量.x() 直接拿取x分量。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//下面进行运算符重载。</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//单目 &#x27;-&#x27; 运算符 ，会对三维向量的每一维取反。</span></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符的const版本，返回右值。</span></span><br><span class="line">    	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符普通版本，返回左值</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;+=&#x27;运算符，const保护参数不被修改，返回引用允许操作符嵌套。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// &#x27;*=&#x27;运算符</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;/=&#x27;运算符，直接使用*=去定义&#x27;/=&#x27;。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//模相关。</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 模的平方。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 模</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 向量中的数组也直接暴露出去了，这里是float也没问题，看你的喜好。</span></span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给vec3类多起几个名字。</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point，在指定三维空间中的点的时候使用这种别名。</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color，在指定颜色的时候使用这种别名。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="类外补充"><a href="#类外补充" class="headerlink" title="类外补充"></a>类外补充</h2><p>接下来是一些加减乘除等操作，其中的有些操作并不可以写在类内，比如double类型<code>*</code>vec3类型，所以统一写在类外：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vec3 类外函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出流符号&quot;&lt;&lt;&quot;</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123; </span><br><span class="line">    <span class="comment">//当用户使用 cout &lt;&lt; vec3的时候，输出vec3中的各个分量值。</span></span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符，它的返回值不是引用，这很合理，我们永远不会把 “a + b”这样的东西放在赋值符号左侧</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，向量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，标量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还是*运算符，但这次参数中标量和向量的顺序是反过来的。</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用*去定义/</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量点乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量叉乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单位化这个向量，就是把它的各个分量除以它的长度，正好，我们可以用上面刚刚写完的/运算符去定义它。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽离与简化"><a href="#抽离与简化" class="headerlink" title="抽离与简化"></a>抽离与简化</h2><p>在第一章时，有三行将0-1的通道映射到0-255的代码，这部分代码是固定的，可以统一将它们抽离出去，创建、<code>color.h</code>文件，以后的关于渲染颜色的代码统一放到这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个全局的函数，接受一个输出流参数，和一个color参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把之前的代码两步并作一步，直接转到[0,255]区间然后直接输出出去。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来main函数的代码将相当简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//直接调用vec3类有参构造构造一个对象</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写颜色！如此的简单！</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第3节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/19/%E5%85%89%E8%BF%BD1.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" class="post-title-link" itemprop="url">生成第一张图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-19T00:00:00+08:00">2022-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:54:21" itemprop="dateModified" datetime="2022-04-02T16:54:21+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/19/%E5%85%89%E8%BF%BD1.1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前言：</strong>前段时间在学习C++ primer的同时，我还有幸接触到了一本非常有趣的书，它通过我们的vs写出的代码直接模拟光线追踪生成图像。地址：<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a>。它非常的有趣也具有很高的学习价值，所以我想把学习的过程记录下来，也欢迎大家来一起学习并找出其中的错误，废话不多说，直接开始！</p>
<h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>首先明确我们这里使用的是ppm格式的图片格式，它是通过类似于<code>vector&lt;vector&lt;int&gt;&gt;</code>的方式记录下每个色素的RGB值。</p>
<p><img src="https://s2.loli.net/2022/03/04/enLDpxsbyNRazIu.png" alt="image.png"></p>
<p>此外在开头还需要做一些说明：</p>
<ul>
<li>P3#代表颜色使用ASCII码表示</li>
<li>3 2#代表3行两列，它使得我们接下来的数字不需要按照行列摆放工整，而是可以</li>
<li>255#表示使用0-255来表示一个通道的颜色</li>
</ul>
<p>可以试着通过代码来生成一张这样的图片：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义图片的宽度和高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印ppm文件的开头</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以左下角为原点，从左上方依次打印像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//将r和g通道控制在0-1内</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line">			<span class="comment">//之后统一将它们映射到0-255</span></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">			<span class="comment">//依次输出rgb，注意中间空格</span></span><br><span class="line">            std::cout &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码之后，我们以release方式运行，之所以不选择debug模式，主要还是因为太耗费时间，在保证代码不出现错误的情况下，使用release可以节省一些时间。</p>
<p><img src="https://s2.loli.net/2022/03/04/RCEOVqXUlxdi9TI.png" alt="image.png"></p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>以上代码只能让信息输出到控制台，而我们希望将其输出到一个文件内，所以我们可以使用命令行实现：</p>
<ul>
<li>打开命令行输入项目所在硬盘加冒号之后回车，如：<code>D:</code></li>
<li>接着输入，cd+空格+项目文件下的release文件夹地址后回车，如：<code>cd D:\C++\RayTracing\x64\Release</code>同时还要注意是X86还是X64。</li>
<li>之后输入<code>raycast.exe &gt; image.ppm</code>，raycast.exe为我们的程序，使用<code>&gt;</code>重定向将数据输出到文件名为image1.1的文件中，同时指定文件格式为ppm</li>
</ul>
<p>最后依次回车之后我们就可以在release文件夹下看到一个image的图片文件，如果打不开，可以下载一个极速看图软件。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220304224339897.png" alt="image-20220304224339897"></p>
<p>一张非常绚丽的图，正如我们代码中的那样，从左到右越来越红，从下到上越来越绿。</p>
<h2 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h2><p>现在我们并不知道图片能够多久加载完成，当所需要的图片像素点非常多时，这个问题会更加明显，所以我们使用std::cerr来显式加载的进度，它主要用于显示错误消息，且不被缓冲，可以发送到显示器，并且不被重定向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 提示还有多少行数据没有处理完。</span></span><br><span class="line">       std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提示已经完全搞定。</span></span><br><span class="line">   std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>同时使用“\r”可以把光标强行移回本行开头，这样这次输出的内容就会覆盖掉这一行原本的内容，就好像每次到来的新东西会“冲洗”掉之前输出的东西。</p>
<p>注意这一行的结尾是std::flush，它表示再输出完这一行之后，会强行把内存中缓冲区内的数据打出到错误输出流里（清空缓冲区）。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sss_0916/article/details/95622404?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5.pc_relevant_default&spm=1001.2101.3001.4242.4&utm_relevant_index=8">endl、ends和flush的区别</a></p>
<p>再次使用命令行就可以看到</p>
<p><img src="https://s2.loli.net/2022/03/04/hHqw6jYGFof7dPX.png" alt="image.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第2节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十六章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-15T00:00:00+08:00">2022-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:42" itemprop="dateModified" datetime="2022-03-04T12:58:42+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> string&amp; v1, <span class="keyword">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl &lt; v2) <span class="keyword">return</span> -l; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; v1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于像这样除了类型意外一模一样的函数，我们可以使用模板来适配各种各样的类型。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板，而不是为每一个类型定义一个新的函数。则compare的模板可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; vl) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板定义以关键字template开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(&lt;)和大于号(&gt;）包围起来。</p>
<p><strong>在模板定义中,模板参数列表不能为空。</strong></p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>调用一个函数模板时，编译器用函数的实参来推断模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt; endl; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>

<p>编译会推断出实参int，并绑定到T，这样推断出来的为我们<strong>实例化</strong>一个特定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T为int</span></span><br><span class="line"><span class="comment">//实例化出int compare (const vector&lt;int&gt;&amp;,const vector&lt;int&gt;&amp;)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;, vec2&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1, vec2) &lt;&lt;endl; <span class="comment">// T为vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里编译器会实例化两个不同版本的compare。其中一个T为int，另一个T为vector<int>，编译器生成的版本成为模板的实例。</p>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>我们的compare函数有一个模板类型参数(type parameter)。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:返回类型和参数类型相同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">Tfoo</span> (T* p)&#123;</span><br><span class="line">	T tmp = *p; <span class="comment">// tmp 的类型将是指针p指向的类型/ / ...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数前必须使用关键字class或typename:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:U之前必须加上class或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;)</span> </span>;</span><br><span class="line"><span class="comment">//正确:在模板参数列表中,typename和class没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="built_in">calc</span> (<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;) ;</span><br></pre></td></tr></table></figure>

<p>因为可以使用非类的类型作为模板实参，所以使用typename更为直观。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了模板参数，我们还可以定义非类型参数，简言之就是一个固定的值，当模板被实例化后，非类型模板参数就被这个值所取代，这个值也必须时常量表达式，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span> (p1, p2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span> ( <span class="string">&quot;hi&quot;</span>, <span class="string">&#x27;mom&quot;)</span></span><br></pre></td></tr></table></figure>

<p>最后编译器使用字面常量大小代替N和M：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1) [<span class="number">3</span>],<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。</p>
<p>通常在需要常量表达式的地方需要用到此参数。</p>
<h4 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:inline说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误:inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>通过const＋引用的方式，我们保证了函数可以用于不能拷贝的类型。</p>
<p>此外，我们没必要即使用<code>&lt;</code>又使用<code>&gt;</code>运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//期望的比较操作</span></span><br><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -l;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//即使用于指针也正确的compare版本;参见14.8.2节（第510页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">( less&lt;T&gt;()(vl, v2))</span> <span class="keyword">return</span> -1</span>;</span><br><span class="line"><span class="keyword">if</span> ( less&lt;T&gt;() (v2, v1)) <span class="keyword">return</span> l;<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的（据查阅资料，less<T>的默认实现用的就是&lt;，所以这其实并未起到让这种比较有一个良好定义的作用—译者注)。</p>
<p><strong>模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>编译器遇到模板时，只有当实例化除模板特例时，才会生成代码。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同:为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>关键概念:模板和头文件</strong></p>
<p>模板包含两种名字:</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p>当使用模板时,所有不依赖于模板参数的名字都必须是可见的,这是由模板的提供者来保证的。而且,模板的提供者必须保证，当模板被实例化时,模板的定义,包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件,包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件,以及用来实例化模板的任何类型的头文件。</p>
<h4 id="实例化器件错误报告"><a href="#实例化器件错误报告" class="headerlink" title="实例化器件错误报告"></a>实例化器件错误报告</h4><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<p>例如原始版本的<code>if (vl &lt; v2) return -l;//要求类型T的对象支持&lt;操作</code>其中如果调用者传入类型没有<code>&lt;</code>运算符，则会在第三个阶段报错。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板是用来蓝图的，编译器不能为类推断参数类型。必须在尖括号中提供额外的信息，用来代替参数的模板实参列表。</p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>我们实现StrBlib的模板版本，为Bolb，不在针对string，使用时用户需要指出元素类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t ypedef T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;T&gt; : :size_type size_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: : initializer_list&lt;T&gt; il);</span><br><span class="line">	<span class="comment">// Blob中的元素数目</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="comment">//移动版本，参见13.6.3节（第484页)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std : : <span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (size_type i); <span class="comment">// 在14.5节(第501页)中定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: : shared ptr&lt;std : : vector&lt;T&gt;&gt; data;<span class="comment">//若data[i]无效，则抛出msg</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std: :string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例如，我们将元素访问操作的返回类型定义为T&amp;。当用户实例化Blob时，T就会被替换为特定的模板实参类型。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>使用类模板时，提供额外信息，这些信息实际上是显示模板实参列表，它们被绑定到模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;					<span class="comment">//空Blob&lt;int&gt;</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; 	<span class="comment">//有5个元素的Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是编译器生成一个类似这样的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;<span class="keyword">int</span>&gt;: :size_type size_type; </span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: :initializer_list&lt;<span class="keyword">int</span>&gt; il); <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: :shared ptr&lt;std: :vector&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std : : string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联,也不会对任何其他B1ob类型的成员有特殊访问权限。</strong></p>
<h4 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h4><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的data 成员使用了两个模板，vector和 shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是Blob的模板参数。因此，data的定义如下:</p>
<p><code>std: :shared_ ptr&lt;std: : vector&lt;T&gt;&gt; data;</code></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</p>
<p>当我们定义一个成员函数时，模板实参与模板形参相同。对于strBlob的一个给定的成员函数</p>
<p><code>ret-type StrBlob : : member-name(parm-list)</code></p>
<p>对应的Blob的成员应该是这样的:</p>
<p><code>template &lt;typename T&gt; ret-type Blob&lt;T&gt;: :member-name(parm-list)</code></p>
<h4 id="check和元素访问成员"><a href="#check和元素访问成员" class="headerlink" title="check和元素访问成员"></a>check和元素访问成员</h4><p>我们首先定义check成员，它检查一个给定的索引:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">check</span>(size_type i,<span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;=data-&gt;<span class="built_in">size</span> ())</span><br><span class="line">		<span class="keyword">throw</span> std: :<span class="built_in">out_of_range</span>(msg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用模板参数指出返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;: : <span class="built_in">back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>); <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt; : : <span class="keyword">operator</span>[](size_type i) &#123;</span><br><span class="line">	<span class="comment">//如果i太大，check会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    <span class="built_in">check</span> (i, <span class="string">&quot;subscript out of range&quot;</span> ) ;</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pop_back函数与原StrBlob的成员几乎相同:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Blob构造函数"><a href="#Blob构造函数" class="headerlink" title="Blob构造函数"></a>Blob构造函数</h4><p>与类模板外函数一样，构造函数先定义模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span> (std: :make_shared&lt;std: :vector&lt;T&gt;&gt;())&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>分配一个空vcector，并将指向vector的指针保存在data中，还要有接受一个initializer_list参数的构造函数将其类型参数工作为initializer list参数的元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std: :initializer_list&lt;T&gt; il):</span><br><span class="line">			<span class="built_in">data</span>(std: :make_shared&lt;std: :vector&lt;T&gt;&gt;(il))&#123; &#125;	</span><br></pre></td></tr></table></figure>

<p>为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob的元素类型兼容:</p>
<p><code>Blob&lt;string&gt; articles = &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot; &#125;;</code></p>
<h4 id="类模板成员的实例化"><a href="#类模板成员的实例化" class="headerlink" title="类模板成员的实例化"></a>类模板成员的实例化</h4><p>只有当程序用到它时才会进行实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; squares = &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt; : :size ( ) const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != squares.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	squares[i] = i*i;<span class="comment">//实例化Blob&lt;int&gt; : : operator[] (size_t)</span></span><br></pre></td></tr></table></figure>

<p>实例化了 Blob<int>类和它的三个成员函数: operator[ ] 、 size和接受initializer_list<int>的构造函数。</p>
<p><strong>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
<h4 id="在类内简化模板类名"><a href="#在类内简化模板类名" class="headerlink" title="在类内简化模板类名"></a>在类内简化模板类名</h4><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若试图访问一个不存在的元素，BlobPtr抛出一个异常template &lt;typename T&gt; class BlobPtr &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, <span class="keyword">size_t</span> sz - <span class="number">0</span>):</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; </span><br><span class="line">        <span class="comment">// (*p)为本对象指向的vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递增和递减</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置运算符</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--( );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check 返回一个指向vector的shared_ptr</span></span><br><span class="line">	std: :shared_ptr&lt;std: :vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std : : <span class="keyword">size_t</span>, <span class="keyword">const</span> std : : string&amp;) <span class="keyword">const</span>; </span><br><span class="line">	<span class="comment">// 保存一个weak ptr，表示底层vector可能被销毁</span></span><br><span class="line">	std : : weak_ptr&lt;std : : vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std : : <span class="keyword">size_t</span> curr; <span class="comment">//数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在递增和递减函数中，我们返回的是BlobPtr&amp;，而不使用BlobPtr<T>&amp;，因为当处于一个类模板的作用域时，自身引用时就等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>

<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>由于在类外，只有遇到类名才代表进入类的作用域，所以类外函数返回自身需要使用BlobPtr<T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置:递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;: :<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查;调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//保存当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>;<span class="comment">//推进一个元素;前置++检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数体已经进入类内，所以可以直接使用BlobPtr。</p>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</strong></p>
<h4 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h4><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<h4 id="一对一友好关系"><a href="#一对一友好关系" class="headerlink" title="一对一友好关系"></a>一对一友好关系</h4><p>我们的Blob类应该将BlobPtr类和模板版本的Blob相等运算符定义为友元，此外我们在Blob加入可以用==运算符的友元函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在 Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span><span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;); </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">		(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">	<span class="comment">//其他成员定义，与12.1.1（第405页）相同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里在Blob类中出现的5个T，说明它将对应的类与函数声明为友元，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;<span class="comment">// BlobPtr&lt;char&gt;和operator==&lt;char&gt;都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;<span class="comment">// BlobPtr&lt;int&gt;和operator==&lt;int&gt;都是本对象的友元</span></span><br></pre></td></tr></table></figure>

<h4 id="通过和特定的模板友好关系"><a href="#通过和特定的模板友好关系" class="headerlink" title="通过和特定的模板友好关系"></a>通过和特定的模板友好关系</h4><p>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> &#123;</span><span class="comment">//C是一个普通的非模板类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;<span class="comment">//用类c实例化的Pal是c的一个友元/l Pal2的所有实例都是c的友元;这种情况无须前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">c2</span> &#123;</span><span class="comment">// C2本身是一个类模板</span></span><br><span class="line">	<span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;; <span class="comment">// Pal的模板声明必须在作用域之内</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> x&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">	<span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span><span class="comment">//不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
<h4 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Type; <span class="comment">//将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成为Bar<Foo>的友元，sales data将成为Bar<Sales data>的友元，依此类推。</p>
<h4 id="模板的类型别名"><a href="#模板的类型别名" class="headerlink" title="模板的类型别名"></a>模板的类型别名</h4><p>可以给已经实例化的类起别名：<code>typedef Blob&lt;string&gt; StrBlob;</code>模板起别名的方式为则不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以固定多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">// books是一个pair&lt;string,unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars是一个pair&lt;Vehicle,unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids是一个pair&lt;Student,unsigned&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>类模板也可以声明static成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> std: :<span class="function"><span class="keyword">size_t</span> <span class="title">count</span> <span class="params">()</span></span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">//其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> std: : <span class="keyword">size_t</span> ctr;<span class="comment">//其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的static成员会在同一个类型内共享，如Foo<X>这个类型的所有对象，共享这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化static成员Foo&lt;string&gt; ::ctr和Foo&lt;string&gt; : :count</span></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line"><span class="comment">//所有三个对象共享相同的Foo&lt;int&gt; : :ctr和Foo&lt;int&gt; : : count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2,fi3;</span><br></pre></td></tr></table></figure>

<p>数据成员也同样如此，且必须有且仅有一个定义，所有该特定类的对象共享此成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt; : : ctr = <span class="number">0</span>; <span class="comment">//定义并初始化ctr</span></span><br></pre></td></tr></table></figure>

<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问static成员，我们必须引用一个特定的实例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;						<span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">count</span> () ;	 <span class="comment">//实例化Foo&lt;int&gt; ; :count</span></span><br><span class="line">ct = fi.<span class="built_in">count</span> ();					<span class="comment">//使用Foo&lt;int&gt; : : count</span></span><br><span class="line">ct= Foo: :<span class="built_in">count</span> ();					<span class="comment">//错误:使用哪个模板实例的count?</span></span><br></pre></td></tr></table></figure>

<p>static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板参数的名字不仅可以是T还可以是其他任何命名。</p>
<h4 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h4><p>一个模板参数可用范围是在其声明之后，至模板声明或定义结束之前。与其他任何名字一样的是模板参数隐藏外层作用域声明的相同的名字，不同的是，在模板内不能重用模板参数名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a,B b)</span></span></span><br><span class="line"><span class="function">	A tmp </span>= a;<span class="comment">// tmp的类型为模板参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;<span class="comment">//错误:重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于模板名字不能重用，所以在模板参数列表也只能出现一次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:非法重用模板参数名v</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> v, <span class="keyword">typename</span> v&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>模板的声明必须包括模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明但不定义compare和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
<h4 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h4><p>由于使用：：运算符在模板参数上就会有困难，如：T：：men，它不知道men声明类型成员和static数据成员，所以必须知道这个T是否表示一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>如果希望使用一个类型成员就必须显示使用typename关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p><strong>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用 class。</strong></p>
<h4 id="默认的模板实参"><a href="#默认的模板实参" class="headerlink" title="默认的模板实参"></a>默认的模板实参</h4><p>就像函数的默认实参一样，我们也可以为模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2，Ff = <span class="built_in">F</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(vl, v2) ) <span class="keyword">return</span> -l;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户调用时，可以自己提供，也可以使用默认的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = <span class="built_in">compare</span> (<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//使用less; i为-1</span></span><br><span class="line"><span class="comment">//结果依赖于item1和item2中的isbn</span></span><br><span class="line"><span class="function">sales_data <span class="title">item1</span><span class="params">(cin)</span>, <span class="title">item2</span><span class="params">(cin)</span> </span>;</span><br><span class="line"><span class="keyword">bool</span> j = <span class="built_in">compare</span> (iteml, item2,compareIsbn);</span><br></pre></td></tr></table></figure>

<p>与函数默认实参一样,对于一个模板参数,只有当它右侧的所有参数都有默认实参时它才可以有默认实参。</p>
<h4 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h4><p>同样的，类可以使用默认模板参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> &#123;</span><span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Numbers</span>(T V = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line">	<span class="comment">//对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>

<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><h4 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h4><p>若一个普通类中有一个模板函数，便被称为成员模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象类，对给定指针执行delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DebugDelete</span>(std::ostream&amp; s = std::cerr) :<span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">	<span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std : : endl; <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::ostream &amp; os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个类似unique_ptr的使用的默认删除器，根据不同的类型进行销毁操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">//可像delete表达式一样使用的对象</span></span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用 DebugDelete: :operator() (double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在一个临时 DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip) ;</span><br></pre></td></tr></table></figure>

<p>我们就可以用这个类型替换unique_ptr中的删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁p指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;int&gt; (int *)</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>，DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>,DebugDelete())</span></span>;</span><br><span class="line"><span class="comment">//销毁sp指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;string&gt; (string* )</span></span><br><span class="line"><span class="function">unique _ptr&lt;string,DebugDelete&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> string,DebugDelete() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>当unique_ptr析构函数调用时，De—类便会实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebugDelete的成员模板实例化样例</span></span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">int</span> *p) <span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>()(string *p)<span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h4><p>类和成员有各自的模板，即可以像这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="built_in">Blob</span> (It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::<span class="built_in">Blob</span> (It b, It e):</span><br><span class="line">		<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h4><p>为了实例化上一个模板类的成员模板，我们必须同时提供类和函数的实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] =&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">long</span>&gt; vi = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; w = &#123; <span class="string">&quot;now&quot;</span> , <span class="string">&quot;is&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;time&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类及其接受两个int*参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span> <span class="params">(begin(ia), end (ia))</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt; : :iterator的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin (), vi.end ())</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;string&gt;及其接受两个list&lt;const char*&gt; : :iterator参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;string&gt; <span class="title">a3</span> <span class="params">( w.begin (), w.end ())</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义a1时就实例化了如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">Blob</span> (<span class="keyword">int</span>* , <span class="keyword">int</span>* );</span><br></pre></td></tr></table></figure>

<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板,并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>在新标准中，我们可以通过显式实例化(explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;		<span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;				<span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">//declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</span></span><br><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;				<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>

<p>编译器遇到extern声明时，它不会在本文件中生成实例化代码，而是承诺其他地方有这样的实例化，我现在只是使用它，对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p>extern声明必须在任何使用此实例之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cc</span></span><br><span class="line"><span class="comment">//这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sal,sa2; <span class="comment">//实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; al = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(al)</span></span>; <span class="comment">//拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">compare</span>(a1 [<span class="number">0</span>],a2[<span class="number">0</span>]);<span class="comment">//实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>

<p>上面的这些使用extern的实例必须在其他地方有定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">//实例化文件必须为每个在其他文件中声明为extern 的类型和函数提供一个(非extern)的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;<span class="comment">//实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>

<p><strong>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
<h4 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h4><p><strong>在一个类模板的实例化定义中,所用类型必须能用于模板的所有成员函数。</strong></p>
<h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>unique_ptr避免了间接调用删除其的运行时开销，而shared_ptr使用户可以重载删除器。前者有效率，后者有灵活度。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li>const转换:可以将一个非 const对象的引用（或指针）传递给一个const的引用（或指针）形参。</li>
<li>数组或函数指针转换:如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T，T)</span></span>;<span class="comment">//实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 引用</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">s2</span> <span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);<span class="comment">//调用fobj(string,string); const被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);<span class="comment">//调用fref(const string&amp;, const string&amp;)</span></span><br><span class="line"><span class="comment">//将s1转换为const是允许的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b) ;</span><br><span class="line"><span class="comment">//调用f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a,b);</span><br><span class="line"><span class="comment">//错误:数组类型不匹配</span></span><br></pre></td></tr></table></figure>

<p>在最后一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针(参见6.2.4节，第195页)。a和 b的类型是不匹配的，因此调用是错误的。</p>
<p><strong>将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有const转换及数组或函数到指针的转换。</strong></p>
<h4 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h4><p>模板的参数只允许几种有限的类型转换，因此传递的这些形参必须具有相同的类型。我们的compare函数接受两个const T&amp;参数，其实参必须是相同类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);<span class="comment">//错误:不能实例化compare (long, int)</span></span><br></pre></td></tr></table></figure>

<p>如果希望可以类型转换，可以将函数模板定义为两个类型参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span> <span class="params">(<span class="keyword">const</span> A&amp; v1,<span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl&lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2&lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cout,<span class="number">42</span>); <span class="comment">//实例化print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span> <span class="params">( <span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span> (f，<span class="number">10</span>);<span class="comment">//使用print (ostream&amp;, int);将f转换为ostream&amp;</span></span><br></pre></td></tr></table></figure>

<p>第一个函数参数是一个已知类型ostream&amp;。第二个参数 obj 则是模板参数类型。由于os 的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换:</p>
<p><strong>如果函教参教类型不是模板参数，则对实参进行正常的类型转换。</strong></p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>某些时候模板参数无法推断除类型，允许用户控制模板实例化。</p>
<h4 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h4><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">Tl <span class="title">sum</span><span class="params">(T2，T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没有任何参数可供推断出T1的类型，所以调用时必须提供一个显示模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);<span class="comment">// long long sum(int，long)</span></span><br></pre></td></tr></table></figure>

<p>显式模板实参时一一对应的，只有右边的可以忽略，但必须可以从函数参数推断出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//糟糕的设计:用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span> <span class="params">(T2,T1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则我们总是必须为所有三个形参指定实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; (i, lng) ;<span class="comment">//正确:显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>，<span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>所以把需要显示提供的参数放在最前面</p>
<h4 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h4><p>如果模板类型参数已经显式指定，页可以进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);					<span class="comment">//错误:模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare (long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare(int,int)</span></span><br></pre></td></tr></table></figure>

<p>第一个调用由于类型不匹配错误，后面的调用由于显式指定，而可以进行正常的类型转换。</p>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span> (It beg, It end)&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不知道返回结果的准确类型，但所需类型是所处理的序列的元素类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span> (vi.<span class="built_in">begin</span> (), vi.<span class="built_in">end</span>() ); 	<span class="comment">//fcn应该返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span> (ca.<span class="built_in">begin</span> (), ca.<span class="built_in">end</span>());		<span class="comment">// fcn应该返回string&amp;</span></span><br></pre></td></tr></table></figure>

<p>我们知道函数应该返回*beg，而且知道我们可以用decltype (*beg)来获取表达式类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg,It end)</span> -&gt; <span class="title">decitype</span> <span class="params">(*beg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h4><p>如果并不想返回引用而是返回其中的值，可以使用标准库<strong>类型转换</strong>模板。在头文件type_traits中，如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化 remove_reference&lt;int&amp;&gt;，则type 成员将是int。类似的，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string，依此类推。更一般的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span> (*beg) &gt;::type</span><br></pre></td></tr></table></figure>

<p>组合使用它们就可以在函数中返回元素值的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用模板参数的成员，必须用typename，参见16.1.3节（第593页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span> <span class="params">(It beg,It end)</span> -&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span> <span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png" alt="image.png"></p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>可以用一个函数模板对一个函数指针进行赋值，可根据形参生成一个实例，被指针所指：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> ( *pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<p>如果不能从函数指针类型却低估模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本;每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*) (<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span> (compare); <span class="comment">//错误:使用compare的哪个实例?</span></span><br></pre></td></tr></table></figure>

<p>由于既可以接受int和string版本的compare，所以调用失败。不过可以显式的指出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:显式指出实例化哪个compare版本</span></span><br><span class="line"><span class="built_in">func</span> (compare&lt;<span class="keyword">int</span>&gt;);<span class="comment">//传递compare (const int&amp;,const int&amp;)</span></span><br></pre></td></tr></table></figure>

<p><strong>当参数是一个函数模板实例的地址时,程序上下文必须满足:对每个模板参数,能唯一确定其类型或值。</strong></p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><h4 id="左值引用函数参数推断类型"><a href="#左值引用函数参数推断类型" class="headerlink" title="左值引用函数参数推断类型"></a>左值引用函数参数推断类型</h4><p>一个函数参数是模板类型参数的普通引用时，只能传递给它一个左值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参必须是一个左值//对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line"><span class="built_in">f1</span>(i);<span class="comment">// i是一个int;模板参数类型T是int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">// ci是一个const int;模板参数T是const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>); <span class="comment">//错误:传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果是const T&amp;,则推断结果不会是一个const类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">//f2中的参数是const &amp; ;实参中的const是无关的</span></span><br><span class="line"><span class="comment">//在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i);<span class="comment">//i是一个int;模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">//ci是一个const int，但模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);<span class="comment">//一个const&amp;参数可以绑定到一个右值;T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h4><p>如果函数参数是右值引用，如T&amp;&amp;，推断出T的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp; &amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">//实参是一个int类型的右值;模板参数T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h4><p>如果一个函数参数是指向模板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&amp;)。</p>
<h4 id="编写接受右值引用参数的模板函数"><a href="#编写接受右值引用参数的模板函数" class="headerlink" title="编写接受右值引用参数的模板函数"></a>编写接受右值引用参数的模板函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">	Tt = val; <span class="comment">//拷贝还是绑定一个引用?</span></span><br><span class="line">	t = <span class="built_in">fcn</span> (t) ; <span class="comment">//赋值只改变t还是既改变t又改变val?</span></span><br><span class="line">	<span class="keyword">if</span> (val == t)&#123;<span class="comment">/* ...*/</span> &#125;<span class="comment">//若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，如果传入42，则T会推断为int，但如果传入int的左值，则T会推断为int&amp;，则如果修改t的同时也会修改val。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; )</span> </span>;		<span class="comment">//绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;		<span class="comment">//左值和const右值</span></span><br></pre></td></tr></table></figure>

<p>通常是这样重载模板函数，与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>在13.6.2节中我们注意到，虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<h4 id="std-move如何定义"><a href="#std-move如何定义" class="headerlink" title="std::move如何定义"></a>std::move如何定义</h4><p>标准库的的move</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// static_cast是在4.11.3节（第145页）中介绍的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt; (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很短，但其中有些微妙之处。首先，move的函数参数T&amp; &amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span> <span class="params">( <span class="string">&quot;hi! &quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std: :<span class="built_in">move</span>(<span class="built_in">string</span> ( <span class="string">&quot;bye ! &quot;</span>) );<span class="comment">//正确:从一个右值移动数据</span></span><br><span class="line">s2 = std: :<span class="built_in">move</span>(sl);<span class="comment">//正确:但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>

<h4 id="std-move如何工作"><a href="#std-move如何工作" class="headerlink" title="std::move如何工作"></a>std::move如何工作</h4><p>如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型。因此，在<code>std: : move (string ( &quot;bye ! &quot;))</code>中:</p>
<ul>
<li>推断出的T的类型为string。</li>
<li>因此，remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp; 。</li>
<li>move的函数参数t的类型为string&amp; &amp;。</li>
</ul>
<p>因此，这个调用实例化move<string>，即函数<code>string&amp;&amp; move(string &amp;t)</code></p>
<h4 id="左值static-cast到右值引用时允许的"><a href="#左值static-cast到右值引用时允许的" class="headerlink" title="左值static_cast到右值引用时允许的"></a>左值static_cast到右值引用时允许的</h4><p>我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是const的以及实参是左值还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受一个可调用对象和另外两个参数的模板//对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现:顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f,T1 t1,T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用一个接受引用的参数就会出问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span><span class="comment">//注意v2是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;++v2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数第二个参数为引用，说明我们希望通过函数改变原变量的值，但是使用模板调用就会丢失这个引用的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,i);			<span class="comment">//f改变了实参i</span></span><br><span class="line"><span class="built_in">flip1</span>(f,j,<span class="number">42</span>);		<span class="comment">//通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非int&amp;。因此，这个flip1调用会实例化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn) (<span class="keyword">int</span>,<span class="keyword">int</span>&amp; ), <span class="keyword">int</span> t1,<span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h4><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值〉使得我们可以保持const属性,因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&amp;&amp;和 T2&amp;&amp;,通过引用折叠（参见 16.2.5节，第608页）就可以保持翻转实参的左值/右值属性（参见16.2.5节，第608页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2, t1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样调用就传递给t1一个左值j，t1会折叠为int&amp;，则t1会绑定到j上，就可以通过函数改变j的值。</p>
<p><strong>如果一个函数参数是指向模板类型参数的右值引用(如 T&amp;&amp;)，它对应的实参的const属性和左值/右值属性将得到保持。</strong></p>
<p>但是不能用于接受右值引用参数的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp; &amp;i, <span class="keyword">int</span>&amp; j)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传递一个右值给flip2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>);<span class="comment">//错误:不能从一个左值实例化int&amp; &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="std-forward保持类型信息"><a href="#std-forward保持类型信息" class="headerlink" title="std::forward保持类型信息"></a>std::forward保持类型信息</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line">	<span class="built_in">finalFcn</span> (std::forward&lt;Type&gt;(arg));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节。</strong></p>
<p>于是我们可以重写前面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f,T1 &amp; &amp;t1,T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">f</span> (std: :forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h4 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h4><p>首先编写俩个不同的函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	ostringstream ret;	<span class="comment">//参见8.3节（第287页)</span></span><br><span class="line">	ret &lt;&lt; t;			<span class="comment">//使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); 	<span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个对象对应string表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">//注意:此函数不能用于char*;参见16.3节（第617页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p;	<span class="comment">//打印指针本身的值</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;<span class="built_in">debug_rep</span> (*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; null pointer&quot;</span> ;<span class="comment">//或指出 p为空</span></span><br><span class="line">	<span class="keyword">return</span> ret.<span class="built_in">str</span>();<span class="comment">//返回ret绑定的string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内容并不重要，我们先看使用它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">( <span class="string">&quot;hi&quot;</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>这个调用只有第一个版本是可行的，第二个版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。</p>
<p>如果用一个指针调用debug_rep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>两个函数都生成可行的实例:</p>
<ul>
<li>debug rep(const string*&amp;)，由第一个版本的debug_rep实例化而来，T被绑定到string*。</li>
<li>debug rep(string*)，由第二个版本的 debug_rep实例化而来，T被绑定到string。</li>
</ul>
<p>但第二个版本更加精确，第一个版本需要进行普通指针到const的转换，编译器也会选择第二个版本。</p>
<h4 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (sp) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配:</p>
<ul>
<li><code>debug rep(const string*&amp;)</code>，由第一个版本的 debug_rep 实例化而来，T被绑定到<code>string*</code>。</li>
<li><code>debug rep(const string*)</code>，由第二个版本的 debug_rep 实例化而来，T被绑定到const string。</li>
</ul>
<p>再这种时候编译器会选择最特例化的，我的理解是，最简洁的，则选择第一个版本。</p>
<h4 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印双引号包围的string</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27; &quot;&quot; +s + &#x27;</span><span class="string">&quot;&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当同时匹配同样好的模板和非模板函数的时候，编译器一定会选择非模板版本。</p>
<h4 id="重载模板和类型转换"><a href="#重载模板和类型转换" class="headerlink" title="重载模板和类型转换"></a>重载模板和类型转换</h4><p>如果使用这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;<span class="comment">//调用debug_rep(T*)</span></span><br><span class="line"><span class="comment">//本例中所有三个debug _rep版本都是可行的:</span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> T&amp;)</span>，<span class="comment">//T被绑定到char [10]。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span><span class="params">(T*)</span>，<span class="comment">//T被绑定到const char。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> strina&amp;)</span>，<span class="comment">//要求从const char*到string 的类型转换。</span></span></span><br></pre></td></tr></table></figure>

<p>前两个版本都是匹配的，而第二个版本会被认为是精确匹配的，非模板版本是可行的，但需要一次用户定义的类型转换。所以选择第二个。</p>
<p>如果更希望使用字符版本，可以定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符指针转换为string，并调用string版本的 debug_reg</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h4><p>为了使用<code>char*</code>版本的函数，必须提前准备好其中的模板函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *P)</span></span>;</span><br><span class="line"><span class="comment">//为了使debug_rep(char*)的定义正确工作，下面的声明必须在作用域中string debug_rep (const string &amp;);</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function">i</span></span><br><span class="line"><span class="function"><span class="comment">//如果接受一个const string&amp;的版本的声明不在作用域中，</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回语句将调用debug_rep(const T&amp;)的T实例化为string 的版本return debug_rep(string(p) );</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</strong></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个<strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。存在两种参数包:<strong>模板参数包</strong>template parameter packet)，表示零个或多个模板参数;<strong>函数参数包</strong>（function parameteroacket)，表示零个或多个函数参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包; rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与往常一样，编译器从函数的实参推断模板参数类型。对于可变参数模板，编译器会推断保重的参数数目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span> ;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>,d);	<span class="comment">//包中有三个参数</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="built_in">foo</span>(d,s);			<span class="comment">//包中有一个参数</span></span><br><span class="line"><span class="built_in">foo</span> ( <span class="string">&quot;hi&quot;</span>);		<span class="comment">//空包</span></span><br><span class="line"><span class="comment">//编译器会为foo实例化出四个不同的版本:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;，<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> string&amp;)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h4><p>若需要知道包中的运算符，使用sizeof…运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt;endl; <span class="comment">//类型参数的数目</span></span><br><span class="line">	cout&lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;		<span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>. . . Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;...rest)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;，&quot;</span>;			<span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>print (cout, i, s,42); //包中有两个参数</code>来调用上面的函数，首先会匹配到第二个函数，然后递归调用第二个函数，直至最后一个参数由第一个函数打印。</p>
<p><strong>当定义可变参数版本的 print时，非可变参数版本的声明必须在作用域中。否则,可变参数版本会无限递归。</strong></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>除了获取其大小以外，我们还可以<strong>扩展</strong>，我们还要提供扩展元素的<strong>模式</strong>。就时分解为构成的元素，在模式右边放一个省略号(…)触发扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;<span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span><span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);		<span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个扩展操作扩展模板参数包，为 print生成函数参数列表。第二个扩展操作出现在对print的调用中。此模式为print调用生成实参列表。</p>
<h4 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">	<span class="comment">//print (os,debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span> (os,<span class="built_in">debug_rep</span> (rest)... ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看这样的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将包传递给debug_rep; print (os，debug_rep(a1,a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os,<span class="built_in">debug_rep</span>(rest.. .) );<span class="comment">//错误:此调用无匹配函数</span></span><br></pre></td></tr></table></figure>

<p>它们的区别就是第一个对扩展包中的每一个调用函数，第二个是在调用中展开：</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;...)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员的定义，同13.5节（第465页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">chk_n_alloc</span>(); <span class="comment">//如果需要的话重新分配 StrVec内存空间</span></span><br><span class="line">	alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emplace_back的函数体调用了chk_n_alloc（参见13.5节，第465页）来确保有足够的空间容纳一个新元素，然后调用了construct在first_free 指向的位置中创建了一个元素。construct调用中的扩展为</p>
<p><code>std: : forward&lt;Args&gt;(args) ...</code><br>它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素</p>
<p><code>std::forward&lt;T&gt;(t)</code></p>
<p>其中T,表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如.假定svec是一个strVec，如果我们调用</p>
<p><code>svec.emplace_back (10,&#39;c&#39;);//将cccccccccc添加为新的尾元素</code></p>
<p>construct调用中的模式会扩展出</p>
<p><code>std::forward&lt;int&gt; (10), std::forward&lt;char&gt;(c)</code></p>
<p>通过在此调用中使用forward，我们保证如果用一个右值调用emplace back，则construct也会得到一个右值。例如，在下面的调用中:</p>
<p><code>svec.emplace back (s1 + s2);//使用移动构造函数</code></p>
<p>传递给emplace_back的实参是一个右值，它将以如下形式传递给construct</p>
<p><code>std: :forward&lt;string&gt; (string ( &quot;the end&quot; ))</code></p>
<p>forward<string>的结果类型是string&amp;&amp;，因此construct将得到一个右值引用实参。construct会继续将此实参传递给string 的移动构造函数来创建新元素。</p>
<p><strong>建议:转发和可变参数模板</strong></p>
<p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的emp lace_ back函数一样的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">(Args&amp;&amp;... args)</span> <span class="comment">//将Args扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// work的实参既扩展Args又扩展args</span></span><br><span class="line">	<span class="built_in">work</span>(std: : forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们希望将fun的所有实参转发给另一个名为work的函数,假定由它完成函数的实际工作。类似emplace_back中对 construct的调用,work调用中的扩展既扩展了模板参数包也扩展了函数参数包。<br>由于 fun的参数是右值引用,因此我们可以传递给它任意类型的实参;由于我们使用std:: forward传递这些实参，因此它们的所有类型信息在调用work时都会得到保持。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp; )</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们定义了另一个版本的compare，当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用，而传递给它字符指针，就会调用第一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span> ;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);<span class="comment">//调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>( <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;mom&quot;</span> );<span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>因为无法将指针转换为数组的引用，因此参数是p1和p2时，第二个版本compare不可行。</p>
<p>为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例化( template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<h4 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h4><p>特例化一个函数模板时，必须为每个模板参数提供实参，在template后跟&lt;&gt;，指出正在实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个特例化版本时，函数的参数类型必须与先前模板中对应类型匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>特例化中T对应的为const char*，模板函数中为一个常量指针，而我们需要一个指向常量的指针，我们需要在特例化版本中使用的类型是const char * const &amp;，即一个指向const char的const指针的引用。</p>
<h4 id="函数重载与模板特例化"><a href="#函数重载与模板特例化" class="headerlink" title="函数重载与模板特例化"></a>函数重载与模板特例化</h4><p><strong>特例化的本质是实例化一个模板,而非重载它。因此,特例化不影响函数匹配。</strong></p>
<p><strong>关键概念:普通作用域规则应用于特例化</strong></p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且,在任何使用模板实例的代码之前,特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板,很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是,这种错误编译器又无法发现。</p>
<p><strong>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面,然后是这些模板的特例化版本。</strong></p>
<h4 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h4><p>我们将has模板定义一个特例化版本，用它保存Sale_data对象，为了让我们自己的数据类型能使用hash<key_type>，必须定义hash模板的一个特例化版本。一个特例化hash类必须定义:</p>
<ul>
<li>一个重载的调用运算符（参见14.8节，第506页)，它接受一个容器关键字类型的对象，返回一个size_t。</li>
<li>两个类型成员，result type和 argument_type，分别调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义，参见13.1.2节，第443页)。</li>
</ul>
<p>首先打开命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;<span class="comment">//我们正在定义一个特例化版本，模板参数为sales_data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Sales_data&gt; </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> sales_data argument_type;<span class="comment">// 默认情况下，此类型需要==</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> sales_data&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;string&gt;() (s.bookNo) ^</span><br><span class="line">            hash&lt;<span class="keyword">unsigned</span>&gt;() (s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="keyword">double</span>&gt;() (s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//关闭std命名空间;注意:右花括号之后没有分号</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz',
      appKey     : '6k9HROMoqf6vzPadEMksx26r',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>