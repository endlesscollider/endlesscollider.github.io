<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="祥瑞客栈">
<meta property="og:url" content="http://mackrui.com/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Collider">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mackrui.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">43</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/08/09/%E5%85%89%E8%BF%BD2.5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/09/%E5%85%89%E8%BF%BD2.5/" class="post-title-link" itemprop="url">简单纹理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-09 00:00:00 / 修改时间：11:45:15" itemprop="dateCreated datePublished" datetime="2022-08-09T00:00:00+08:00">2022-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/09/%E5%85%89%E8%BF%BD2.5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/09/%E5%85%89%E8%BF%BD2.5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="内容梳理"><a href="#内容梳理" class="headerlink" title="内容梳理"></a>内容梳理</h4><p>上一章我们引入包围盒的概念后，大大缩短了我们运行时间，但整体逻辑开始变的复杂起来，没关系，让我我们来一起梳理一下之前的内容。</p>
<p>首先我们把man函数当成一个raycast类，他除了需要一些长宽比，分辨率、采样数、反射深度等变量外，还需要一个自由相机、一个bvh_node构成的世界，有了这些，它就可以给我们呈现一张”美丽”的图片了，这其中两个关键就是相机和世界了。</p>
<p>先来看看相机，它由很多参数构造而成，但构造完成后，我们就不必管那么多，我们只需要在main函数传入一个0-1内的u、v值就可以得到我们想到的光线，再由ray_color函数来获得该光线带回的颜色。ray_color函数只需要光线，世界和深度就可以得到颜色，这个过程就是所谓的碰撞。</p>
<p>world是bvh_node类型，由一个hittable_list和两个时间构造而成，在构造函数中，对物体按随机轴进行二分直到只有一个物体或物体列表，为它们套上各自的包围盒后，回溯为每个节点的左右孩子一起套上更大的包围盒。目前的这种方式也代表了虽然我们可以在hitable_list里面包含hittable_list但是该函数并不会打开列表将里面的物体拿出来进行二分，所以当下为了更快的速度不建议这么做。</p>
<p>再回到我们的ray_color函数，光线首先会world这个最大包围盒检测，如果通过，继续检测左右孩子，当所有包围盒检测都通过之后，那么它便会和我们具体物体进行碰撞检测，由于我们的bvh的排序仅仅是通过比较每个节点最小值得到，所以是可能同时通过所有检测来到多个不同的物体进行碰撞，所以hit函数中深度检测也是必不可少的一环，将碰撞带回反射率和新的光线带回的颜色相乘就得到了这一次采样的结果，上述过程是一个递归的过程，反射光线回再一次与世界”碰撞“，直到反射的光线什么都没有碰到或者是碰到了光源。</p>
<p>这里还有一个非常重要的点，就是怎么得到的新的反射（折射光线）呢？这就是材质存在的意义了，每个物体中都包含一个材质，通过hit函数调用材质内的方法得到就可以得到一根新的光线！</p>
<p>将这样的采样重复一定次数取平均就得到这了这个像素点的颜色了，填满它们就得到我们的图片了。为了更加方便的理解这里放上他们的类图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%B1%BB%E5%9B%BE.png" alt="光线追踪类图"></p>
<p>最后谈谈我们是如何管理这个world，一切还得从hittable说起，它有我们最最最重要的碰撞函数hit，以及刚刚引入的bounding_box包围盒生成函数，还有四个继承者分别是球、移动球、物体列表以及bvh_node，继承者们自然需要实现基类的各自的碰撞及包围盒函数。</p>
<p>让我们来看看这些继承者们，首先最简单球和移动球，他们是抽象模型中最底层最具体的类，无论上层如何处理，最后的任务都要落到他们的头上，当然以后也会增加更多的物体（打工人），进行扩充，物体对hittable的继承也让我们可以通过容器统一进行管理实现多态。</p>
<p>物体列表可以看成一个总经理，他可以把分配任务和部门或是编号给手底下的打工人和小经理，也就是可以对列表内每一个物体执行碰撞检测和生成包围盒</p>
<p>bvh_node那就得是董事长了，给他一个经理，董事长给经理手底下的人排序编号，到时候有任务来了，就看看适合哪个部门的哪个编号的人干，这样公司，不对是光线就可以找到对应的物体进行碰撞了。</p>
<hr>
<p>好了，现在暂时忘掉它们。接下来几章的内容和包围盒、动态模糊以及时空光追都没有什么关系。换句话说，丢弃掉之前的那些代码也不影响这几章程序的运行。</p>
<p>我们将目光重新移回物体表面。回顾一下我们的三大材质：磨砂、金属和玻璃——难道我们的世界仅限于此吗？渲染器还不能描述陶瓷的纹路，又或是婴儿细腻的皮肤，甚至这个世界上的所有物体表面！世界上所有的东西都是不完美的，你见过没有划痕的金属和不沾上人类指纹的玻璃球么？</p>
<p>换句话来说，这个世界上不存在仅仅使用材质就可以完美模拟的物体表面。是时候请出材质最好的搭档——“纹理”了！</p>
<h4 id="纹理简谈"><a href="#纹理简谈" class="headerlink" title="纹理简谈"></a>纹理简谈</h4><p>纹理，在图形学领域通常表示程序化的物体表面颜色。比如，通过一些参数和数据，来计算得到物体表面某一点的颜色。根据具体计算方式不同可以大致分为两种：</p>
<p>①：找一张图，对于这个物体表面上的任意一点，都赋予其一个二维坐标，通过这个二维坐标在这个二维平面图上去找，找到的那一点是什么颜色，那物体表面该处就是什么颜色。这个二维坐标如何找到呢？一般来说是由建模师进行安排，建模师在制作模型的时候会为模型上的一些点指定一个二维坐标，其他的点的二维坐标就由这些给定点的插值进行计算——当然我们的渲染器到目前为止尚未引入三角面片的概念，这里不多谈。</p>
<p>这种方式得到的纹理看上去就好像是把这张二维图片贴到三维表面上一样，所以这又叫做贴图纹理。它的应用相当的广泛。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1651803841431-cf8bc296-b384-4de9-9300-b05c1816e02f.png" alt="img"></p>
<p>②：另一种获取各点的颜色的方式就显得比较理科生了：利用某种数学函数直接得到某点的颜色。这种纹理我们已经接触过了。还记得“元气弹”么？这就是一种纹理，我们把物体表面的法线信息映射到颜色区间并显示出来，当然这种纹理还有很多，利用法线只是其中的一种。</p>
<h4 id="纹理基类"><a href="#纹理基类" class="headerlink" title="纹理基类"></a>纹理基类</h4><p>每次引入一个新事物必定要先完成基类的编写，新建文件texture.h，并敲入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">texture</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>本纹理基类基于上小节中的第一种纹理类型：他只有一个函数，这个函数需要一个二维坐标u和v，返回一个颜色。当然，我们提到的拿着这个坐标去贴图中找颜色等等，这些都放到子类的value函数里来处理。从这个基类建立完成之后，如何得到颜色也就被规范化了，无论你是拿这个uv进行某种函数计算得到颜色，还是拿到某张图里去查找，这些都是子类该干的事情。</p>
<p>当然，仅仅传入uv并不能得到诸如“元气弹”之类的纹理，如果你需要通过纹理类创建元气弹，我们可以在之后再改造这个基类，加入诸如法线等等的参数。</p>
<p>至于这个u,v坐标从何而来，不是纹理类该管的事情，uv的计算不该放在这个类里，这个我们之后介绍。</p>
<p>uv坐标作为引入纹理之后碰撞中最重要的信息之一，需要把它写进record结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    vec3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="comment">//uv坐标。</span></span><br><span class="line">    <span class="keyword">double</span> u;</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">    <span class="keyword">bool</span> front_face;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4 id="纯色纹理"><a href="#纯色纹理" class="headerlink" title="纯色纹理"></a>纯色纹理</h4><p>我们的金属和磨砂类都有名为albedo的变量来控制最终颜色。其实纯色也可以被当作一种纹理，就好像我们把<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/276f208c260ee34aab2ec24423417272.svg" alt="img">也当作一种函数（常值函数）一样。</p>
<p>并不是所有的渲染器都会把纯色当作一种纹理，但在本渲染器中，我推荐这么做。这样意味着纹理类搭建完毕之后，对物体表面颜色的所有的解释都会被放到一个类里面。这会使代码架构变得更加易懂。</p>
<p>当然，把纯色解释为纹理会使得纯色材质会比过去更加耗时，因为有更多需要维护的变量，但不会比过去慢多少。</p>
<p>继续把这个类写在texture.h文件里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">texture</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solid_color</span> :</span> <span class="keyword">public</span> texture &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">solid_color</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">solid_color</span>(color c) : <span class="built_in">color_value</span>(c) &#123;&#125;</span><br><span class="line">        <span class="built_in">solid_color</span>(<span class="keyword">double</span> red, <span class="keyword">double</span> green, <span class="keyword">double</span> blue)</span><br><span class="line">          : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red,green,blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//纯色纹理的uv参数仅仅是个摆设，无论吃到什么样的uv，直接吐颜色值就行，毕竟就一种颜色。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> color_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//纯色纹理的颜色值</span></span><br><span class="line">        color color_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/08/07/%E6%AD%A6%E5%99%A8-%E6%BF%80%E5%85%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/%E6%AD%A6%E5%99%A8-%E6%BF%80%E5%85%89/" class="post-title-link" itemprop="url">武器-连锁激光</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-07T00:00:00+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-08 12:12:24" itemprop="dateModified" datetime="2022-08-08T12:12:24+08:00">2022-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index"><span itemprop="name">unity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/07/%E6%AD%A6%E5%99%A8-%E6%BF%80%E5%85%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/07/%E6%AD%A6%E5%99%A8-%E6%BF%80%E5%85%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一直都想做一个激光武器，地球online里面做有点危险，那还是在unity里面做一个吧，先来康康效果：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E6%BF%80%E5%85%89.gif" alt="激光"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E6%BF%80%E5%85%895.gif" alt="激光5"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E6%BF%80%E5%85%899.gif" alt="激光9"></p>
<p>版本一呢，链接的激光是瞬间生成的，有一些假，第二个做了一些优化，可以看到链接丝滑了很多，第三个做了顶点动画看起来要更有威力了一些，康康怎么实现的吧，也可以取代码自用。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>有几个基本的需求</p>
<ol>
<li>当激光路径碰到敌人，激光会锁住敌人，并产生连锁。</li>
<li>当敌人走出一定范围，链接会断开，重新生成链接。</li>
<li>当有新的敌人进入范围，而且没达到连锁上限，可以再次重新生成链接。</li>
</ol>
<p>另外有几个自己可有可无的需求</p>
<ol>
<li>用点光源照亮被连锁到的敌人</li>
<li>光线是有动感的，不能仅仅只一条线，那太low了</li>
<li>光线打出去是有速度的。</li>
</ol>
<h1 id="基础需求实现"><a href="#基础需求实现" class="headerlink" title="基础需求实现"></a>基础需求实现</h1><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>首先是一些变量，建议跳过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#region 共有变量</span><br><span class="line">//可供调节激光参数相关</span><br><span class="line">public int maxAtkNum = 5;</span><br><span class="line">public int atkLinkRange = 7;</span><br><span class="line">public float maxDistance = 20;</span><br><span class="line">public float pulseSpeed = 0.7f;</span><br><span class="line">public float minWidth = 0.5f;</span><br><span class="line">public float maxWidth = 0.6f;</span><br><span class="line">public float laserSpeed = 8;</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">#region 私有变量</span><br><span class="line">private LineRenderer lineRenderer;</span><br><span class="line"></span><br><span class="line">//控制状态切换</span><br><span class="line">private Ray ray;</span><br><span class="line">private RaycastHit hit;</span><br><span class="line">private bool isAtking = false;</span><br><span class="line"></span><br><span class="line">//转折点相关</span><br><span class="line">private GameObject[] lights;</span><br><span class="line">private Collider[] colliders;</span><br><span class="line">private HashSet&lt;Collider&gt; enemyIsAtking = new HashSet&lt;Collider&gt;();</span><br><span class="line">private int pointSize = 1;</span><br><span class="line">private Vector3[] tempPoints;</span><br><span class="line">private Vector3 lastPos;</span><br><span class="line">private float startTime;</span><br><span class="line">private int curPointSize = 2;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>我们可以想到使用射线来检测我们的激光是否碰到了第一个敌人，这很重要，因为当激光是否连锁敌人对line组件的选点完全不同，所以，我们需要一个保存一个RaycastHit来判断状态，只有打到第一个敌人才开始连锁。击中敌人之后该怎么做呢？我将它分为四个状态，分别是NotAtking、Atking、NotAtk2Atking、Atk2NotAtking，控制四个状态进行转换的变量为前面我们保存的RaycastHit和一个表示是否开启攻击状态的bool值。先来看update代码吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        //让控件依附在父物体身上</span><br><span class="line">        transform.localPosition = Vector3.zero;</span><br><span class="line">        transform.localRotation = Quaternion.identity;</span><br><span class="line"></span><br><span class="line">        //控制射线检测方向</span><br><span class="line">        ray.origin = transform.position;</span><br><span class="line">        ray.direction = transform.forward;</span><br><span class="line">        Physics.Raycast(ray, out hit, maxDistance);</span><br><span class="line"></span><br><span class="line">        //控制四种状态的切换</span><br><span class="line">        if (!isAtking &amp;&amp; hit.transform)</span><br><span class="line">        &#123;</span><br><span class="line">            NotAkt2Atking();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (isAtking &amp;&amp; !hit.transform)</span><br><span class="line">        &#123;</span><br><span class="line">            Atk2NoAkting();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isAtking &amp;&amp; hit.transform)</span><br><span class="line">        &#123;</span><br><span class="line">            Atking();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            NotAtking();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>C++ Primer告诉我们最好先实现宏观调用，再去写细节方法，这里通过射线检测返回的hit和bool值在四种状态进行切换，有人可能会问：你这个怎么怎么不传参数啊，当然可以，但我想在这里尽量不在Atking和NotAtking中使用参数传递来调用函数，因为这个函数在update中调用频率非常之高，倒不如全部使用成员变量，这点空间换取的时间是相当值得的。</p>
<h4 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h4><p>当然我们接下来要去实现这四种状态，从最简单的开始吧，notAtking（）函数，它只需要绘制一条慢慢变长的直线就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void NotAtking()</span><br><span class="line">&#123;</span><br><span class="line">    //用插值取得终点位置。</span><br><span class="line">    Vector3 endPos = Vector3.Lerp(lastPos, transform.position + transform.forward * maxDistance, 							(Time.time - startTime) * laserSpeed);</span><br><span class="line">    lineRenderer.SetPositions(new Vector3[]</span><br><span class="line">    &#123;</span><br><span class="line">        transform.position,</span><br><span class="line">        endPos</span><br><span class="line">    &#125;);</span><br><span class="line">    //之后会提到</span><br><span class="line">    curPointSize = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没什么好说的，非常简单，第二个自然就是NotAtk2Atking（），这里需要弄清楚链接逻辑，这个切换函数所要做的就是把一切数据都准备好，它主要是为Atking（）函数做准备，先看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//这里的形参后面会提到</span><br><span class="line">void NotAkt2Atking()</span><br><span class="line">    &#123;</span><br><span class="line">    	//还记得控制状态的切换的两个关键吗？这是其中之一，这里新建局部对象用来作为循环条件</span><br><span class="line">        Collider col = hit.collider;</span><br><span class="line">        </span><br><span class="line">        //用来收集范围检测到的敌人</span><br><span class="line">        Collider[] tempCol;</span><br><span class="line">        </span><br><span class="line">        //循环寻找下一个单位</span><br><span class="line">        while (col &amp;&amp; pointSize &lt;= maxAtkNum)</span><br><span class="line">        &#123;</span><br><span class="line">        	//加入hashset中</span><br><span class="line">            enemyIsAtkingSet.Add(col);</span><br><span class="line">            colliders[pointSize - 1] = col;</span><br><span class="line">            </span><br><span class="line">            //范围检测，这里检测层级可以自己定义</span><br><span class="line">            tempCol = Physics.OverlapSphere(col.transform.position, atkLinkRange,</span><br><span class="line">            			1 &lt;&lt; LayerMask.NameToLayer(&quot;Corpse&quot;));</span><br><span class="line">            </span><br><span class="line">            if (tempCol.Length == 0) col = null;</span><br><span class="line">            //依次遍历数组，若没有在hashSet中，就可以继续循环</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                col = null;</span><br><span class="line">                foreach (Collider collider in tempCol)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!enemyIsAtking.Contains(collider))</span><br><span class="line">                    &#123;</span><br><span class="line">                        col = collider;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //用于记录总共需要多少个点，默认值为1个，每多一个敌人就增加一个</span><br><span class="line">            pointSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    	//设置状态准备进入Atking（）函数</span><br><span class="line">        isAtking = true;</span><br><span class="line">    	//此变量是为了控制激光进行位移</span><br><span class="line">        startTime = Time.time;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中使用一个Colloder类型的col作为循环条件，依次寻找到所有单位，当然还可以设置一个上限值，其中范围检测因为仍然会找到已经被链接的单位，所以这里选择使用hashSet来将它们排除。剩下一个变量curPointSize，它为当前已链接点数量，在Atking中就可以明白它的作用。Atking太长了，先看第一部分吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void Atking()</span><br><span class="line">    &#123;</span><br><span class="line">    	//为Atking2NotAtk做准备，我不希望看到断开之后是重新从自身位置慢慢出来，而是从敌人这个位置继续向前</span><br><span class="line">        lastPos = hit.point;</span><br><span class="line">    	</span><br><span class="line">    	//这里需要判断的是当敌人之间距离过大，我们需要重新进行状态的转换</span><br><span class="line">        for (int i = 1; i &lt; pointSize - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((colliders[i].transform.position - </span><br><span class="line">                 colliders[i - 1].transform.position).magnitude &gt; atkLinkRange * 1.2f)</span><br><span class="line">            &#123;</span><br><span class="line">                //为了让画面更连贯，我们直接跳过NotAtk阶段</span><br><span class="line">                Atk2NoAkting();</span><br><span class="line">                curPointSize = i + 1;</span><br><span class="line">                NotAkt2Atking();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	//防止有敌人挡在了第一个敌人和自身之间</span><br><span class="line">        if(hit.collider != colliders[0])</span><br><span class="line">        &#123;</span><br><span class="line">            Atk2NoAkting();</span><br><span class="line">            curPointSize = 2;</span><br><span class="line">            NotAkt2Atking();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>curPointSize = i + 1;</code>该参数的意义是下一次进入Atking函数时，从哪个点开始渐进光线，总不能状态一变就从头开始吧。后面的逻辑就是激光的渐进逻辑，具体分为两个不同的状态，一个是渐进状态，一个是光线已经全部链接完毕状态，具体看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">void Atking()</span><br><span class="line">    &#123;</span><br><span class="line">    	......</span><br><span class="line">		</span><br><span class="line">		//渐进状态</span><br><span class="line">        if(curPointSize &lt; pointSize)</span><br><span class="line">        &#123;</span><br><span class="line">        	//创建临时数组，该数组之后直接传到lineRenderer组件中</span><br><span class="line">            tempPoints = new Vector3[curPointSize + 1];</span><br><span class="line">			</span><br><span class="line">			//第一个点是自身，中间点为已经链接到的敌人位置，最后一个点是从倒数第二个敌人向最后敌人渐进</span><br><span class="line">			tempPoints[0] = transform.position;</span><br><span class="line">            for (int j = 1; j &lt; curPointSize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tempPoints[j] = colliders[j - 1].transform.position;</span><br><span class="line">            &#125;</span><br><span class="line">            tempPoints[curPointSize] = Vector3.Lerp(tempPoints[curPointSize - 1], </span><br><span class="line">            colliders[curPointSize - 1].transform.position, (Time.time - startTime) * laserSpeed);</span><br><span class="line">			</span><br><span class="line">			//设置点数量并传入数组</span><br><span class="line">            lineRenderer.positionCount = curPointSize + 1;</span><br><span class="line">            lineRenderer.SetPositions(tempPoints);</span><br><span class="line"></span><br><span class="line">			//当渐进点和渐进位置差的不多就可以认为已经到达</span><br><span class="line">            if (Vector3.Distance(colliders[curPointSize - 1].transform.position, </span><br><span class="line">            	tempPoints[curPointSize]) &lt; 0.2f)</span><br><span class="line">            &#123;</span><br><span class="line">                ++curPointSize;</span><br><span class="line">                startTime = Time.time;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //别忘了使激光看起来更有威力的灯光效果，将它们点亮并移动位置</span><br><span class="line">            for (int i = 0; i &lt; curPointSize - 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lights[i].SetActive(true);</span><br><span class="line">                lights[i].transform.position = tempPoints[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //链接完毕状态</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">        	//老五样了，最后一个点不需要渐进了。</span><br><span class="line">            tempPoints = new Vector3[pointSize];</span><br><span class="line">            tempPoints[0] = transform.position;</span><br><span class="line">            for (int i = 1; i &lt; pointSize; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                tempPoints[i] = colliders[i - 1].transform.position;</span><br><span class="line">            &#125;</span><br><span class="line">			lineRenderer.positionCount = curPointSize;</span><br><span class="line">            lineRenderer.SetPositions(tempPoints);</span><br><span class="line">			</span><br><span class="line">            //开灯，比上面多一盏</span><br><span class="line">            for (int i = 0; i &lt; pointSize - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lights[i].SetActive(true);</span><br><span class="line">                lights[i].transform.position = tempPoints[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //还需要在最后一个位置继续判断有没有新加进来的敌人</span><br><span class="line">            Collider[] tempCol = Physics.OverlapSphere(tempPoints[pointSize - 1], </span><br><span class="line">            					atkLinkRange * 0.8f, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Corpse&quot;));</span><br><span class="line">			//同样的逻辑</span><br><span class="line">            foreach (Collider collider in tempCol)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!enemyIsAtking.Contains(collider))</span><br><span class="line">                &#123;</span><br><span class="line">                    Atk2NoAkting();</span><br><span class="line">                    NotAkt2Atking(); </span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要提到之前NotAtking中的<code>CurPointSize = 2</code>了，因为我们中Atking中的转换为了画面流畅都跳过了NotAtking这一步，所以需要补上，不然就会出现下次Atking时很多多余的奇怪激光。</p>
<p>其他看起来没有什么困难吧，但其实这里各种各样的边界条件，数组下标的选取让你各种越界，还好都是小问题，最麻烦的Atking结束，那有请最后的状态切换函数登场：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Atk2NoAkting()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; maxAtkNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lights[i].SetActive(false);</span><br><span class="line">        &#125;</span><br><span class="line">        pointSize = 1;</span><br><span class="line">        enemyIsAtking.Clear();</span><br><span class="line">        isAtking = false;</span><br><span class="line">        lineRenderer.positionCount = 2;</span><br><span class="line">        Array.Clear(colliders, 0, colliders.Length);</span><br><span class="line">        Array.Clear(tempPoints, 0, curPointSize.Length);</span><br><span class="line">        startTime = Time.time;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非常朴实，这里都是处理我们Atking留下来的烂摊子，把它们收拾好之后，准备下次的Atking或者是NotAtking函数。</p>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><p>还有一些初始化相关，基本搞定！</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> Awake()</span><br><span class="line">&#123;</span><br><span class="line">    lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">// <span class="keyword">Start</span> <span class="keyword">is</span> <span class="keyword">called</span> <span class="keyword">before</span> the first frame <span class="keyword">update</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">Start</span>()</span><br><span class="line">&#123;</span><br><span class="line">    //把各种各样的东西先初始化一下</span><br><span class="line">    lastPos = <span class="keyword">transform</span>.position;</span><br><span class="line">    colliders = <span class="built_in">new</span> Collider[maxAtkNum];</span><br><span class="line"></span><br><span class="line">    //点光源池</span><br><span class="line">    lights = <span class="built_in">new</span> GameObject[maxAtkNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxAtkNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lights[i] = GameObject.Instantiate(Resources.<span class="keyword">Load</span>&lt;GameObject&gt;(&quot;redPoint&quot;), <span class="keyword">transform</span>.position, Quaternion.<span class="keyword">identity</span>);</span><br><span class="line">        lights[i].SetActive(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动感光波"><a href="#动感光波" class="headerlink" title="动感光波"></a>动感光波</h4><p>仅仅就这？现在我们只能得到一个非常难看的线，这可太逊了，必须来一个材质美化一下，来康康shader代码吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line">Shader &quot;Particles/Additive&quot; &#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_TintColor(&quot;Tint Color&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_MainTex(&quot;Particle Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_InvFade(&quot;Soft Particles Factor&quot;, Range(0.01,3.0)) = 1.0</span><br><span class="line">		_ColorGloss(&quot;Gloss&quot;, Float) = 10</span><br><span class="line">		//颜色渐变</span><br><span class="line">		_ColorSpeed(&quot;Color Speed&quot;, Range(0.01, 10)) = 1</span><br><span class="line">		//顶点动画</span><br><span class="line">		_Magnitude(&quot;Distortion Magnitude&quot;, Float) = 1</span><br><span class="line">		_Frequency(&quot;Distortion Frequency&quot;, Float) = 1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Category&#123;</span><br><span class="line">		//分别为开启透明通道，开启渲染类别，以及禁用批处理</span><br><span class="line">		Tags &#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;RenderType&quot; = &quot;Transparent&quot; &quot;DisableBatching&quot; = &quot;True&quot;&#125;</span><br><span class="line">		//颜色混合，会和组件上的颜色进行混合处理</span><br><span class="line">		Blend SrcAlpha One</span><br><span class="line"></span><br><span class="line">		SubShader &#123;</span><br><span class="line">			Pass &#123;</span><br><span class="line"></span><br><span class="line">				CGPROGRAM</span><br><span class="line">				#pragma vertex vert</span><br><span class="line">				#pragma fragment frag</span><br><span class="line">				#pragma multi_compile_particles</span><br><span class="line">				#pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">				#include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">				sampler2D _MainTex;</span><br><span class="line">				fixed4 _TintColor;</span><br><span class="line">				float _ColorSpeed;</span><br><span class="line">				float4 _MainTex_ST;</span><br><span class="line">				float _ColorGloss;</span><br><span class="line">				//顶点动画</span><br><span class="line">				float _Magnitude;</span><br><span class="line">				float _Frequency;</span><br><span class="line"></span><br><span class="line">				struct appdata_t &#123;</span><br><span class="line">					float4 vertex : POSITION;</span><br><span class="line">					fixed4 color : COLOR;</span><br><span class="line">					float2 texcoord : TEXCOORD0;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				struct v2f &#123;</span><br><span class="line">					float4 vertex : SV_POSITION;</span><br><span class="line">					fixed4 color : COLOR;</span><br><span class="line">					float4 texcoord : TEXCOORD0;</span><br><span class="line">					UNITY_FOG_COORDS(1)</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				//取随机数函数，shader中没有直接可用的函数，返回-1到1（不包含边界）的随机数</span><br><span class="line">				float InterleavedGradientNoise(float2 pos)</span><br><span class="line">				&#123;</span><br><span class="line">					float3 magic = float3(12.9898, 78.233, 43758.5453123);</span><br><span class="line">					return frac(magic.z * frac(dot(pos, magic.xy)));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				v2f vert(appdata_t v)</span><br><span class="line">				&#123;</span><br><span class="line">                    float halfPi = 1.57079632675f;</span><br><span class="line">					v2f o;</span><br><span class="line">                    //随机偏移值</span><br><span class="line">					float4 offset = float4(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">                    //调用该随机函数，传入的参数也很重要，我选择使用顶点位置当作参数</span><br><span class="line">                    //后面用sin调控光线越远抖的越厉害，Magnitude调控整体幅度</span><br><span class="line">					offset.xyz = _Magnitude * InterleavedGradientNoise(float2(v.vertex.x, v.vertex.y)) *</span><br><span class="line">                        				sin(v.texcoord.x * halfPi);</span><br><span class="line">					o.vertex = UnityObjectToClipPos(v.vertex + offset);</span><br><span class="line">					o.color = v.color;</span><br><span class="line">                    //用zw保存uv，并加上一个时间函数，让uv动起来！</span><br><span class="line">					o.texcoord.zw = TRANSFORM_TEX(v.texcoord,_MainTex) + </span><br><span class="line">                        				(1 - frac(float2(_ColorSpeed, 0.0) * _Time.y));</span><br><span class="line">					o.texcoord.xy = v.texcoord.xy</span><br><span class="line">                    //用UnityCG.cginc头文件中内置定义的宏处理雾效，从顶点着色器中输出雾效数据  </span><br><span class="line">					UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">					return o;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				sampler2D_float _CameraDepthTexture;</span><br><span class="line">				float _InvFade;</span><br><span class="line"></span><br><span class="line">				fixed4 frag(v2f i) : SV_Target</span><br><span class="line">				&#123;</span><br><span class="line">					//控制光线内部的白色，Gloass调节大小</span><br><span class="line">					fixed ratio = pow(sin(i.texcoord.y * pi), _ColorGloss);</span><br><span class="line">                    //将纹理与主颜色（我这里就用白色）混合</span><br><span class="line">					fixed4 col = tex2D(_MainTex, i.texcoord.zw) * (1 - ratio) + _TintColor * ratio;</span><br><span class="line">                    //用UnityCG.cginc头文件中内置定义的宏启用雾效 </span><br><span class="line">					UNITY_APPLY_FOG_COLOR(i.fogCoord, col, fixed4(0,0,0,0)); </span><br><span class="line">					return col;</span><br><span class="line">				&#125;</span><br><span class="line">				ENDCG</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h4><p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ew1lCZNnSHyS4A4UC1PAYg?pwd=naqo">https://pan.baidu.com/s/1ew1lCZNnSHyS4A4UC1PAYg?pwd=naqo</a><br>        提取码：naqo </p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013412391/article/details/120618727?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-120618727-blog-121413434.pc_relevant_multi_platform_featuressortv2removedup&spm=1001.2101.3001.4242.2&utm_relevant_index=4">实验通过使命召唤所使用的 Interleaved Gradient Noise 在Shader中生成随机噪声</a></p>
<p><a href="">shader入门精要第11章让画面动起来</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2058427">Unity Shader 一 激光特效Shader[通俗易懂]</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bboyxu/article/details/88897214#comments_9431743">Shader smoothstep实现线条渐变色</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/07/18/%E5%85%89%E8%BF%BD2.4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/%E5%85%89%E8%BF%BD2.4/" class="post-title-link" itemprop="url">包围盒（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-18T00:00:00+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-09 09:39:09" itemprop="dateModified" datetime="2022-08-09T09:39:09+08:00">2022-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/18/%E5%85%89%E8%BF%BD2.4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/18/%E5%85%89%E8%BF%BD2.4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="物体列表的AABB"><a href="#物体列表的AABB" class="headerlink" title="物体列表的AABB"></a>物体列表的AABB</h4><p>上一章中基本讲完了各个类的aabb写法，还剩最后一个，物体列表类的aabb生成，下面给出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;aabb.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//包围盒生成函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果物体列表为空，我们无法为空物体生成包围盒，直接返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="comment">//设定一个flag用来初始化一个包围盒。</span></span><br><span class="line">    <span class="keyword">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//遍历列表内物体。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="comment">//如果遍历刀列表内有物体无法建立包围盒（返回fasle），那对不起，物体列表也无能为力了，直接返回。</span></span><br><span class="line">        <span class="comment">//注意，这个if中的bounding_box函数把这个子物体的包围盒赋给了temp_box。</span></span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(time0, time1, temp_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果是第一次建立包围盒，那直接使用temp_box。</span></span><br><span class="line">        <span class="comment">//否则要求本循环子物体的aabb和之前包围盒的包围盒，使用surrounding_box函数。</span></span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        <span class="comment">//在首次建立包围盒成功之后，把first_box置false。</span></span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    物体列表的aabb的求法就是逐个子物体遍历，求它们这些物体共同的包围盒。其中使用到了上一章中提到的计算两个包围盒的包围盒的函数surrounding_box。</p>
<p>自此，我们已有的物体类：球类、移动的球类和物体列表类都接入了生成包围盒的函数。</p>
<h4 id="BVH类"><a href="#BVH类" class="headerlink" title="BVH类"></a>BVH类</h4><p>是时候把这一切组织起来了，记得上一章中提到的对象划分已经对象划分下的树状结构吗？我们还没有给它起名字呢：我们将创建一个树状结构，树的每一个节点都是一个包围盒或者一个物体，包围盒一层层的嵌套，物体作为叶子节点被一层一层的包裹着，这种结构叫<strong>层次包围盒</strong>（Bounding Volume Hierarchies），或称<strong>BVH</strong>。</p>
<p>BVH既然是一棵树，我们首先得创建它的节点，和其他所有树结构一样，它的节点得储存孩子信息。如果我们把事情再想得简单一点，每个大包围盒内部包着两个子包围盒，那BVH结构就变成了一个二叉树，看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个节点类是物体类的子类，我们还是得依靠多态的便利性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bvh_node</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">bvh_node</span>();</span><br><span class="line">        <span class="comment">//这是传入物体列表的构造，直接调用下面的有vector的构造。</span></span><br><span class="line">        <span class="built_in">bvh_node</span>(<span class="keyword">const</span> hittable_list&amp; list, <span class="keyword">double</span> time0, <span class="keyword">double</span> time1)</span><br><span class="line">            : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//这个构造函数非常复杂，之后再说。</span></span><br><span class="line">        <span class="built_in">bvh_node</span>(</span><br><span class="line">            <span class="keyword">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">            <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end, <span class="keyword">double</span> time0, <span class="keyword">double</span> time1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//override hit函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成包围盒的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//本节点的左右子节点指针，它们都是物体类型的指针。</span></span><br><span class="line">        shared_ptr&lt;hittable&gt; left;</span><br><span class="line">        shared_ptr&lt;hittable&gt; right;</span><br><span class="line">        <span class="comment">//本节点的包围盒，会在构造函数里生成。</span></span><br><span class="line">        aabb box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，bvh节点类的包围盒我们会在构造函数里生成，这里直接赋值即可。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bvh_node::bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​    来看一下hit函数，在这里你会看到包围盒是如何减少计算的——你连我的盒子都碰不到，那我们就没有继续看下去的必要了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bvh_node::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你连我的盒子都碰不到，那我们就没有继续看下去的必要了。</span></span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续遍历左右物体。</span></span><br><span class="line">    <span class="keyword">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//见下方讲解。</span></span><br><span class="line">    <span class="keyword">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, t_min, hit_left ? rec.t : t_max, rec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历过程中只要不是所有的子物体都没碰到，就算产生了碰撞。</span></span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注意上面的代码中有一个剪枝操作，在第十行中，遍历右子树节点的时候先检查了左子树返回值是否为true，即光线有无和左子树碰撞，如果有，那么在判断右子树的时候就又有一个参照物了：“右子树上的物体是否是先被光线碰到的？或者它被左子树上的物体遮挡了？改变t的范围，只在右子树物体离光源更近的情况下，才认可这次碰撞，其他的直接剪掉。”</p>
<p>我们现在来理一下思路，我们写这样的hit函数会发生什么，假设一个bvh在场景中构造完毕（虽然我们暂时没有给出用来构造bvh的构造函数），即，现在main函数中那个world物体不再是一个物体列表，换做是一个已经构建好的bvh，现在有一根光线自相机或者某处发射过来：</p>
<p>既然有光线，我们就得调用场景中所有物体的hit，现在只有一个物体那就是bvh，我们只需要调用它的hit即可。如果这根光线没有碰到最外层的盒子，那上述代码中的第四行<code>return false</code>就是整个碰撞检测的最后一句代码，在这之前我们只调用了一个aabb的hit函数，无论场景中有多少物体，也只需要调用这一个函数即可。再想想如果我们没有bvh，而是使用物体列表来管理场景中的物体，那我们会做哪些工作——如果t的范围不考虑进去的话，即便这根光线没有碰到任何一个物体，我们也需要调用每个物体的hit函数，其中就包括一些球，每个球意味着要求一次一元二次方程的求根公式。</p>
<p>要知道，场景是无限大的，物体只占了场景中微不足道的某个角落，我们创建的大部分光线实际上都是没有和物体发生碰撞的光线，光考虑这部分光线，bvh就比传统的物体列表要快上几个数量级了。</p>
<h4 id="构造BVH"><a href="#构造BVH" class="headerlink" title="构造BVH"></a>构造BVH</h4><p>到此为止，核心问题还没有解决，如何构造一棵bvh树呢？</p>
<p>先来讲一讲上一课的遗留问题，对象划分的依据是什么？首先，必须要明确一个概念：我们现在不需要任何规律的把bvh里的所有物体粗暴的分成两堆，代码也能很好的工作，即便包围盒内部的包围盒比外面的盒子还要大，也不影响代码的运行，充其量只是慢了一点。我们要找的对象划分的依据，是能让程序运行更快，更发挥bvh优势的一种划分方式，它可以是这样一个划分：</p>
<p>先随便找一个轴，x、y或者z轴，把物体列表里的物体按照这个轴从小到大的顺序进行排序并划分成两堆，对于左右子树，用这两堆分别再次进行递归。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">    <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end, <span class="keyword">double</span> time0, <span class="keyword">double</span> time1</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">//创建一个指针指向形参中的物体列表，增加代码可读性。</span></span><br><span class="line">    <span class="keyword">auto</span> objects = src_objects; </span><br><span class="line">    <span class="comment">//随机一个int值，0，1，2分别代表x，y，z轴，这个函数之后会给出。</span></span><br><span class="line">    <span class="keyword">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//通过选定的是哪个坐标轴选到特定的比较器，注意，这个comparator是一个函数指针</span></span><br><span class="line">    <span class="comment">//之后会给出box_x_compare等三个函数的签名即具体函数体。</span></span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                                  : box_z_compare;</span><br><span class="line">    <span class="comment">//本列表中有多少物体？</span></span><br><span class="line">    <span class="keyword">size_t</span> object_span = end - start;</span><br><span class="line">    <span class="comment">//如果发现这个列表中只有一个物体了，那令本节点的左右孩子指针都指向这个物体。</span></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) &#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有俩物体，按照给定轴信息，看看谁在左，谁在右。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start+<span class="number">1</span>])) &#123;</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start+<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = objects[start+<span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果本段物体列表有超过两个物体，直接对其进行排序，并且二分之后，开启下一轮递归。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line">        <span class="comment">//二分找中值。</span></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">        left = make_shared&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = make_shared&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，代码运行到这里，说明本节点的左右孩子递归代码都已经执行完毕。是时候给他们套上包围盒了。</span></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line">    <span class="comment">//给左右节点分别套盒子，并且利用返回信息来判断盒子是否成功生成。</span></span><br><span class="line">    <span class="keyword">if</span> (  !left-&gt;<span class="built_in">bounding_box</span> (time0, time1, box_left)</span><br><span class="line">       || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">    )</span><br><span class="line">        <span class="comment">//进入这个if表示左右孩子的某个盒子没有生成成功。</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//注意，这里有一个bug，如果bouding_box返回false,其box一定是没有被赋值的，即为空。</span></span><br><span class="line">    <span class="comment">//空box调用下面的surrounding_box函数是会出错的，因为访问了空物体。</span></span><br><span class="line">    <span class="comment">//我们暂时没有无法生成包围盒的物体，如：无限大的平面。所以这个问题我们先不要管。</span></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随机范围内的int值的函数如下所示，工具函数都写到rtweekend.h里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">random_int</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回[min,max]范围内int值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">random_double</span>(min, max+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后，我们给出比较器的函数代码，注意把它写在上述构造函数的前面，让编译器可以成功的找到他们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个物体的盒子“大小”的主要函数，第三个参数axis表示比较的是哪个轴。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">box_compare</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b, <span class="keyword">int</span> axis)</span> </span>&#123;</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line">    <span class="comment">//先求两个物体的盒子。</span></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//比较两个盒子的较小的边，谁的给定轴分量越大，谁就越大。</span></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是三个轴比较函数，都是调用上面的比较函数。这三个函数存在的意义是方便构造函数中的函数指针。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">box_x_compare</span> <span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">box_y_compare</span> <span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">box_z_compare</span> <span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试包围盒"><a href="#测试包围盒" class="headerlink" title="测试包围盒*"></a>测试包围盒*</h4><p>现在回到动态模糊那一章的最后一个场景，我们分别使用物体列表和BVH来装载场景物体，并运行光追器，来对比一下两者的耗时，首先，给main函数打个时间戳：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !MULTITHREAD</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//需要引用此头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个函数可以获取当前时间，并转换成某种基于毫秒的整数。</span></span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">GetTickCount64</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main中的全部代码都要被包进来。</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//再次获得当前时间，并且减去main函数开头时记录的时间，便得到了毫秒差。</span></span><br><span class="line">    <span class="keyword">int</span> time = <span class="built_in">GetTickCount64</span>() - start;</span><br><span class="line">    time = time / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">auto</span> minute = time / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">auto</span> second = time % <span class="number">60</span>;</span><br><span class="line">    <span class="comment">//简单转换一下，并输出出去。</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;took &quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;m &quot;</span> &lt;&lt; second &lt;&lt;<span class="string">&quot;s  to complete. \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，用bvh提到程序中的物体列表，在main函数中调用random_scene的地方，直接把物体列表传到bvh_node类的构造函数里，创建一个bvh即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用函数生成一个有着许多随机小球的场景！！！</span></span><br><span class="line"><span class="comment">//auto world = random_scene();</span></span><br><span class="line"><span class="keyword">auto</span> world = <span class="built_in">bvh_node</span>(<span class="built_in">random_scene</span>(),<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>传入构造函数的两个时刻值0和1是和相机的快门打开时间和关闭时间保持一致的。这决定了我们程序中所有的移动的球对象的包围盒都是通过这两个时间值来计算的。对于直线运动的球来说，在两个极端情况下的包围盒的包围盒，即是最终的包围盒。</p>
<p>运行程序，可见命令行中的运行时间（release-x86）：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1651405102043-9a34d32d-2fef-4880-9196-5a97a9d00308.png" alt="img"></p>
<p>对比前者——物体列表作为容器下的运行时间，后者bvh容器下的运行时间快了好几倍。</p>
<h4 id="课后实践"><a href="#课后实践" class="headerlink" title="课后实践"></a>课后实践</h4><ol>
<li><p>在脑海中构建一个少量物体的bvh，按顺序阅读bvh的构造函数，体会物体被二分和生成包围盒的过程。接下来思考hit函数中包围盒是如何和光线求交的，这有助于理解整体架构。</p>
</li>
<li><p>将bvh应用于多线程模式，并生成一个视频，比较使用包围盒前后的序列帧生成时间。</p>
</li>
<li><p>将之前所有的关键类的关系做出一个类图，并梳理他们之间的调用过程。回想一下我们是怎么得到一张图片的。</p>
</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第3.8节到第3.10节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/07/01/%E5%85%89%E8%BF%BD2.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/01/%E5%85%89%E8%BF%BD2.3/" class="post-title-link" itemprop="url">包围盒（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-01T00:00:00+08:00">2022-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-09 09:08:24" itemprop="dateModified" datetime="2022-08-09T09:08:24+08:00">2022-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/01/%E5%85%89%E8%BF%BD2.3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/01/%E5%85%89%E8%BF%BD2.3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们开开心心的讲完了中篇的前两章，渲染出了炫酷的动态模糊效果，它简单而且漂亮。但是，该来的总归还是要来，下面的几章会给大伙儿整些头疼的：包围盒。</p>
<h4 id="光线碰撞中的重复冗余"><a href="#光线碰撞中的重复冗余" class="headerlink" title="光线碰撞中的重复冗余"></a>光线碰撞中的重复冗余</h4><p>现在回顾一下我们发射光线到回收颜色的全过程，我们就会明白，我们的代码有哪些不合理的地方：</p>
<p>相机朝虚拟视口中的像素格子发出光线，这跟光线会尝试调用场景中所有物体（本项目中一个名为world的物体列表）的hit函数——会按物体<strong>插入物体列表时候的顺序</strong>对物体进行逐一调用它们自己的hit函数。这些子物体要不还是物体列表，或者是球、移动的球之类的实体物体。</p>
<p>我们再来看看球和移动的球是如何处理光线碰撞的，我们通过解一个二元一次方程来判断球是否和光线碰撞，返回碰撞时刻以及碰撞点信息等等（具体见第五章《球》）。这意味着对于每一次射出光线（无论是相机射出的，还是材质表面反射得来的）都要和场景中所有的球进行一次判断。如果场景中有100个物体，意味着，每一次hit之后反射的光线，就要解100个二元一次方程。假设平均每根光线会在场景中弹射5次，对于每一根光线我们要解500个方程，采样数会把这个数字拉到50000（假设每个像素采样100次），而像素数量会把这个数字拉到亿级别（假设我们的场景是400*300），现在看看我们球类代码中的hit函数，那么一大坨，能想象每次在命令行中点击回车，电脑运行了几亿次这部分的代码吗？</p>
<p>不合理的地方在哪里呢？假设我们有一个光线朝西边径直而去，在光线射过去的方向的相反方向有99颗球，这九十九颗球也都逃不过碰撞检测函数。这分莫名其妙的开销应该是可以通过某种方式避免的。</p>
<p>总结一下：<strong>光线-物体交集是光线追踪器中的主要时间瓶颈，时间与物体数量成线性关系。这是对同一模型的重复搜索，有没有什么办法可以使之复杂度降低呢？比如通过某种二分法让其的复杂度降低到对数等级？</strong></p>
<h4 id="空间划分与八叉树"><a href="#空间划分与八叉树" class="headerlink" title="空间划分与八叉树"></a>空间划分与八叉树</h4><p>刚提到了二分法，但二分法必须针对已排序的数据才有作用，也就是说，我们必须让场景中的物体依照某种规则变得有序，才可以使用二分法的思想降低复杂度。</p>
<p>假设我们的物体都集中在以原点为中心的单位立方体里面，很容易可以想到一种划分方式：先通过三个坐标轴把空间划分为八个小立方体。</p>
<p>如果把任意一个数带入t，光线的公式<img src="https://cdn.nlark.com/yuque/__latex/31ae9c334f3c47daac82d08f80c0a96b.svg" alt="img">，最终得到的坐标点的x,y,z都不会大于0，那我们就没有必要检查位于第Ⅰ象限的物体了。如果x,y,z有全大于0的情况，说明光线与第Ⅰ象限有交点，我们就对第一象限中的小立方体继续划分——划分成八个更小的立方体，再检查光线是否与它们有交点，位于和光线无交点的小立方体内的物体，我们就无需检查了。这种思想叫<strong>空间划分</strong>。</p>
<p>整个搜索链条就如同树一样，先看有没有和大立方体有交集，如果有交集就再看其中的小立方体，然后一直往下看，直到我们人为规定的某个大小的立方体内不再有更小的立方体，就直接查看该立方体内的物体即可。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25639626/1646477603061-2d3fc2ee-9316-414c-b911-72b25014180f.png" alt="img"></p>
<p><strong>八叉树</strong>——这种结构有一个浅显易懂的名字。很容易可以写出关于八叉树的伪代码（这个八叉树只有两层，第三层就是物体层）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (光线碰到了某个立方体)</span><br><span class="line">    <span class="keyword">if</span>(光线碰到了子立方体<span class="number">1</span>号)&#123;</span><br><span class="line">        <span class="keyword">if</span>(光线碰到了子立方体<span class="number">1</span>号内的某个物体)&#123;</span><br><span class="line">            处理碰撞信息。</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(光线碰到了子立方体<span class="number">2</span>号)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(光线碰到了子立方体<span class="number">7</span>号)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>我们没有讨论如何判断光线和立方体求交，也没有讨论物体在两个立方体的边界上我们要如何处理，篇幅有限。我们不会在项目中使用八叉树，但是它确实是一个可行的方案，并且很容易被图形工程师们提起。</p>
<p>我们并不准备使用空间划分的八叉树来管理我们场景中的物体，因为还有另一个备选方案可以使用——<strong>对象划分</strong>。这种空间划分比空间划分使用更为广泛。</p>
<h4 id="对象划分简述"><a href="#对象划分简述" class="headerlink" title="对象划分简述"></a>对象划分简述</h4><p>现在假设空间中有15个对象，我们按照某种规律把它们分成俩个部分，如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25639626/1646539589363-daec5150-6cc0-45db-8aad-8222c6717e88.png" alt="img"></p>
<p>至于划分对象的算法我们之后再说。</p>
<p>这是三维空间的某种对象划分在二维上的投影示意图。可见对象划分之后的各个区域是很可能会重叠的，但是也就不再存在一个物体处于区域边界的情况。</p>
<p>当然这里也依然存在一个树状结构。光线先和最外层和紫色部分算交点，如果存在交点才会查看红蓝两个区域的交点情况。</p>
<h4 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h4><p>我们已经决定使用对象划分来加速光线碰撞，这里有很多问题待解决：具体如何划分物体？树状结构如何搭建？新的场景物体又该如何管理（物体列表显然已经不满足要求了）？</p>
<p>这些问题先靠一边，我们先来把目光瞄准到所谓“区域”，也就是包围盒。</p>
<p>包围盒应该是什么样的？我们又如何计算光线与盒子求交呢？</p>
<p>如果不考虑性能，包围盒可以是任何形状，它可以是一个大球，包裹住内部的小球，这样我们只需要算一次一元二次方程就可以得到光线和大球碰撞的结果，如果有碰撞再计算光线和内部小球的碰撞情况。而且我们计算光线和大球求交的时候不需要计算具体反射光线，完全不需要调用材质代码，只需要返回是否碰撞到信息，以便我们去判断需不需要和内部小球进一步计算碰撞即可。</p>
<p>但是光线和球的碰撞计算复杂度还是高了一点，有一种结构最擅长处理和光线求交，这就是轴向立方体。使用轴向立方体作为包围盒的形状，这就是<strong>轴向包围盒（****Axis-Aligned Bounding Boxes</strong> <strong>）</strong>，又叫<strong>AABB</strong>。</p>
<p>轴向立方体就是所有的边都和坐标轴平行的立方体，它和光线求交的计算复杂度低，且易于理解。</p>
<p>先不看Z轴，在平面上的轴向包围盒如下图所示，空间中的包围盒和其原理相同，可以通过推广得到：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25639626/1647064464317-099412bb-3163-4426-a4e4-bb19920e8b88.png" alt="img"></p>
<p>平面上的AABB（2D-AABB）即是四条直线<img src="https://cdn.nlark.com/yuque/__latex/4974822c92d19605bcd18bf7fdf478b0.svg" alt="img">围成的区域。对于这对平行线<img src="https://cdn.nlark.com/yuque/__latex/c36f7ad9930be00ac943fdf62adee947.svg" alt="img">，光线会和它们产生两个交点，当然，另外一对平行线同理：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25639626/1647064714114-9991e2f8-794b-473b-bd89-ad8480fc8c0e.png" alt="img"></p>
<p>看看光线传播到<img src="https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg" alt="img">分量为<img src="https://cdn.nlark.com/yuque/__latex/48d05334b5b0710d63edb6b4b3ac631c.svg" alt="img">和<img src="https://cdn.nlark.com/yuque/__latex/0e8831d88c93179dbe6c8b5e3678ca20.svg" alt="img">时，时间<img src="https://cdn.nlark.com/yuque/__latex/120ecc98af8b35809bffc3741ac52f86.svg" alt="img">和<img src="https://cdn.nlark.com/yuque/__latex/120ecc98af8b35809bffc3741ac52f86.svg" alt="img">是多少，只要把光线原点位置坐标向量A的x分量和方向向量b的x分量带入公式<img src="https://cdn.nlark.com/yuque/__latex/8f8c605714efea092050d60d61b9ce49.svg" alt="img">即可：</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/626aeee8e7ac4fa7933d7400f02ead03.svg" alt="img">和<img src="https://cdn.nlark.com/yuque/__latex/8b5d8216af9ea05bfc8c35fb3e54f441.svg" alt="img"></p>
<p>同理，在y轴上你同样可以得到两个时间：</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/bce9659878ed8e8581ba4708410d8fec.svg" alt="img">和<img src="https://cdn.nlark.com/yuque/__latex/02d0d3620f1610730048fed887bc6b18.svg" alt="img"></p>
<p>好，有了这四个时间值，我们如何判断这根光线有没有和2D-AABB相交呢？看下图： </p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25639626/1647270555009-073512e0-d9cc-4f73-b5d1-bc1f2b43372b.png" alt="img"></p>
<p>对于上图中上方的光线，其(t0,t1)和(t2,t3)两个时间区域并无交集，在图中的表现即是蓝色和绿色的线段并无重合处，那就可以断言，这根光线和盒子并无交集。而下面的光线可见明显蓝绿重合，它一定是一根穿过盒子的光线。</p>
<p>很容易就能把这个原理推广到三维的情形下：</p>
<p><strong>3D-AABB由三对面组成，假设光线传播到与XoY面平行的那一对面上的时间是t0,t1，传播到YoZ面上的时间t2,t3，ZoX则是t4,t5。则一定有：光线和盒子相交 &lt;==&gt; (t0,t1)、(t2,t3)和(t4,t5)两两有交集。</strong></p>
<p>伪码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compute</span> (tx0, tx1)</span><br><span class="line"><span class="built_in">compute</span> (ty0, ty1)</span><br><span class="line"><span class="built_in">compute</span> (tz0, tz1)</span><br><span class="line"><span class="comment">//返回这三个时间段有无重叠</span></span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1))</span><br></pre></td></tr></table></figure>

<p>对于坐标轴上的两个区间(a,b)和(c,d)，判断区间有无重叠，只需要取a和c较大的那一个和b与d中较小的那一个比较，如果前者小于后者，说明有重叠，这部分的伪码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">overlap</span><span class="params">(a, b, c, d)</span></span></span><br><span class="line"><span class="function">    f </span>= <span class="built_in">max</span>(a, c)</span><br><span class="line">    F = <span class="built_in">min</span>(b, d)</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (f &lt; F)</span><br></pre></td></tr></table></figure>

<p>铺垫完成，接下来我们来从代码层面构造AABB。</p>
<h4 id="编写AABB类"><a href="#编写AABB类" class="headerlink" title="编写AABB类"></a>编写AABB类</h4><p>创建aabb.h文件，敲入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aabb</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">aabb</span>() &#123;&#125;</span><br><span class="line">        <span class="comment">// 如何唯一确定一个3D-AABB？只需要两个点即可！</span></span><br><span class="line">        <span class="built_in">aabb</span>(<span class="keyword">const</span> point3&amp; a, <span class="keyword">const</span> point3&amp; b) &#123; minimum = a; maximum = b;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回三个分量都较小的那一个点。</span></span><br><span class="line">        <span class="function">point3 <span class="title">min</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> minimum; &#125;</span><br><span class="line">        <span class="comment">//返回minimum点在盒子上的对角点，即三个分量都较大的那个点。</span></span><br><span class="line">        <span class="function">point3 <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> maximum; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//光线和AABB求交代码，注意这个hit和物体类的hit没有一毛钱关系。</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">//for循环判断三个轴向的三对面和光线碰撞的时间。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++) &#123;</span><br><span class="line">                <span class="comment">//见解析。</span></span><br><span class="line">                <span class="keyword">auto</span> t0 = <span class="built_in">fmin</span>((minimum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                               (maximum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                <span class="keyword">auto</span> t1 = <span class="built_in">fmax</span>((minimum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                               (maximum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                t_min = <span class="built_in">fmax</span>(t0, t_min);</span><br><span class="line">                t_max = <span class="built_in">fmin</span>(t1, t_max);</span><br><span class="line">                <span class="keyword">if</span> (t_max &lt;= t_min)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        point3 minimum;</span><br><span class="line">        point3 maximum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​    我们使用两个point3来唯一确定一个3D-AABB，就如同我们可以在平面直角坐标系上用左下角和右上角两个点确定一个2D-AABB一样。</p>
<p>我们来看看hit函数里的for循环中做了什么？</p>
<p>首先，我们把minmum和maximum点的<img src="https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg" alt="img">分量都带入了公式<img src="https://cdn.nlark.com/yuque/__latex/8f8c605714efea092050d60d61b9ce49.svg" alt="img">来计算光线穿过这一对面的时间值<img src="https://cdn.nlark.com/yuque/__latex/120ecc98af8b35809bffc3741ac52f86.svg" alt="img">和<img src="https://cdn.nlark.com/yuque/__latex/a67f549adc92ae7ed58082ebbbc38d50.svg" alt="img">，注意，这里的fmin和fmax函数是为了确保<img src="https://cdn.nlark.com/yuque/__latex/120ecc98af8b35809bffc3741ac52f86.svg" alt="img">小于<img src="https://cdn.nlark.com/yuque/__latex/a67f549adc92ae7ed58082ebbbc38d50.svg" alt="img">。因为minmum[0]一定是小于maximum[0]的，但是无法确定<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/029bb2c1832b843ce66867ac49f1db71.svg" alt="img">就一定比<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/c8811b213e2cf2356b0395ce5e85f807.svg" alt="img">小，想想光线从x轴无穷大处朝x变小的方向射过来，这时候<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/359c47e9adb148f44b2583aed8513818.svg" alt="img">，我们就需要调换存储<img src="https://cdn.nlark.com/yuque/__latex/120ecc98af8b35809bffc3741ac52f86.svg" alt="img">和<img src="https://cdn.nlark.com/yuque/__latex/a67f549adc92ae7ed58082ebbbc38d50.svg" alt="img">。</p>
<p>紧接着，我们开始对区间求交集。hit函数传进来的t_min和t_max代表我们认可的t的范围，这个与物体类的hit函数的参数中的t_min和t_max是一个道理，用来给我们切去不必要的碰撞（如负值t）的。现在把(<img src="https://cdn.nlark.com/yuque/__latex/120ecc98af8b35809bffc3741ac52f86.svg" alt="img">,<img src="https://cdn.nlark.com/yuque/__latex/a67f549adc92ae7ed58082ebbbc38d50.svg" alt="img">)和(t_min,t_max)求交，得到的值如果是一个不存在的区间，则表示“在您认可的t的区间内，不存在一个t让光线传播到AABB的x轴同向对面中”。</p>
<p>紧接着对y和z轴上的对面做同样的操作，期间一旦发现求交后区间不存在，便可断定“光线在给定的时间区间内不曾跨过指定对面”，对三个对面进行这样的操作之后，求交的结果存在与否则代表了“光线是否在某一时刻同时在三个对面之间，即是否曾射入AABB之中”。</p>
<h4 id="优化hit函数"><a href="#优化hit函数" class="headerlink" title="优化hit函数"></a>优化hit函数</h4><p>我们换一种方式描述hit代码中的逻辑，下面的代码比起原先的hit函数冗长的逻辑显得更为清晰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">aabb::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[a];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[a] - r.<span class="built_in">origin</span>()[a]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[a] - r.<span class="built_in">origin</span>()[a]) * invD;</span><br><span class="line">        <span class="comment">//如果光线的方向向量某个分量为负，则光线一定会逆向穿过本轴上的对面。</span></span><br><span class="line">        <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        t_min = t0 &gt; t_min ? t0 : t_min;</span><br><span class="line">        t_max = t1 &lt; t_max ? t1 : t_max;</span><br><span class="line">        <span class="keyword">if</span> (t_max &lt;= t_min)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给物体绑定包围盒"><a href="#给物体绑定包围盒" class="headerlink" title="给物体绑定包围盒"></a>给物体绑定包围盒</h4><p>AABB类已经被构造出来了，我们现在得把它和物体类联系起来了，因为包围盒子终归是要包裹住物体的。</p>
<p>先来修改底层，给物体类添加一个纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;aabb.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//制造包围盒子的函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看看这个新的函数，首先，它的返回值是bool类型，这是因为我们得给无法被包围盒包裹的物体一个解释，比如一个无限大的平面（以后可能会有），如果返回true，则表示包围盒生成失败。</p>
<p>生成的包围盒通过参数中的引用传递出去 ：<code>aabb&amp; output_box</code>。</p>
<p>至于另外两个参数time0和time1，它对于移动的球类以及后续所有动态的物体都是必要的，因为如果不给定一个时间区间，物体运动的轨迹将会无限长，无法被包围盒包裹。</p>
<p>很容易可以写出球类的包围盒生成函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//override包围盒生成函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是一个球的外切立方体。它是能包裹住球且体积最小的AABB。</span></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        center - <span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + <span class="built_in">vec3</span>(radius, radius, radius));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面是移动的球类的包围盒生成函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;aabb.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moving_sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//override包围盒生成函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> _time0, <span class="keyword">double</span> _time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">moving_sphere::bounding_box</span><span class="params">(<span class="keyword">double</span> _time0, <span class="keyword">double</span> _time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们先生成移动的球在两个极端时间下的包围盒。</span></span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="comment">//然后再求这两个包围盒的包围盒。这个surrounding_box函数会在之后给出。</span></span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面添加两个包围盒的包围盒函数<code>surrounding_box(box0, box1)</code>到aabb.h中，它的本质是通过比较去筛选包围盒中的两个point3的分量，使得minimum的各个分量取两个盒子的minimum分量的较小值，maximum的所有分量都取两个盒子的maximum分量的较大值，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>&#123;</span><br><span class="line">    <span class="function">point3 <span class="title">small</span><span class="params">(fmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">                 fmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">                 fmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">big</span><span class="params">(fmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">               fmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">               fmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small,big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>aabb对于本章开头提到的树状结构来说相当于叶子节点，本章基本完成了叶子节点的构造，但对于整个树状结构的搭建来说，才是刚刚开始。</p>
<h4 id="课后实践"><a href="#课后实践" class="headerlink" title="课后实践"></a>课后实践</h4><p>尝试编写物体列表类的包围盒生成函数（这个函数会在下一章给出）。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第3.1节到第3.7节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/06/13/%E5%85%89%E8%BF%BD2.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/13/%E5%85%89%E8%BF%BD2.2/" class="post-title-link" itemprop="url">动态模糊</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-13T00:00:00+08:00">2022-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-05 09:04:16" itemprop="dateModified" datetime="2022-08-05T09:04:16+08:00">2022-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/13/%E5%85%89%E8%BF%BD2.2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/13/%E5%85%89%E8%BF%BD2.2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态模糊"><a href="#动态模糊" class="headerlink" title="动态模糊"></a>动态模糊</h1><p>“带时间的光线”划开了新旧篇章的界限，新的维度下，新的可能性在孕育。</p>
<p>这一章中就来看看，“时间”会给这个世界带来什么变化。本章我们会创建继“球”之后，第二个实体物体类：“移动的球”。呃，抱歉，它还是球。</p>
<h4 id="匀速运动的球"><a href="#匀速运动的球" class="headerlink" title="匀速运动的球"></a>匀速运动的球</h4><p>创建新文件moving_sphere.h，并敲入如下代码，其实其中大部分代码是从球类中复制过来的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MOVING_SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOVING_SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moving_sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">moving_sphere</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//带参构造，比sphere类要多吃四个参数，分别是两个时间值，以及这两个时间下对应的球心位置。</span></span><br><span class="line">        <span class="built_in">moving_sphere</span>(</span><br><span class="line">            point3 cen0, point3 cen1, <span class="keyword">double</span> _time0, <span class="keyword">double</span> _time1, <span class="keyword">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">            : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(_time0), <span class="built_in">time1</span>(_time1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m)</span><br><span class="line">        &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//多出来的函数，这个函数用来返回当前时间下球心位置。</span></span><br><span class="line">        <span class="function">point3 <span class="title">center</span><span class="params">(<span class="keyword">double</span> time)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//两个时间下的球心位置。</span></span><br><span class="line">        point3 center0, center1;</span><br><span class="line">    	<span class="comment">//两个时间值</span></span><br><span class="line">        <span class="keyword">double</span> time0, time1;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过插值得到球心位置</span></span><br><span class="line"><span class="function">point3 <span class="title">moving_sphere::center</span><span class="params">(<span class="keyword">double</span> time)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0))*(center1 - center0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>center函数的参数time不一定非要处于time0和time1之间，它也可以小于time0或者大于time1。从另一个角度来说，time0,time1和其对应的球心位置center0,center1并不是球运动的边界，而是用于确定球运动方向和速度的参数。</p>
<p>总结来说，<strong>这颗球沿着空间中的某条直线做匀速运动，它在time0时刻处于直线上的center0位置，time1时间下处于center1位置</strong>。</p>
<p>接下来补完moving_sphere类，它还差一个hit函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">moving_sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入光线r的发射时间r.time()到center函数里，移动的球会根据这个值调整球心坐标。</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">//同理，法线的计算中的center也得更换成插值计算版本。</span></span><br><span class="line">    <span class="keyword">auto</span> outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="材质类对应修改"><a href="#材质类对应修改" class="headerlink" title="材质类对应修改"></a>材质类对应修改</h2><p>每次递归都会产生新的光线，得确保时间信息可以传递到新光线上，修改材质类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">//把time信息传递给出射光线。</span></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           ...</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">			...</span><br><span class="line">            <span class="comment">//把time信息传递给出射光线。</span></span><br><span class="line">        	scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz*<span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ...</span></span></span><br><span class="line"><span class="params"><span class="function">        	<span class="comment">//把time信息传递给出射光线。</span></span></span></span><br><span class="line"><span class="params"><span class="function">            scattered = ray(rec.p, direction, r_in.time());</span></span></span><br><span class="line"><span class="params"><span class="function">			...</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="修改初篇最终场景"><a href="#修改初篇最终场景" class="headerlink" title="修改初篇最终场景"></a>修改初篇最终场景</h2><p>我们尝试把初篇最终场景中的所有漫反射小球都替换成移动的球，并且让他们移动的方向都为y轴正方向，为了做出差异性，让所有的小球移动的速度都不同，我们要利用随机数给定不同的参数。</p>
<p>假设相机镜头在 time0=0 时刻打开镜头，time1=1 时刻关闭镜头，且time0时刻这些移动的球正好都在y = 0.2 平面上（这也是我们以前最终场景中的设计），也就是说center0.y() 是 0.2 ，那么center1就可以根据center0加上一个随机长度的y轴正方向向量得到，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;moving_sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">        	...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>() * color::<span class="built_in">random</span>();</span><br><span class="line">                    sphere_material = make_shared&lt;lambertian&gt;(albedo);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// center2表示1.0时刻球心位置。</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>,<span class="number">.5</span>), <span class="number">0</span>);</span><br><span class="line">                    </span><br><span class="line">                 	<span class="comment">// 创建moving_sphere时，比sphere多传入四个参数。</span></span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;moving_sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                 	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再修改相机和图片参数，为了不等待太久，适当降低了分辨率</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// change</span></span><br><span class="line">    <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="comment">// ↓↓↓</span></span><br><span class="line">    <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// ↓↓↓</span></span><br><span class="line">    <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//相机传入的两个时间值和刚刚移动的球中的值保持一致，方便同步修改。</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>会得到：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645624221803-0845eb43-30f2-4979-af3f-9a2fbcc47c79.png" alt="img"></p>
<p>虽然这些移动的球的运动轨迹是“直破云霄”往天上去的，但是看起来就好像是球在平台上弹跳一样。这是因为无论是向下运动还是向上运动，动态模糊看上去都是一个样子的。</p>
<p><em>以下内容为个人探索（需要先完成初篇第十六章）。</em></p>
<h2 id="配置ffmpeg"><a href="#配置ffmpeg" class="headerlink" title="配置ffmpeg*"></a>配置ffmpeg*</h2><p>现在来休息一下，暂停对技术的探索，一起来做一些工程方向的趣事。让我们来生成一系列的图片，并且把它串成视频。你不想看到自己的小球真的动起来吗？如果答案为肯定，那就来继续探索时空光线追踪的极限吧。</p>
<p>图片按序列帧转视频这件差事如果要靠代码完成可得费一番功夫，幸好伟大的前辈们早就写好了统一解决方案——ffmpeg！一个伟大的开源程序！它可以用来记录、转换数字音频、视频，并能将其转化为流，总之，它在音视频方面几乎无所不精无所不能。</p>
<p>但本篇并不是ffmpeg的教程贴，而且为了整体项目的精简，把ffmpeg接入光追项目暂时来看是没有必要。我们仅仅只利用ffmpeg作为外部工具生成视频，或者更准确来说，仅仅只用到一个命令。</p>
<p>一：先需要下载ffmpeg，直接点击该链接进行下载：<a target="_blank" rel="noopener" href="https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z%E3%80%82">https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z。</a></p>
<pre><code> （授人以鱼不如授人以渔，以防上方链接失效，我再教你如何得到本下载链接：
</code></pre>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li>先上官网：<a target="_blank" rel="noopener" href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></li>
<li>因为我是windows系统，就按下图所示进入链接（其他系统下的ffmpeg安装远比windows下安装简单，具体请自行搜索）：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645675175268-5f43f54c-c63d-485c-a244-f818a3609980.png" alt="img"></p>
<p>进入之后，第一行就是最新的git分支的压缩包，俩个分别是只包含基础功能的以及全部功能的压缩包，随便选一个，因为我还使用ffmpeg做其他项目，所以安装的是full版本，但是应对本项目，essential应该就足够了。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645675230186-6e1197a5-b134-4811-b51f-55b241bcf4cf.png" alt="img"></p>
<p>你会下载到和刚刚我给你的链接里一样的安装包。</p>
<p>二：把下载的压缩包解压到某个目录，笔者将其解压到了D:\ffmpeg文件夹下。</p>
<p>三：配置环境变量。我的电脑右键属性-高级系统设置-环境变量-再编辑path-新建一个path为ffmpeg目录下的bin文件夹。（本部分我简单描述，环境变量配置为程序员必修课，如果不会的话去看教程，这里贴一个百度经验教程<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/a17d5285c9b0c48099c8f26a.html%EF%BC%89%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E4%BD%A0%E7%9A%84path%E5%BA%94%E8%AF%A5%E4%BC%9A%E5%A4%A7%E6%A6%82%E5%A6%82%E4%B8%8B%E5%A4%9A%E5%87%BA%E4%B8%80%E8%A1%8C%EF%BC%9A">https://jingyan.baidu.com/article/a17d5285c9b0c48099c8f26a.html），配置完成你的path应该会大概如下多出一行：</a></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645675931404-73c58218-d114-4986-ae81-d68544470348.png" alt="img"></p>
<p>四：配置完毕之后就可以通过命令行测试是否配置成功，在任意目录下输入ffmpeg -version，如果出现版本信息，即表示配置成功：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645676037568-b712f67a-c7ee-4e67-89f6-fef762f22dae.png" alt="img"></p>
<h2 id="多线程输出序列帧"><a href="#多线程输出序列帧" class="headerlink" title="多线程输出序列帧*"></a>多线程输出序列帧*</h2><p>切换代码为多线程模式，修改多线程的main所在文件如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MULTITHREAD</span></span><br><span class="line"><span class="comment">//我们需要用到c语言中的部分内存操作函数，比如sprintf，在C++标准中它们被认为是危险和禁忌的。</span></span><br><span class="line"><span class="comment">//使用这个宏即可解禁这些函数，你亦可将其写入预处理器命令中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;moving_sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整为16/9，和本章中动态模糊示例代码保持一致。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line"><span class="comment">// ↓↓↓，因为要输出多张图片，我们让其尽可能的快。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 让center2尽可能的高，我打算让球高高的飞起！</span></span><br><span class="line">         <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">50</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 时间依然不变，卡在1个单位时间内运行完毕。</span></span><br><span class="line">         world.<span class="built_in">add</span>(make_shared&lt;moving_sphere&gt;(</span><br><span class="line">            center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">        ...       </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 视频一共有多少帧。</span></span><br><span class="line">    <span class="keyword">int</span> video_frame_num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 把这些序列帧存放在指定目录下，方便查看和编辑。</span></span><br><span class="line">    std::string video_folder_path = <span class="string">&quot;video&quot;</span>;</span><br><span class="line"></span><br><span class="line">    world = <span class="built_in">random_scene</span>();</span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C的新建文件夹的多种方式之一，这种通过system命令新建文件夹的方式不需要多余的头文件包含，很方便。</span></span><br><span class="line">    std::string command;</span><br><span class="line">    <span class="comment">// mkdir命令就是命令行中新建文件夹的命令，后跟新文件夹目录</span></span><br><span class="line">    command = <span class="string">&quot;mkdir &quot;</span> + video_folder_path;</span><br><span class="line">    <span class="comment">// 会在当前目录上创建video文件夹。</span></span><br><span class="line">    <span class="comment">// system只接受c风格字符串，所以要用c_str转换一下。</span></span><br><span class="line">    <span class="built_in">system</span>(command.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 具体文件名。</span></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">50</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环创建多帧。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; video_frame_num; i++) &#123;</span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;LineIndex:&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sprintf和c语言中人尽皆知的printf几乎没有什么不同。</span></span><br><span class="line">        <span class="comment">// 唯一的区别是它要把字符串输出给一个char数组而不是标准输出流。</span></span><br><span class="line">        <span class="comment">// 图片名需要规律排列，ffmpeg会从编号为0的图片开始串帧成视频。</span></span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;./%s/videoframe%04d.ppm&quot;</span>, video_folder_path.<span class="built_in">c_str</span>(), i);</span><br><span class="line"></span><br><span class="line">        buf = <span class="keyword">new</span> <span class="built_in">imageoutput</span>(image_width, image_height, filename);</span><br><span class="line">        std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本帧图片的时间区间，随后讲解。</span></span><br><span class="line">        cam = <span class="keyword">new</span> <span class="built_in">camera</span>(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="built_in">pow</span>(i / (<span class="keyword">float</span>)video_frame_num, <span class="number">5</span>), <span class="built_in">pow</span>((i + <span class="number">1</span>) / (<span class="keyword">float</span>)video_frame_num, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numThread; k++) &#123;</span><br><span class="line">            threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(ray_tracing_by_thread, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">            thread.<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (thread_remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining : &quot;</span> &lt;&lt; line_remain - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意初始化这些进程监视相关变量。</span></span><br><span class="line">        line_remain = image_height;</span><br><span class="line">        thread_remain = numThread;</span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">        buf-&gt;<span class="built_in">buffer_2_file</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> cam;</span><br><span class="line">        <span class="keyword">delete</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>移动的球类是一些匀速运动的小球，但这个匀速运动也是有条件的，那就是时间流速是匀速不变的。</p>
<p>我们将均匀增加的自变量i（每次循环加一），套进<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/97e5bb87482db93b9ec3dd2fbc98644f.svg" alt="img">函数，并将其映射到(0,1)区间内（和移动的球在创建之初指定的时间区间保持同步），即可实现球速逐渐加快效果，因为<img src="https://cdn.nlark.com/yuque/__latex/97e5bb87482db93b9ec3dd2fbc98644f.svg" alt="img">在此区间为凹函数。可以简单理解为，套用该函数之后，时间流速不再均匀，而是会逐渐加快。</p>
<p>运行代码，如果你是在命令行中运行exe文件，就可以在exe所在目录下找到video文件夹。如果是vs内运行生成，这个文件夹会在代码所在目录下。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645681526261-f9be0d88-488b-4080-b899-dd6b3989ea12.png" alt="img"></p>
<h2 id="ffmpeg命令生成视频"><a href="#ffmpeg命令生成视频" class="headerlink" title="ffmpeg命令生成视频*"></a>ffmpeg命令生成视频*</h2><p>打开命令行，走到video目录，然后输入以下命令：</p>
<p>ffmpeg -r 10 -i videoframe%04d.ppm -q:v 1 output.avi</p>
<p>如图所示：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645686428622-3622a2f2-f39d-412d-8d7c-8ab3a2f72b15.png" alt="img"></p>
<p>我们分开看看这个命令讲了什么：</p>
<p>ffmpeg 表示运行的exe的名字，系统会在环境变量里面的那些目录去找叫这个名字的exe，显然，它要找的就是ffmpeg/bin文件夹下的那个exe。</p>
<p>-r 10 表示我们要以一秒10帧的速度安排这些图片，最后生成的图片每秒钟会有十张图片播放。</p>
<p>-i videoframe%04d.ppm 表示图片输入，ffmpeg会找指定格式化输入的%d从0开始，这样它就可以找到目录下全部的10张图片。</p>
<p>-q:v 1 表示我们希望最后生成的图像质量高一些，但可惜的是，即使是这样它还是会失去一些清晰度。</p>
<p>output.avi 输出文件目录，没有前缀的话它就会存放在和图片同样的目录里。</p>
<p>在一阵提示输出之后，你会得到视频：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645683030692-8da75e3d-8468-494d-9b54-409a80570f58.gif" alt="img"></p>
<p>它的时长是1秒。我们做到了三个时间统一：移动的球类指定时间，相机区间和最终生成图片时间区间。</p>
<p>时间统一有很多好处，它可以让时间轴一目了然。</p>
<p>当然它们三个也可以不完全统一，而是某种映射关系，这取决于你的设计。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>可以尝试通过修改代码，达到以下效果：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645684273328-b44becb3-6771-4ea0-9a8a-cbec55a731ad.gif" alt="nxr3w-nkpff.gif"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645851897575-a9747188-c28b-4fd7-82a4-b08f457451b5.gif" alt="i1khw-t25yk.gif"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第2.2节到第2.5节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/06/05/%E5%85%89%E8%BF%BD2.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E5%85%89%E8%BF%BD2.1/" class="post-title-link" itemprop="url">时空光追</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-05T00:00:00+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-09 09:47:26" itemprop="dateModified" datetime="2022-08-09T09:47:26+08:00">2022-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E5%85%89%E8%BF%BD2.1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E5%85%89%E8%BF%BD2.1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="曝光时间"><a href="#曝光时间" class="headerlink" title="曝光时间"></a>曝光时间</h2><p>初篇的最后我们一直在和相机较劲，一个拥有景深（散焦模糊）的相机也并不是我们相机进化的终点，在本篇的开始，我们将让相机进化为完全形态。这将是本系列最后一次改动相机类，在本篇之后，相机类将不会再有任何改动——当然，你自己可以对其进行一些个性化改动或者添加你认为需要的功能，但是对于我们介绍的所有功能中，相机将进化为完全体。</p>
<p>真实的相机，有一个概念叫做曝光时间：它表示镜头打开的时间，在这段时间内射到相机的光线都会被相机捕捉。</p>
<p>但是我们当前的相机，曝光时间是趋于无穷小的，也就意味着，<strong>任何高速移动的物体，在相机镜头打开的这一瞬间里，移动的距离都为0</strong>。</p>
<p>依照我们在散焦模糊那一章的处理思路，我们得自断一臂，通过某些方式让我们的相机产生缺陷去迎合真实的相机。</p>
<p>要怎么模拟曝光时间这一概念呢？按照逆光路模型，我们得让光线在一段时间内先后从相机射出，而不是一瞬间。按照曝光时间的长短，让某一个像素中射出的若干采样光线在此曝光时间内的随机时刻射出，并带回信息即可。</p>
<p>要想实现这一点，需要先改动光线类，让光线和时间挂钩。</p>
<p>请不要把这个时间和我们光线公式中 P( t ) = A + tb 的 t 弄混，这个 t 表示这一根光线在发射之后过了多少时间，并不涉及到光源发射的时间。</p>
<p>看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">// 更改构造函数，tm的缺省默认值为0。</span></span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction, <span class="keyword">double</span> time = <span class="number">0.0</span>)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">        <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//tm的getter函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">time</span><span class="params">()</span> <span class="keyword">const</span>    </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t*dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 光线发射时刻。</span></span><br><span class="line">        <span class="keyword">double</span> tm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>光线现在有发射时间的概念了，接下来修改发射光线的相机类，让相机能发射有不同tm值的光线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">            point3 lookfrom,</span><br><span class="line">            point3 lookat,</span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="keyword">double</span> vfov, </span><br><span class="line">            <span class="keyword">double</span> aspect_ratio,</span><br><span class="line">            <span class="keyword">double</span> aperture,</span><br><span class="line">            <span class="keyword">double</span> focus_dist,</span><br><span class="line">            <span class="comment">//相机快门打开时间。</span></span><br><span class="line">            <span class="keyword">double</span> _time0 = <span class="number">0</span>,</span><br><span class="line">			<span class="comment">//相机快门关闭时间，开关差值既是曝光时间。</span></span><br><span class="line">            <span class="keyword">double</span> _time1 = <span class="number">0</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">            u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">            v = <span class="built_in">cross</span>(w, u);</span><br><span class="line"></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">            horizontal = focus_dist * viewport_width * u;</span><br><span class="line">            vertical = focus_dist * viewport_height * v;</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - focus_dist*w;</span><br><span class="line"></span><br><span class="line">            lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//开关时间初始化</span></span><br><span class="line">            time0 = _time0;</span><br><span class="line">            time1 = _time1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">            vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">                origin + offset,</span><br><span class="line">                lower_left_corner + s*horizontal + t*vertical - origin - offset,</span><br><span class="line">                <span class="comment">//光线的tm值给一个time0和time1中的随机值。</span></span><br><span class="line">                <span class="built_in">random_double</span>(time0, time1)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">        vec3 u, v, w;</span><br><span class="line">        <span class="keyword">double</span> lens_radius;</span><br><span class="line">    	<span class="comment">//快门开关时间。</span></span><br><span class="line">        <span class="keyword">double</span> time0, time1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们拥有了一个能在曝光时间内随机发射光线的相机！你可能会觉得这根本不算什么，就是给光线类多加了一个成员变量罢了，但这对我们的渲染器来说是跨时代的一步。我们的光追器不再仅仅只是描绘光线在空间上的碰撞，而且开始描绘时间上的交错变化。这叫做<strong>时空光线追踪</strong>（SpaceTime Ray Tracing）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第1节和第2.1节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/05/25/C++%20thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/25/C++%20thread/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-25 21:34:57" itemprop="dateCreated datePublished" datetime="2022-05-25T21:34:57+08:00">2022-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-29 23:27:52" itemprop="dateModified" datetime="2022-05-29T23:27:52+08:00">2022-05-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/25/C++%20thread/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/25/C++%20thread/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/04/02/%E5%85%89%E8%BF%BD1.15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/%E5%85%89%E8%BF%BD1.15/" class="post-title-link" itemprop="url">多线程加速</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-02 00:00:00 / 修改时间：16:52:43" itemprop="dateCreated datePublished" datetime="2022-04-02T00:00:00+08:00">2022-04-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/02/%E5%85%89%E8%BF%BD1.15/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/02/%E5%85%89%E8%BF%BD1.15/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>本章内容为个人探索。</em></p>
<p>在《抗锯齿》那一章中，增加了多次采样的逻辑后，程序的运行速度开始变得非常缓慢。多次采样是渲染真实感图像的基石，想要保持多次采样的同时加快程序的运行速度，就得另辟蹊径。</p>
<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>在计算机中我们常听到进程与线程，<strong>进程</strong>是资源（CPU、内存等）分配的基本单位，通俗来说就是我们桌面上的每一个应用当点击QQ时，就创建了一个进程，我们所用的VS本地调式也是一个进程。<strong>线程</strong>是一条执行路径，是程序执行时的最小单位，他们之间的关系就好比一个部门和其中的每一个人，当然人越多干活越快，需要的总工资（内存和cpu资源）也越多。一个线程的使用示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="built_in">func</span>(par1, par2)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接构造thread对象t，第一个参数为函数，后面依次传入对应函数所需参数</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func, par1, par2...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//detach表示彻底放养t线程，这是一个危险的行为，如果不能保证主线程在t线程之后走完</span></span><br><span class="line"><span class="comment">//就会导致t线程的资源无法回收。</span></span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//join t线程到本线程，在join完后表示接下来的代码必须等待t执行完成之后才开始执行。</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="建立输出管理类"><a href="#建立输出管理类" class="headerlink" title="建立输出管理类"></a>建立输出管理类</h2><p>单线程代码中，渲染循环是由主线程独自运行完成的。建立多个线程平摊渲染循环中繁杂重复的任务是很容易想到的多线程加速方案。</p>
<p><strong>可以建立N个线程，让它们同时从不同行开始绘制。</strong>因为最终的ppm文件是有严格的顺序要求，每个线程绘制的像素都不可能都把画好的像素立即的输出到文件里，这里可以在内存上开一个缓冲区用来暂时存放结果，每个线程绘制好的像素先填入其中，等所有线程都绘制完成的时候，再将数组中的内容输出。</p>
<p>对于这部分缓冲区的管理，和最终输出到ppm文件的操作，我们可以封装到一个类里，创建imageoutput.h文件，敲入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IMAGEOUTPUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGEOUTPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色的值最高只到255，只需要8bit存储，使用int类型太过浪费。</span></span><br><span class="line"><span class="comment">// 我们给unsigned char这个8bit类型重命名，用它来当缓冲区类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> D_BYTE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">imageoutput</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，通过文件名直接输出。</span></span><br><span class="line">    <span class="built_in">imageoutput</span>(<span class="keyword">int</span> wth, <span class="keyword">int</span> hgt, <span class="keyword">const</span> <span class="keyword">char</span>* file_nm) :<span class="built_in">width</span>(wth), <span class="built_in">height</span>(hgt) &#123;</span><br><span class="line">        <span class="comment">// 分配一块大小为width * height * 3的区域用于存取像素的rgb。</span></span><br><span class="line">        buffer = <span class="keyword">new</span> D_BYTE[width * height * <span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 建立输出文件流。</span></span><br><span class="line">        outFile = std::<span class="built_in">ofstream</span>(file_nm);</span><br><span class="line">        <span class="comment">// ppm文件的开头要加上这句话。</span></span><br><span class="line">        outFile &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数，释放缓冲区。为保证安全性，需要确认它不为空。</span></span><br><span class="line">    ~<span class="built_in">imageoutput</span>() &#123;</span><br><span class="line">         <span class="keyword">if</span> (buffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填写颜色到数组中，需要传入像素的位置，以及rgb值。这里做了之前color类做的一些事情。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_buffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y, <span class="keyword">const</span> <span class="keyword">double</span> red, <span class="keyword">const</span> <span class="keyword">double</span> green, <span class="keyword">const</span> <span class="keyword">double</span> blue)</span> </span>&#123;</span><br><span class="line">        D_BYTE ir = <span class="built_in">D_BYTE</span>(<span class="number">255.999</span> * <span class="built_in">clamp</span>(red, <span class="number">0</span>, <span class="number">0.999</span>));</span><br><span class="line">        D_BYTE ig = <span class="built_in">D_BYTE</span>(<span class="number">255.999</span> * <span class="built_in">clamp</span>(green, <span class="number">0</span>, <span class="number">0.999</span>));</span><br><span class="line">        D_BYTE ib = <span class="built_in">D_BYTE</span>(<span class="number">255.999</span> * <span class="built_in">clamp</span>(blue, <span class="number">0</span>, <span class="number">0.999</span>));</span><br><span class="line">        <span class="comment">// 二维坐标转一维数组坐标，然后依次填入rgb。</span></span><br><span class="line">        <span class="keyword">int</span> n = (y * width + x) * <span class="number">3</span>;</span><br><span class="line">        buffer[n] = ir;</span><br><span class="line">        buffer[n + <span class="number">1</span>] = ig;</span><br><span class="line">        buffer[n + <span class="number">2</span>] = ib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数把整个缓冲区内的数据写入文件。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buffer_to_file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (height - <span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = (j * width + i) * <span class="number">3</span>;</span><br><span class="line">                outFile &lt;&lt; (<span class="keyword">int</span>)buffer[n] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="keyword">int</span>)buffer[n + <span class="number">1</span>] </span><br><span class="line">                    &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="keyword">int</span>)buffer[n + <span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    D_BYTE* buffer;</span><br><span class="line">    std::ofstream outFile;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="平摊渲染循环任务"><a href="#平摊渲染循环任务" class="headerlink" title="平摊渲染循环任务"></a>平摊渲染循环任务</h2><p>输出管理类提供了写缓冲区和最终生成图片的函数，接下来的任务就很明确了：创建线程们调用write_buffer函数写缓冲区，再在main函数的最后，把缓冲区写成文件。</p>
<p>为了拆分渲染循环，我们把它从main中抽离，并且把与之相关的一些变量都改为全局变量，方便多线程共享调用。</p>
<p>以下代码会重构main函数所在文件，为保留之前的代码，建议新建RayTracingByMultithread.cpp文件作为新的main文件，老代码记得保存，新代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imageoutput.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread相关，我们可以先设置为50个线程</span></span><br><span class="line"><span class="keyword">int</span> numThread = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//定义一个输出设置</span></span><br><span class="line">imageoutput* buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相机与场景</span></span><br><span class="line">hittable_list world;</span><br><span class="line">camera* cam;</span><br><span class="line"></span><br><span class="line"><span class="comment">//着色函数，直接复制。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//最终场景，直接复制。</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把渲染循环切分成numThread份，分配给每个线程执行。</span></span><br><span class="line"><span class="comment">//这是分配第k个线程的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ray_tracing_by_thread</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height - k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= numThread) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; i++) &#123;</span><br><span class="line">            <span class="function">color <span class="title">tmp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; s++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam-&gt;<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                tmp += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp /= <span class="built_in"><span class="keyword">float</span></span>(samples_per_pixel);</span><br><span class="line">            <span class="comment">//将颜色gamma矫正，存入缓冲区</span></span><br><span class="line">   			buf-&gt;<span class="built_in">write_buffer</span>(i, j, <span class="built_in">sqrt</span>(tmp[<span class="number">0</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">1</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 摆放场景</span></span><br><span class="line">    world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化缓冲区和输出文件流，并给图片命名。</span></span><br><span class="line">    buf = <span class="keyword">new</span> <span class="built_in">imageoutput</span>(image_width, image_height,<span class="string">&quot;image.ppm&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 线程列表</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 放置相机</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line">    cam = <span class="keyword">new</span> <span class="built_in">camera</span>(lookfrom, lookat, <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程下的renderloop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numThread; k++) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(ray_tracing_by_thread, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="comment">//阻塞主线程，必须等待所有线程执行完毕，再会执行后续的代码。</span></span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲区已经填充完毕，输出成文件。</span></span><br><span class="line">    buf-&gt;<span class="built_in">buffer_2_file</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放堆上内存。</span></span><br><span class="line">    <span class="keyword">delete</span> cam;</span><br><span class="line">    <span class="keyword">delete</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然选择使用文件流的方式创建文件，那么也不需要使用命令窗口了，可以直接点击vs中的本地调试以生成文件，紧接着就可以在代码所在目录下找到image.ppm文件了。</p>
<p>如果还是采用命令行的方式生成（不使用重定向符号，命令行中直接运行exe），image.ppm文件会生成在exe文件同目录下。</p>
<p>如果本次生成感到卡顿，可以降低线程数量，但总体来说，生成文件的速度肯定比单线程要快上好几倍。</p>
<h2 id="进度提示"><a href="#进度提示" class="headerlink" title="进度提示"></a>进度提示</h2><p>最后一步，加上进度提示。</p>
<p>先在每个线程里对共享的记录变量进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剩余行数</span></span><br><span class="line"><span class="keyword">int</span> line_remain = image_height;</span><br><span class="line"><span class="comment">//剩余多少线程没完成任务</span></span><br><span class="line"><span class="keyword">int</span> thread_remain = numThread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ray_tracing_by_thread</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height - k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= numThread) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; i++) &#123;</span><br><span class="line">           ...</span><br><span class="line">            buf-&gt;<span class="built_in">write_buffer</span>(i, j, <span class="built_in">sqrt</span>(tmp[<span class="number">0</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">1</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行到这说明有一行像素存缓冲区完毕。</span></span><br><span class="line">        --line_remain;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到这说明有一个线程执行完毕。</span></span><br><span class="line">    --thread_remain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main函数里进行记录，这次把线程改成detach于主线程。因为主线程可以通过thread_remain来判断线程们的运行情况，就不必担心主线程会先结束了，并且还可以利用主线程的等待时间进行进度的显示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    cam = <span class="keyword">new</span> <span class="built_in">camera</span>(lookfrom, lookat, <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程下的renderloop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numThread; k++) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(ray_tracing_by_thread, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="comment">//detach单独使用是非常危险的，但后续的while循环会卡住主线程，让线程结束顺序变得可控。</span></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (thread_remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// line_remain-1是为了最后能让显示数字归零，工整好看。</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; line_remain<span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">    buf-&gt;<span class="built_in">buffer_2_file</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cam;</span><br><span class="line">    <span class="keyword">delete</span> buf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样控制台就会有进度提示了。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644760612951-6f06140b-95a2-44f0-bd93-ae060937d22d.png" alt="img"></p>
<p>数字刷新速度开始很慢，这说明在程序运行的一开始，main函数中的while循环争取到cpu的频率不高，cpu大多被副线程们占据，最后会随着副线程们一个个全都完成，主线程能争取到的cpu时间会变多，刷新速度变得顺畅。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>注意到line_remain和thread_remain变量在同时被多个线程访问中所产生的问题吗？如果有那么一个时刻，有两个线程同时拿取了line_remain的值——假设是53，他们同时对其进行–操作，然后相继写回了它们各自认为的正确的值——52，实际上这个值是错误的，有两个线程在同一时刻完成了图片中的某行的渲染，这个值理应减到51。</p>
<p>对变量加同步锁，可以完美的解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行到这的线程都会尝试给some_mutex加上属于它们自己的锁。</span></span><br><span class="line"><span class="comment">//但是如果这时候锁已经有主人了，这个请求就会失败，申请的线程会被阻塞，直到锁被持有者释放。</span></span><br><span class="line">some_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥代码</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//锁的持有者释放了这个锁！现在其他线程们可以来抢夺这枚锁了！</span></span><br><span class="line">some_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>锁的本质是创造一个只有一个线程可以独享的区域，上述代码中，some_mutex是个同步信号量，对其实行lock()操作意味有某个线程想要占有这枚锁，之后所有想要拥有这枚锁的线程，都必须要等待本线程释放掉它。</p>
<p>在lock和unlock之间的代码，在同一时间里，至多只有一个线程执行。这样就避免了同时写变量，导致变量值出错的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">//信号量</span></span><br><span class="line">std::mutex line_remain_mutex;</span><br><span class="line">std::mutex thread_remain_mutex;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = image_height - k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= numThread) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; i++) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        line_remain_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        --line_remain;</span><br><span class="line">        line_remain_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    thread_remain_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    --thread_remain;</span><br><span class="line">    thread_remain_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<h2 id="用宏控制要执行的代码块"><a href="#用宏控制要执行的代码块" class="headerlink" title="用宏控制要执行的代码块"></a>用宏控制要执行的代码块</h2><p>因为之后依然是在单线程模式的基础上进行编写的，有时候需要切回单线程模式，来回黏贴代码很麻烦，可以使用如下方式自由的在两种模式之间切换，首先，确保项目目录下有第十五章结束时候的main函数所在文件和本章新创建的文件。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644765772450-258fabf2-16b2-4f31-833b-4cade26bc58a.png" alt="img"></p>
<p>在老文件RayTracing.cpp（当然你的可能不叫这个名字）中加入如下宏，<strong>包裹所有的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !MULTITHREAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在新文件中使用同样的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MULTITHREAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来尝试添加一下预编译命令，此处展示vs中更改预编译命令的方法：</p>
<p>注意，一定要保证修改的配置页是当前的代码环境，比如下图中修改的是“活动(Release)”-“活动(Win32)”平台，如果你的代码是Debug平台或者是x64，此更改并不会生效。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766071978-e908b653-500a-4b87-82e3-a9ab94cf4a54.png" alt="img"></p>
<p>添加MULTITHREAD命令，本程序便会进入多线程模式：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766120244-c255d9d5-445b-40b9-a73d-24345c04dee8.png" alt="img"></p>
<p>添加完成后，显示如下：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766148415-4d46e8c8-b22d-45fb-a2df-c6010d4a258d.png" alt="img"></p>
<p>在MULTITHREAD的宏定义成功后，老文件中的代码应该全显示为灰色。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766227253-9d89c9bf-50c5-4a67-b84b-2454a519801f.png" alt="img"></p>
<p>如果想使用单线程，就再次编辑上述预处理器文本，删除MULTITHREAD命令即可。</p>
<p>其他编辑器有各自的预处理命令的添加方式，或者你可以通过新建一个.h文件作为配置文件，再把<code>#define MULTITHREAD 1or0</code>输入到配置文件中，来定义并使用宏。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/04/02/%E5%83%B5%E5%B0%B8%E5%9B%B4%E5%9F%8E-%E7%AE%A1%E7%90%86%E8%80%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/%E5%83%B5%E5%B0%B8%E5%9B%B4%E5%9F%8E-%E7%AE%A1%E7%90%86%E8%80%85/" class="post-title-link" itemprop="url">丧尸围城-框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-02T00:00:00+08:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-19 08:21:15" itemprop="dateModified" datetime="2022-05-19T08:21:15+08:00">2022-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index"><span itemprop="name">unity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/02/%E5%83%B5%E5%B0%B8%E5%9B%B4%E5%9F%8E-%E7%AE%A1%E7%90%86%E8%80%85/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/02/%E5%83%B5%E5%B0%B8%E5%9B%B4%E5%9F%8E-%E7%AE%A1%E7%90%86%E8%80%85/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以前做的项目，复习一下以前写的框架，<em>注：</em>只针对代码讲解。</p>
<h1 id="数据管理者"><a href="#数据管理者" class="headerlink" title="数据管理者"></a>数据管理者</h1><p>因为在游戏中我希望能将游戏的数据储存，或者在外部配置一些数据应用到游戏中，所以用到了json的数据存贮，这里我们直接基于Litjson开源项目来完成这个管理者类。其功能主要便是把数据序列化后储存到本地和将本地数据反序列化应用于游戏中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">using LitJson;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.IO;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">// 序列化和反序列化Json时  使用的是哪种方案</span><br><span class="line">public enum JsonType</span><br><span class="line">&#123;</span><br><span class="line">    JsonUtlity,</span><br><span class="line">    LitJson,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Json数据管理类 主要用于进行Json的序列化存储到硬盘和反序列化从硬盘中读取到内存中</span><br><span class="line">public class JsonMgr</span><br><span class="line">&#123;</span><br><span class="line">    //单例模式，简单说就是将此脚本的代码暴露出去，供其他所有脚本使用，通常用在管理者脚本上</span><br><span class="line">    private static JsonMgr instance = new JsonMgr();</span><br><span class="line">    public static JsonMgr Instance =&gt; instance;</span><br><span class="line"></span><br><span class="line">    private JsonMgr() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    //存储Json数据 序列化</span><br><span class="line">    public void SaveData(object data, string fileName, JsonType type = JsonType.LitJson)</span><br><span class="line">    &#123;</span><br><span class="line">        //确定存储路径</span><br><span class="line">        string path = Application.persistentDataPath + &quot;/&quot; + fileName + &quot;.json&quot;;</span><br><span class="line">        //序列化 得到Json字符串</span><br><span class="line">        string jsonStr = &quot;&quot;;</span><br><span class="line">        switch (type)</span><br><span class="line">        &#123;</span><br><span class="line">            case JsonType.JsonUtlity:</span><br><span class="line">                jsonStr = JsonUtility.ToJson(data);</span><br><span class="line">                break;</span><br><span class="line">            case JsonType.LitJson:</span><br><span class="line">                jsonStr = JsonMapper.ToJson(data);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        //把序列化的Json字符串 存储到指定路径的文件中</span><br><span class="line">        File.WriteAllText(path, jsonStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取指定文件中的 Json数据 反序列化</span><br><span class="line">    public T LoadData&lt;T&gt;(string fileName, JsonType type = JsonType.LitJson) where T : new()</span><br><span class="line">    &#123;</span><br><span class="line">        //确定从哪个路径读取</span><br><span class="line">        //首先先判断 默认数据文件夹中是否有我们想要的数据 如果有 就从中获取</span><br><span class="line">        string path = Application.streamingAssetsPath + &quot;/&quot; + fileName + &quot;.json&quot;;</span><br><span class="line">        //先判断 是否存在这个文件</span><br><span class="line">        //如果不存在默认文件 就从 读写文件夹中去寻找</span><br><span class="line">        if(!File.Exists(path))</span><br><span class="line">            path = Application.persistentDataPath + &quot;/&quot; + fileName + &quot;.json&quot;;</span><br><span class="line">        //如果读写文件夹中都还没有 那就返回一个默认对象</span><br><span class="line">        if (!File.Exists(path))</span><br><span class="line">            return new T();</span><br><span class="line"></span><br><span class="line">        //进行反序列化</span><br><span class="line">        string jsonStr = File.ReadAllText(path);</span><br><span class="line">        //数据对象</span><br><span class="line">        T data = default(T);</span><br><span class="line">        switch (type)</span><br><span class="line">        &#123;</span><br><span class="line">            case JsonType.JsonUtlity:</span><br><span class="line">                data = JsonUtility.FromJson&lt;T&gt;(jsonStr);</span><br><span class="line">                break;</span><br><span class="line">            case JsonType.LitJson:</span><br><span class="line">                data = JsonMapper.ToObject&lt;T&gt;(jsonStr);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把对象返回出去</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UI管理者类"><a href="#UI管理者类" class="headerlink" title="UI管理者类"></a>UI管理者类</h1><p>我们需要一个管理者类来控制和管理我们所有面板的显示以及隐藏，因为我们需要管理不同的面板，所以需要使用模板，此时我们制作面板基类的好处就是，可以通过它来统一管理所有面板。来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class UIManager </span><br><span class="line">&#123;</span><br><span class="line">    //单例模式</span><br><span class="line">    private static UIManager instance = new UIManager();</span><br><span class="line"></span><br><span class="line">    public static UIManager Instance &#123; get =&gt; instance; set =&gt; instance = value; &#125;</span><br><span class="line"></span><br><span class="line">    //用与显示的面板，每显示一个面板就将其加入字典中，以便于调用</span><br><span class="line">    private Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;();</span><br><span class="line"></span><br><span class="line">    //得到自身的Transform，</span><br><span class="line">    private Transform canvasTrans;</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    private UIManager()</span><br><span class="line">    &#123;</span><br><span class="line">        //创建canvas空白画布</span><br><span class="line">        GameObject canvas = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;UI/Canvas&quot;));</span><br><span class="line">        //把画布位置保存下来</span><br><span class="line">        canvasTrans = canvas.transform;</span><br><span class="line">		</span><br><span class="line">        //防止场景加载的时候被销毁</span><br><span class="line">        GameObject.DontDestroyOnLoad(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //传入想调用的面板，来将它显示</span><br><span class="line">    public T showPanel&lt;T&gt;(bool isFade = true) where T:BasePanel</span><br><span class="line">    &#123;</span><br><span class="line">        //type(T)获取该对象，并取得其名字</span><br><span class="line">        string panelName = typeof(T).Name;</span><br><span class="line"></span><br><span class="line">        //查看字典中有无该面板，如果有表明已经显示，直接return该面板，注意此处要将BasePanel重新转换为子类类型</span><br><span class="line">        if (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            return panelDic[panelName] as T;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //显示面板 根据面板名字 动态创建预制体 设置父对象</span><br><span class="line">        GameObject panelObj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;UI/&quot; + panelName));</span><br><span class="line">        panelObj.transform.SetParent(canvasTrans, false);</span><br><span class="line"></span><br><span class="line">        //指向面板上 显示逻辑  并且把它保存起来</span><br><span class="line">        T panel = panelObj.GetComponent&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">        //把这个面板脚本 存储在字典中方便之后的获取和隐藏；</span><br><span class="line">        panelDic.Add(panelName, panel);</span><br><span class="line"></span><br><span class="line">        panel.ShowMe(isFade);</span><br><span class="line"></span><br><span class="line">        return panel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	//隐藏面板</span><br><span class="line">    public void HidePanel&lt;T&gt;(bool isFade = true) where T:BasePanel</span><br><span class="line">    &#123;</span><br><span class="line">        //根据泛型取得名字</span><br><span class="line">        string panelName = typeof(T).Name;</span><br><span class="line"></span><br><span class="line">        //如果存在，调用其基类的HideMe函数，并传入lambda让其释放内存并在字典中删除</span><br><span class="line">        if (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            if (isFade)</span><br><span class="line">            &#123;</span><br><span class="line">                panelDic[panelName].HideMe(() =&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                    //删除对象</span><br><span class="line">                    GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line">                    //删除字典里面储存 面板脚本</span><br><span class="line">                    panelDic.Remove(panelName);</span><br><span class="line">               &#125;); </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //删除对象</span><br><span class="line">                GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line">                //删除字典里面储存 面板脚本</span><br><span class="line">                panelDic.Remove(panelName); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //得到面板</span><br><span class="line">    public T GetPanel&lt;T&gt;() where T:BasePanel</span><br><span class="line">    &#123;</span><br><span class="line">        string panelName = typeof(T).Name;</span><br><span class="line">        if (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            return panelDic[panelName] as T;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个脚本，我们就可以非常方便的调出和删除面板，所有的UI控制我们都可以使用此脚本来实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/03/28/%E5%85%89%E8%BF%BD1.14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/%E5%85%89%E8%BF%BD1.14/" class="post-title-link" itemprop="url">散焦模糊</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-28T00:00:00+08:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:52:47" itemprop="dateModified" datetime="2022-04-02T16:52:47+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/28/%E5%85%89%E8%BF%BD1.14/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/28/%E5%85%89%E8%BF%BD1.14/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="传统相机的局限"><a href="#传统相机的局限" class="headerlink" title="传统相机的局限"></a>传统相机的局限</h2><p>现实中的相机可无法把它获取的所有光线都汇聚到一点，通过逆光路模型来解释，就是它无法精准的控制发射光线的起点都重合在一起。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643969907150-aefe4446-4da2-4de0-9bd2-fe176e670885.png" alt="img"></p>
<p>如上图所示，inside表示相机内部，outside是相机的外部。</p>
<p>相机通过镜头采集光线，镜头采集到的光线会被汇总，在镜头后的胶片上成像。在镜头之外，根据镜头凹透镜的焦距，在某个距离处采集到的光线都来自于一点，这个平面上的所有物体都处于完美对焦状态，而其他距离下的物体，都会因为光线无法精准落于一点而出现模糊。离完美对焦距离越远，就越模糊。</p>
<h2 id="模拟散焦模糊"><a href="#模拟散焦模糊" class="headerlink" title="模拟散焦模糊"></a>模拟散焦模糊</h2><p>在《抗锯齿》那一章我们编写的多采样求平均的算法就可以完美模拟从镜头采集到成像的过程，现在，只需要改变我们光线的发射位置，假装光线是从镜头上任意一点发射的即可。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643970443347-3db9b25c-c319-4f16-92fe-841fa915af9c.png" alt="img"></p>
<p>具体要怎么做呢？</p>
<p><strong>1.要如何模拟镜头呢？</strong></p>
<p>我们可以以原来的固定光线发射点为圆心，找一个圆片，这个圆片和虚拟视口所在平面平行，和相机正对方向垂直。然后在这个圆片上随机找一个点，以这个点为起点发射光线（这个圆片就是虚拟相机的镜头）。这个圆片的大小对应着真实相机中的镜头光圈大小，圆片越大，散焦模糊效果就越大。</p>
<p><strong>2.要如何模拟光线聚焦效果呢？</strong></p>
<p>光线是射向虚拟视口上的虚拟像素内的。在我们原来的设计里，虚拟视口和相机位置的距离始终为1，这意味着，我们的光线都会在镜头前方距离为1的平面上聚焦，如果我们需要让他能在任意位置聚焦，我们只需要改变虚拟视口距离相机的距离即可。</p>
<p>还记得是如何在代码中规定虚拟视口的位置的吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - w;</span><br></pre></td></tr></table></figure>

<p>如果我想把它推到和相机位置距离为2的平面上，仅仅是修改w的系数就可以了吗？比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="number">2</span>*w;</span><br></pre></td></tr></table></figure>

<p>这样就足够了吗？不行，看下图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643973076508-497c8957-39b9-46c8-8202-5b3052917235.png" alt="img"></p>
<p>图上描绘的是相机空间下VoW面上的截面，假设中间的绿色竖线就是原先的虚拟视口，它离相机的距离为1，现在要把它移动到右边的蓝色平面上，根据相似三角形，如果它离相机的距离改成2，那它的高度会同步扩大为2，且因为像素数量没变，每个虚拟像素的大小也会增加为2。<strong>这意味着horizontal和vertical也得同步进行放大。</strong></p>
<p>图中射向虚拟视口的光线假设命中了第x行，如果像素的大小扩大两倍，这根光线的延长线也会命中蓝色视口的第x行。如果像素没有放大，它将命中第2x行，这就不对了。</p>
<p>更改相机代码，现在我们可以传入焦距和光圈大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">            point3 lookfrom,</span><br><span class="line">            point3 lookat,</span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="keyword">double</span> vfov,</span><br><span class="line">            <span class="keyword">double</span> aspect_ratio,</span><br><span class="line">            <span class="comment">//光圈直径</span></span><br><span class="line">            <span class="keyword">double</span> aperture,</span><br><span class="line">            <span class="comment">//焦距</span></span><br><span class="line">            <span class="keyword">double</span> focus_dist</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">            u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">            v = <span class="built_in">cross</span>(w, u);</span><br><span class="line"></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//我们要把虚拟视口推到离相机位置有focus_dist的距离的平面上。</span></span><br><span class="line">            <span class="comment">//原本的距离是1，距离变成原来的focus_dist倍。</span></span><br><span class="line">            <span class="comment">//所以，horizontal和vertical得同步乘以focus_dist倍。</span></span><br><span class="line">            horizontal = focus_dist * viewport_width * u;</span><br><span class="line">            vertical = focus_dist * viewport_height * v;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//距离不再是w，而是focus_dist*w。</span></span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - focus_dist*w;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//处理一下，拿到半径。</span></span><br><span class="line">            lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 生成一个偏移值。</span></span><br><span class="line">            <span class="comment">// 这个random_in_unit_disk()函数会产生一个XoY平面上的以原点为圆心的单位圆片内随机一点。</span></span><br><span class="line">            <span class="comment">// 该函数之后给出。</span></span><br><span class="line">            vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">            <span class="comment">// 把圆片从XoY平面，调整到uv平面上。</span></span><br><span class="line">            vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">                <span class="comment">// 顶点加上偏移。</span></span><br><span class="line">                origin + offset,</span><br><span class="line">                <span class="comment">// -offset使得光线还是朝虚拟视口上的当前像素上发射的。</span></span><br><span class="line">                lower_left_corner + s*horizontal + t*vertical - origin - offset</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">        vec3 u, v, w;</span><br><span class="line">        <span class="keyword">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把random_in_unit_disk函数写在vec3.h类的类外，这个函数负责生成一个XoY面上以原点为圆心的圆片内的随机一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XoY面上以原点为圆心的圆片内的随机一点。</span></span><br><span class="line"><span class="function">vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>,<span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>,<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是使用上一章的场景，但要调整相机，给一个很大的光圈直径，并且把对焦平面（虚拟视口）放在画面正中心的小球上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom-lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    会得到这张图，这里的光圈很大，只要物体离虚拟视口有一点距离，就看不清了。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643976783038-8526d1b9-95c6-4cef-b5fc-413bf73fd84b.png" alt="img"></p>
<h2 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h2><p>现在来汇总在第一章中学到的所有知识，绘制一张图片，这将会是集大成之作，写入代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数帮助生成一个丰富多彩的场景！！！</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    <span class="comment">//先来一个“地板”，它比我们之前创建过最大的球还要大十倍！！！</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这个循环里我们将生成数个小球！！！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//先进行一次随机采样，这次采样用来决定本轮循环生成的小球的材质！！！</span></span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="comment">//在一个y=0.2这个平面上的一块方形区域里随机找一个点，作为这颗小球的球心！！！</span></span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*random_double())</span></span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//我们腾出一个位置，让生成的这些小球离(4, 0.2, 0)这个点远一点！！！</span></span><br><span class="line">            <span class="comment">//因为这里我们要放置一个非常明显的大球，如果出现球与球重合就会影响美观了！！！</span></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//定义一个智能指针，但先别急着决定指向什么类型的材质对象！！！</span></span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line">				</span><br><span class="line">          </span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;<span class="comment">//我们的材质有百分之八十的概率会是磨砂材质。</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>() * color::<span class="built_in">random</span>();</span><br><span class="line">                    sphere_material = make_shared&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;<span class="comment">//我们的材质有百分之十五的概率会是金属材质。</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = make_shared&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//我们的材质有百分之五的概率会是玻璃材质。</span></span><br><span class="line">                    sphere_material = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三颗站在C位的大球！！！</span></span><br><span class="line">    <span class="keyword">auto</span> material1 = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = make_shared&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整图片参数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//分辨率调高点，玩票大的！！！</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="comment">//拉高采样率会增加最终艺术品的成色！！！</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用函数生成一个有着许多随机小球的场景！！！</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置相机</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="comment">//这次是小光圈。</span></span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// renderloop</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644241403158-330630b4-149f-456e-9abd-a749828948f6.png" alt="image.png"></p>
<p>可以给你的随机数生成器其他的种子，来改变小球的随机位置，直到你得到满意的结果。</p>
<p>到此为止，这本书的内容就结束喽！但这个渲染器并没有完成，接下来的内容在《Ray Tracing: The Next Week》中，但在此之前必须想办法给程序提个速，交给下一小节吧。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第12节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  



<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz',
      appKey     : '6k9HROMoqf6vzPadEMksx26r',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>