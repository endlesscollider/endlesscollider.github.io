<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="祥瑞客栈">
<meta property="og:url" content="http://mackrui.com/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Collider">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mackrui.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">28</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/03/03/%E5%85%89%E8%BF%BD1.8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/%E5%85%89%E8%BF%BD1.8/" class="post-title-link" itemprop="url">从零实现光追渲染（八）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-03T00:00:00+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 22:10:01" itemprop="dateModified" datetime="2022-03-07T22:10:01+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/03/03/%E5%85%89%E8%BF%BD1.8/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（八）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="磨砂（上）"><a href="#磨砂（上）" class="headerlink" title="磨砂（上）"></a>磨砂（上）</h1><p>之前我们一直在画一些看起来完全不真实的东西，但从现在开始我们可以来实现更加真实的物体了。</p>
<h3 id="漫反射原理"><a href="#漫反射原理" class="headerlink" title="漫反射原理"></a>漫反射原理</h3><p>例如土墙、手机壳、木制桌面等等这些表面有很多微小凹凸的材质叫做漫反射材质，它们会吸收一部分光线，并且把剩余的光线朝随机方向反射出去，因为光线被反射到了不同的方向，自然不会出现某一个方向能接收到很亮的光线，也就不会有高光点存在。它们一般会吸收特定颜色的光，比如红色的砖块，它会吸收不是红色的光线，而把红色的光线按照随机方向反弹回去。</p>
<p><img src="http://cdn.jsdelivr.net/gh/endlesscollider/imageBed/image-20220307205949767.png" alt="image-20220307205949767"></p>
<h2 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h2><p>现在暂时还没有光源，我们不妨假设<strong>“蓝天”就是光源</strong>，光的能量都是从蓝天上来的。</p>
<p>我们再假设任何物体对各种颜色光线的吸收率都是一样的，是<strong>1：1</strong>。光线碰撞到物体后，都会吸收掉每种光的一半的能量，然后反射一半。</p>
<p>又因为我们是逆光路取色，有以下n种情况：</p>
<ol>
<li>从相机射出一根光线，这根光线没有碰到任何物体，即它射中了“蓝天”，那逆光路顺过来看看这意味着<strong>相机直接望到了蓝天，蓝天发出的光没有经过任何弹射直接进入了相机。</strong></li>
<li>从相机射出一根光线，这根光线碰到了一颗球，然后经过随机弹射之后，再也没有射中任何物体，朝无穷远处射出，即，它经过一次弹射之后射中了蓝天。逆光路顺过来看看这意味着<strong>光线从蓝天射出打到了物体上并且弹到我们的眼睛里。</strong>因为这个物体的能量吸收和反射的比率是1：1，所以这根光线只有一半的能量了。</li>
<li>我们从相机射出一根光线，这根光线碰到了一颗球，然后经过随机弹射之后，它又碰到了一颗球，逆光路顺过来看<strong>光线从蓝天射出打到了一颗球上，反射到了另外一颗球上，再反射到我们的眼睛里，没错，这根光线只剩四分之一的能量了。</strong></li>
<li>…… </li>
</ol>
<p>那么光线在空间中弹射了n-1次，它的能量只剩<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/bb01c00e8b77357ff3732c4f3f3eb9bb.svg" alt="img">。</p>
<p>从相机中射出一根光线之后，只要碰撞到物体，就从这个碰撞点朝随机方向发射一根光线，然后把这根光线取到的颜色乘以0.5并返回。</p>
<p>我们的取色函数叫<code>ray_color(const ray&amp; r, const hittable&amp; world)</code>，我们这个函数的返回值应该写什么呢？应该是<code>return 0.5 * ray_color(newRay,world)</code>，没错，这是一个递归，函数会疯狂的调用自己，直到某根随机反射光线射中了“蓝天”，再一层一层地返回。</p>
<h2 id="随机光线"><a href="#随机光线" class="headerlink" title="随机光线"></a>随机光线</h2><p>之前遗留的最后一个问题是如何随机发射一根光线呢？</p>
<p>这个问题并不像表面看上去那么简单，使用什么模型可以更加真实的模拟漫反射呢？最简单的模型是单位球体积内随机选点模型，如图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307211216029.png" alt="image-20220307211216029"></p>
<p>碰撞点是<strong>P</strong>，法线为<strong>N</strong>（单位化），在以（<strong>P+N</strong>）这个点为球心的单位球内随机寻找一点<strong>S</strong>，然后以<strong>S</strong>减去<strong>P</strong>为光线的反射方向向量就是最终我们需要的向量。这个<strong>S</strong>点是<strong>P</strong>点坐标+<strong>N</strong>向量+一个由球心指向球内随机点的向量三部分组成。</p>
<p><strong>r</strong>向量是相机观察方向，因为我们的漫反射和视角方向无关，不用去管它。</p>
<p>在vec3文件中写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里函数都是static的，就表示它属于整个类而不属于某个特定的对象，我们可以使用上面的函数直接调用vec3类构造生成一个三个分量都在[0,1)或者[min,max)内随机的随机vec3。</p>
<p>random() 函数生成的vec3可不是在单位球内的，它的XYZ轴都是在[0,1)之间的，它是一个在<strong>单位立方体</strong>内的点或者向量，我们得做一个简单的处理，让它的随机值最终落于单位球内。</p>
<p>再在vec3.h文件中vec3的类外写一个<strong>全局</strong>函数，它只有四句代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 先来个中心在原点，边长为2的立方体内的点。</span></span><br><span class="line">        <span class="keyword">auto</span> p = vec3::<span class="built_in">random</span>(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果发现这个vec3的长度（它离原点的距离）大于1，即表示它是落于立方体内且落于球外的。</span></span><br><span class="line">        <span class="comment">// 直接让他暴力再随机一次。</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个位于单位球内的点。</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用了一个很暴力的方法：<strong>拒绝算法（rejection method）</strong>，直接让他疯狂的循环，只要点不落于单位球内，我们就让他一直随机到单位球内为止。</p>
<p>接着更新着色代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由三部分组成的S点坐标。</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创造新的光线并开启下一轮递归。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么将它写在这里，有一个原则就是<strong>对于不自信的内容，先写到表层实现需求，再抽象到底层维护框架</strong>。所以这里不要在意它污染了main函数（对所有的物体都采用了漫反射）。</p>
<h2 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h2><p>到这里运行程序法线根本无法运行：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307213818888.png" alt="image-20220307213818888"></p>
<p>之前设置的递归终止条件是光线射入蓝天，但是如果光线没有射到蓝天而是一直在夹缝里不停的弹跳，就会导致系统栈溢出。为此因为引入一个光线弹射次数的上限值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果次数消耗殆尽，直接终止递归，我们的系统栈可耗不起了！</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="comment">//每一轮新的递归，我们把光线可弹射次数减一。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给定光线最大弹射次数。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line"></span><br><span class="line">        ...            </span><br><span class="line">        <span class="comment">//更改ray_color调用代码。</span></span><br><span class="line">        pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们应该可以得到一张带有漫反射材质的图了：<br><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307214423049.png" alt="image-20220307214423049"></p>
<p>非常的暗的图片，但确实可以看到漫反射的细节，如果我们只看上方小球的球顶，常识告诉我们，光线打到这里，很大概率能反弹到蓝天上，也就是说，它的颜色应该趋向于蓝天的颜色衰减了一半之后的某种蓝色。而图像并非如此。</p>
<p>另一种方法也可以佐证，用文本模式打开ppm文件，可以看到上边右图中的RGB值，它们都是很靠近黑色的值，我们的程序似乎就没生成过只弹射一次就碰到蓝天的光线，这个问题在下一章得到一个非常巧妙且完美的解决办法。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol>
<li>可以证明单位球体积随机选点模型的代码取到的点一定是随机的吗？</li>
<li>如果光线是从球内打到球的内壁上，我们代码能正确的运转吗？</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第8.1节到8.3节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/03/01/%E5%85%89%E8%BF%BD1.7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/%E5%85%89%E8%BF%BD1.7/" class="post-title-link" itemprop="url">从零实现光追渲染（七）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-01T00:00:00+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 22:10:00" itemprop="dateModified" datetime="2022-03-07T22:10:00+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/03/01/%E5%85%89%E8%BF%BD1.7/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（七）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h1><p>仔细观察前面生成的图片，在物体的交界处呈现的是锯齿状，哪怕分辨率非常大，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">1600</span>;</span><br></pre></td></tr></table></figure>

<p>得到这样的图像</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307193903032.png" alt="image-20220307193903032"></p>
<p>放大边缘，可以看到依然如此，为了解决这个问题，先看抗锯齿的本质。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307193945194.png" alt="image-20220307193945194"></p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>其实这个问题之前讨论过，相机只对着每个像素的左上角发射光线，那左上的带回的颜色可以代表整个像素吗？当然不行，所以最好的解决办法就是在这个像素内多发射几次光线，然后取颜色的平均值，即提高<strong>采样率</strong>。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307194536541.png" alt="image-20220307194536541"></p>
<p>比如上图中我们可以在一个像素内采样四次，得到的图像就会准确的多。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>在这里我们就需要用到随机数，其实光线追踪的很多地方都会用到它，首先回忆一下C语言中的随机数，在rtweekend.h中加入内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rand()会返回一个0~RAND_MAX之间的随机数，所以下面这个式子返回的随机数值范围是[0,1)。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围在[min,max)的随机数。</span></span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，我们有更强大的随机数算法，那就是mt19937，它的随机性好，在计算机上容易实现，占用内存较少，所以这里选用mt19937随机数，可以把上面代码中random_double函数改掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置随机范围0到1</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//创建随机数对象</span></span><br><span class="line">    <span class="keyword">static</span> std::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装相机"><a href="#封装相机" class="headerlink" title="封装相机"></a>封装相机</h2><p>这是一个封装我们的相机的好机会。在开始多次采样之前，我们先把相机处理完，让main函数中少一点乱七八糟的代码。</p>
<p>我们可以把在main函数中渲染循环外对相机的所有操作都移动到相机类的构造函数里，然后创建一个类内函数专门用来发射光线，这样设计下来，在main函数中所剩的代码最为清爽。</p>
<p>创建camera.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>() &#123;</span><br><span class="line">            <span class="comment">//暂时全部写死，代码保持和之前在main函数中的一致。</span></span><br><span class="line">            <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">            <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">			</span><br><span class="line">            origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//发射光线的函数，吃xy轴的偏移，吐出一根从原点射往指定方向的光线。</span></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">//这些参数我们没有暴露的必要。之后我们制作高级相机的时候，再考虑要不要把它们的权限放开。</span></span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="修改颜色类"><a href="#修改颜色类" class="headerlink" title="修改颜色类"></a>修改颜色类</h2><p>因为现在需要多次采样，原color类中的write_color函数也需要修改，为了用户更方便的使用main函数中，颜色只管叠加，其余交给write_color处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除以采样次数</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保最终的值是在[0,255]之间，换句话说，我们需要确保r,g,b都在[0,1]之间。</span></span><br><span class="line">    <span class="comment">//这个clamp函数在之后给出。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先需要把处理传进来的颜色除以采样数，还需要将每个通道的颜色映射到0到255的范围内。其中clamp函数是为了确保传入的值在特定区间内，比如这里如果传入的值大于1，就会导致颜色无法显示。所以还是在这个文件中写入函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">clamp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成果验收"><a href="#成果验收" class="headerlink" title="成果验收"></a>成果验收</h2><p>接下来只要替换相机，渲染循环中再加一层for即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们必须要一些参数来告诉程序需要生成什么样的图片，这部分代码逻辑上和摄像机没有关系，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="comment">// 采样次数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要一个构造函数，我们就可以把相机安排妥当。</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//多了一层循环哦。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 随机数出场了，u和v每次都会随机加上一个[0,1)的数，然后除以image的长宽之后，</span></span><br><span class="line">                <span class="comment">// 就会落到一个像素内的随机位置。</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height<span class="number">-1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调用摄像机中封好的函数创造射线。</span></span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                <span class="comment">// 无脑颜色累加即可。</span></span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//最终的绘制颜色代码中，再做最终除法。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漫长等待后我们得到了一个更加“圆润”的球</p>
<p><img src="http://cdn.jsdelivr.net/gh/endlesscollider/imageBed/image-20220307202558937.png" alt="image-20220307202558937"></p>
<p>强大的力量都需要代价，代价就是比原来要多花100倍的时间。但是多次采样是我们渲染效果真实感的保障，并且多次采样在后面还有着更为广泛的应用。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这一节代码在这个场景下我认为是可以优化的，比如我们是没有必要在费物体的边缘做100次的采样，这些地方发射一次又或是多次带回来的结果也没有什么不同，所以这里可以在一个像素内先少量采样，如果它们返回的t值不同，则说明这个像素处于物体交界处，需要多次采样来抗锯齿。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第7节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/28/%E5%85%89%E8%BF%BD1.6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E5%85%89%E8%BF%BD1.6/" class="post-title-link" itemprop="url">从零实现光追渲染（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-28T00:00:00+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 20:42:53" itemprop="dateModified" datetime="2022-03-07T20:42:53+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/02/28/%E5%85%89%E8%BF%BD1.6/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（六）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="物体列表"><a href="#物体列表" class="headerlink" title="物体列表"></a>物体列表</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了物体类，我们可以创建单个物体了，但是如果场景物体非常的多，我们则需要一个数组储存它们，不仅如此我们在进行光线的碰撞检测的时候还需要依次调用它们碰撞函数，并且在创景变化或者程序结束的时候去释放内存等等。所以这些操作放在main函数中是不合适的，所以最好的办法是定义一个类去实现这些操作。创建hittable_list.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针！用它来帮我们管理物体列表，就不用担心内存泄漏问题了！</span></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//当创建物体列表的时候传入了某一个物体，我们直接调用add函数把这个物体加入列表。</span></span><br><span class="line">    	<span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//clear函数调用列表的clear函数清空列表。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    	<span class="comment">//add函数调用push_back把新物体的智能指针加入列表</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//声明我们需要override父类的hit函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//物体列表，使用vector去存每个物体的智能指针。</span></span><br><span class="line">        std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写之后的hit函数。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最开始，把能接受的最远位置设置成外部传进来的t_max。</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个物体做碰撞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line"> 		<span class="comment">//光线射到了这一堆物体里的某一个。</span></span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            <span class="comment">//光线有射中东西，把最终函数的返回值设定为true。</span></span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//光线虽然已经射中了一个东西了，但不确定射中的这个物体是不是离相机最近的。</span></span><br><span class="line">            <span class="comment">//范围缩小，然后继续遍历物体列表。</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每次有新的碰撞，就设定它的record为最终record。</span></span><br><span class="line">            <span class="comment">//遍历完成后，就可以找到最近的碰撞点并返回它的rec。</span></span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回这根光线是否有碰到物体列表中的任何物体。</span></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里面有两个C++非常中要的概念：智能指针和多态</p>
<p>1）智能指针。</p>
<p>C++11给我们提供的瑰宝，它的本质是维护一个指针和一个计数，当创建智能指针并让他指向一个对象的时候，引用计数为1，之后每有一个新的指向它的指针被创建，引用计数加1，一个指针被销毁或者不再指向它，引用计数会下降。引用计数为0则释放对象所占内存。</p>
<p>之前的类我们一直都在“造轮子”，这个物品列表类的作用是管理我们之前做好的“轮子”。通常<strong>C++中用于管理一些对象的类，一般都是通过指针去管理。</strong>对象之间的传输不仅会占据系统栈的内存，还需要付出因拷贝构造而消耗的时间。</p>
<p>况且通过指针管理对象还有另一层作用，那就是“多态”。</p>
<p>2）多态。</p>
<p>继承结构内的多态的一大实现条件就是<strong>基类指针指向子类对象</strong>。这是一个极其经典的场景，我们通过虚函数的重写，再通过基类指针定义某一个接口，在实际程序运行过程中无论来的是哪个子类对象，都可以精确的调到对应的虚函数。</p>
<p>在这个程序中，hit函数是如何完成多态的呢？我们的物品列表类只说明了这个列表里面的东西会是一个物体，即它存的是基类指针，hit函数中我们分别调用了列表中每一个指针指向对象的hit函数的，虽然此时并不知道它到底是个球，或者是其他的什么东西，我们只管调用它，多态会帮我们找到具体到底是那个函数并且调用到它。</p>
<p>把物品列表类设计成了物品类的子类还有更多的好处，举一个只有这样设计才能达成的疯狂的玩法！我们可以在这里进行无限层的嵌套！比如下面的某个物品列表：</p>
<p><em>-物品列表</em></p>
<p><em>-子物品列表1</em></p>
<p><em>-球1</em></p>
<p><em>-球2</em></p>
<p><em>-子物品列表2</em></p>
<p><em>-球3</em></p>
<p><em>-球4</em></p>
<p>现在给最外层的物品列表调用hit函数，我们问这个列表：“这根光线有没有和这一大堆东西碰撞呀，碰撞结果如何啊？”</p>
<p>最外层的列表说：“我给你看看把，我这里有俩玩意，但我不知道这俩玩意是啥，我帮你找他们问问（最外层列表只知道列表中有俩物体，它不知道这些物体到底是啥）”</p>
<p>紧接着程序开始按照名单给这俩小物品列表发消息：“嘿，你们是什么玩意啊？是球吗？我不管你们是不是球，上面发话了，要看看这根光线有没有和你们碰撞，碰撞情况如何啊？我把光线信息和上面要求的t的范围发给你了啊，再给你一个地址，你们俩把record填好啊！我不管了啊！”</p>
<p>好了，俩小物品列表收到消息也急了，它赶忙找它们下面的东西：“嘿！听的到么！我不管你们是谁，老板要求你们把这根光线…….(省略)”</p>
<p>最外层的物品列表只需要维护自己的closest_so_far，比较两个子物品列表给出的t的大小并选择最小的那个，而再下层的东西它完全不用去管。</p>
<p>这叫什么？递归！我们用“物品列表类是物品类的子类”这一设计，实现了一个精美的递归代码帮我们完成一个光线和一堆物品的碰撞。这也多亏了多态的支持。我无法想象如果我们没有多态，实现一个嵌套列表到底要多出几百倍的代码。</p>
<p>我画了一张类图在来帮助理解这部分代码：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1640711858250-599470c8-aca1-45dd-a55e-022902a5ac05.png" alt="img"></p>
<h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><p>现在还需要一些常量数字，比如无穷大。不然我们要怎么传最初始的t_max值呢？我们不能在一开始就限定它为10000，1000之类的。显得很不专业，况且，一些常量和一些换算之后还会有更多作用。我们先把我们能想到的写上，之后需要其他的再添加。</p>
<p>文件取名为rtweekend.h，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTWEEKEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTWEEKEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用C++帮我们定义好的double类型的无限值作为无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> infinity = std::numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="comment">// Π。 我们先把这个东西放在这，虽然暂时还没有什么用。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个角度值转弧度制的函数，嗯。。或许暂时也没有什么用。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="keyword">double</span> degrees)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这俩头文件可是我们的常客，之后用他们就直接包这个rtweekend文件就行了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>在main函数中写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新的光线取色函数中，我们加入了一个名为世界的物体对象，别看它是一个物体对象，我们一般会传入一个物体列表。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">//我们使用到了我们定义的无限大，并且剔除了负t</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">//没错，依然是元气弹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//蓝天...</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创造世界</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入俩个球</span></span><br><span class="line">    <span class="comment">//和以前一样</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    <span class="comment">//一个非常吓人的巨型球！</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机相关</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染循环（render loop）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line">            <span class="comment">//和原来没什么不同，也说明了作者的封装非常完美</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307133434367.png" alt="image-20220307133434367"></p>
<p>于是我们得到了在一片草原之上的元气弹，实际上只是球体所在位置及其表面法线的可视化。这通常是查看模型缺陷和特征的好方法。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第6.5节到第6.7节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/26/%E5%85%89%E8%BF%BD1.5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/26/%E5%85%89%E8%BF%BD1.5/" class="post-title-link" itemprop="url">从零实现光追渲染（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-26T00:00:00+08:00">2022-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 20:41:24" itemprop="dateModified" datetime="2022-03-07T20:41:24+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/02/26/%E5%85%89%E8%BF%BD1.5/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（五）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="物体类"><a href="#物体类" class="headerlink" title="物体类"></a>物体类</h1><h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>首先可以简化一些不必要的常数项，聊胜于无的优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="comment">//默认直接把2除掉</span></span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">    <span class="comment">//这个discriminant是之前的四分之一。</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//分子分母都是简化前的一半。</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (-half_b - <span class="built_in">sqrt</span>(discriminant) ) / a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>现在有了球，或许需要一个球类去描述它，但是未来可能还会有更多的其他种类的物体，最容易想到的方法是首先编写一个物体基类。</p>
<p>这个抽象基类需要抽象出所有物体的共性：</p>
<p>一个物体一定可以被光线感知到，它可以被光线照到，并且光线可以通过这次碰撞获取一些关于物体的信息。即，它需要一个抽象的<strong>碰撞函数</strong>，就和我们之前在main所在文件中写的球简易碰撞函数那样。这个函数的返回值设计成bool，即返回是否碰撞到。至于其他的碰撞信息，我们可以通过一个结构体返回，其中包括：</p>
<ol>
<li><strong>t值</strong>。除了判断t值可以确定是否碰撞到物体，t值在之后会有更大的作用，可以说，<strong>t值是光线和物体碰撞中最重要的信息之一，</strong>应当让外界知道这个值以方便其他的运算。</li>
<li><strong>法线</strong>。前面的元气弹就是使用了法线实现的效果，但是这还不是全部，法线的作用还有很多，比如镜面反射，比如通过法线去计算反射方向。总之，我们需要返回法线信息。</li>
<li><strong>碰撞点坐标</strong>。很多情况下都需要用到p点坐标，我们不希望每次用到的时候都去计算一遍，而且我们理应把这些计算放在更底层的地方，而且我们也不应该把这种底层计算放在用户看得到的地方。</li>
</ol>
<p>创建hittable.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把需要返回的数据封装成结构体，按照上面分析的，暂时我们需要这三个东西。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可碰撞物体类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//需要这样一个纯虚函数，所有继承自这个类的子类（如球），都需要实现这个函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在类中多了两个参数，分别为允许t的最小、最大值，有了它我们就可以剔除t小于0的情况（即物体在相机后后面的情况），同时它还有更多的用处。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于这个物体类来实现球类的代码，创建sphere.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//构造</span></span><br><span class="line">        <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">sphere</span>(point3 cen, <span class="keyword">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//声明要override纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//老代码</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发现方程没有根，直接退出。</span></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为我们引入了tmax和tmin，所以这里还需要格外的运算。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查较小的根</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        <span class="comment">//检查较大的根</span></span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封入结构体</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">//不用麻烦使用unit_vector函数，直接利用已经存好的半径进行单位化，实现加速。</span></span><br><span class="line">    rec.normal = (rec.p - center) / radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第40行开始的if语句非常的巧妙，因为只有在较小的根不满足<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/d87a46ba28d0db64bb2642603c553fba.svg" alt="img">的时候，才会检查较大的根，换句话说，如果较小的根在我们的许可范围内，我们会直接采纳他。一般来说，较小的根是光线和物体的首次交汇点，所以优先返回较小根是非常合理的。</p>
<p>那么什么场景才能用到较大的根呢？非常明显，是相机在物体的里面的时候，但这种情况也会导致之前计算的法线方向相反，接下来就来解决它。</p>
<h2 id="法线修正"><a href="#法线修正" class="headerlink" title="法线修正"></a>法线修正</h2><p>通过什么方式判断法线是否反了呢？可以注意到的是，法线与入射光线的夹角一定小于90度的，所以可以使用向量的点乘来进行判断，并且这部分判断可以直接放在hit_record内，同时在碰撞函数中调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//光线打到的是不是物体的外面？</span></span><br><span class="line">    <span class="keyword">bool</span> front_face;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个结构体内的函数，他判断法线的里外，并且在光线打到物体内面时取反法线。</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sphere.h中修改hit函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用这一个函数设置hit_record中的法线和front_face</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第6.2节到第6.4节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/25/%E5%85%89%E8%BF%BD1.4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/%E5%85%89%E8%BF%BD1.4/" class="post-title-link" itemprop="url">从零实现光追渲染（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-25T00:00:00+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 12:43:56" itemprop="dateModified" datetime="2022-03-07T12:43:56+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/02/25/%E5%85%89%E8%BF%BD1.4/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（四）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="球"><a href="#球" class="headerlink" title="球"></a>球</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>接下来总要让一个对象让光线碰撞，这里选择使用最简单的物体：球<br>$$<br>X^2+Y^2+Z^2=R^2<br>$$<br>一个非常标准的球的数学表达式，这个公式表示以原点为球心，半径是R的球。所有坐标是（x,y,z）的点满足上面的表达式<strong>都在球上</strong>。接下来是点在球内和求外的公式：</p>
<p>$$<br>X^2+Y^2+Z^2&lt;R^2<br>$$</p>
<p>$$<br>X^2+Y^2+Z^2&gt;R^2<br>$$</p>
<p>假定球心为$(C_x,C_y,C_z)$<br>$$<br>(x-C_x)^2+(y-C_y)^2+(z-C_z)^2=r^2<br>$$<br>但是这个公式没有办法在我们的项目中使用，我们的底层使用的vec3类，更希望看到向量而不是标量表示，我们需要简单的改变一下这个公式。现在假设球形所在的坐标用<strong>C</strong>这个vec3类常量表示，即$C=(C_x,C_y,C_z)$。同样的令$P=(x,y,z)$有：<br>$$<br>(P-C)\cdot(P-C)=(x-C_x)^2+(y-C_y)^2+(z-C_z)^2<br>$$<br>上述式子的左侧是一个向量模的平方，右侧是一个距离公式。它们都表示P点和C点之间的距离的平方。所以有：</p>
<p>$$<br>(P-C)(P-C)=r^2<br>$$<br>所有满足这样要求的<strong>P</strong>——它到<strong>C</strong>点的距离为r，这样的点一定在以<strong>C</strong>为球心，r为半径的球上。</p>
<p>现在引入光线，如果光线曾在某一个时刻打在球上，则表示有一个t，使得$P(t)=A+tb$正好传播到了球的位置。带入它之后：<br>$$<br>(P(t)-C)\cdot(P(t)-C)=r^2<br>$$<br>展开：<br>$$<br>(A+tb-C)\cdot(A+tb-C)=r^2<br>$$<br>把左侧括号乘开，这里我们把$(A-C)$看作一个整体，再把右侧的移$r^2$到左侧。<br>$$<br>t^2b\cdot b+2tb\cdot(A-C)+(A-C)\cdot(A-C)-r^2 =0<br>$$<br>变成了一个t的一元二次方程。（b表示光线方向，A是光源位置，C是球心，全是常量）。</p>
<p><img src="https://s2.loli.net/2022/03/06/VImPT4rJxWjOvKF.png"></p>
<h2 id="碰撞函数"><a href="#碰撞函数" class="headerlink" title="碰撞函数"></a>碰撞函数</h2><p>在.cpp文件中main函数外写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简易的球的碰撞检测函数，吃球心，半径和一根光线，吐出光线是否击中球的bool值。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个oc就是上面函数里的(A-C).</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="comment">// 对应上面公式里的b的平方。即平方项的系数。</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 对应上面公式里的2*(A-C)点乘b，即一次项的系数</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// (A-C)点乘(A-C)减去r的平方，即常数项。</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="comment">//高中最爱的Δ，b的平方减4ac。</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="comment">//返回方程有没有根，即光线有没有碰撞到球体。</span></span><br><span class="line">    <span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果我们击中了这个球心在(0,0,1)且半径是0.5的球，就直接返回颜色为红色。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果没有击中的话你就继续画蓝天吧。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得到了一个不那么美丽的太阳！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223618931.png" alt="image-20220306223618931"></p>
<h2 id="可视化法线"><a href="#可视化法线" class="headerlink" title="可视化法线"></a>可视化法线</h2><p>如果我们得知光线和球的碰撞点为P，我们需要得到这一点的法线，它应该是从球心发射，穿过这一点指向球的外侧，所以是<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/3c59ca980a313e3ab91bf87f5db239c0.svg" alt="img">。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223737173.png" alt="image-20220306223737173"></p>
<p>这里需要考虑两个问题：</p>
<ul>
<li>它应该是单位向量吗？是的，它应该是，单位化法线可能会在某些方面为我们的渲染提供便利，但是不强制，并不要求法线一定是单位向量，如果必须是单位化的地方我们进行单位化即可。为了省去这一步骤这里选择永远单位化它。</li>
<li>之前我们给的hit_sphere函数的框架已经不足以满足我们获取法线的需要了，因为这里不仅仅需要了解球和光线是否碰撞，我们还得知道光线和球的第一个焦点的位置，因为只要不是极端的相切的情况，我们总能找到两个焦点，所以我们需要t较小的那个焦点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它不再返回bool，而是返回一个浮点数，表示光线第一次打在球上的时候的时间t。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Δ小于0，别看了，光线没打到球，直接返回一个负值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 求根公式，我们返回了较小的那个根。</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过得到的法线返回颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//如果光线击中了球。</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    	<span class="comment">//拿到法线，嘿嘿，我们之前写过很久的at函数终于派上用场了。我们这次单位化它。</span></span><br><span class="line">        vec3 N = <span class="built_in">unit_vector</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//返回法线可视化之后的颜色值，注意我们做了一个[-1,1]到[0,1]的映射。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*<span class="built_in">color</span>(N.<span class="built_in">x</span>()+<span class="number">1</span>, N.<span class="built_in">y</span>()+<span class="number">1</span>, N.<span class="built_in">z</span>()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没打中？继续画蓝天吧。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将hit_shpere函数的返回值由bool改为第一次碰撞的时间t，并在取色函数中通过时间t获取碰撞点，并计算出法线，最后将法线映射为颜色，最终我们可以看到一个元气弹！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307085406164.png" alt="image-20220307085406164"></p>
<h2 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h2><ol>
<li>在红太阳阶段的代码中如果将太阳放在相机后面会发生什么呢？</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223618931.png" alt="image-20220306223618931"></p>
<p>可以看到与放在相机前没有任何变化，我认为是主要是因为这段代码虽然判断了碰撞函数是否有解，但是忽略了t小于0 的情况，以至于放在相机前后没有区别，用第二段代码就没有任何问题。</p>
<ol start="2">
<li>元气弹的颜色遵循什么规律呢？</li>
</ol>
<p>按照代码逻辑应该是碰撞法线x,y,z分量分别对应r,g,b的值。那么应该是向右越来越红，向上越来越绿，由中心向外越来越蓝。</p>
<ol start="3">
<li>使用元气弹版本的代码，更改hit_sphere函数，这次返回较大的那个根，生成图片另外保存。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求根公式，这次返回较大的那个根。</span></span><br><span class="line"><span class="keyword">return</span> (-b + <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307092334496.png" alt="image-20220307092334496"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第5节和第6.1节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/23/%E5%85%89%E8%BF%BD1.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/%E5%85%89%E8%BF%BD1.3/" class="post-title-link" itemprop="url">从零实现光追渲染（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-23T00:00:00+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 12:43:44" itemprop="dateModified" datetime="2022-03-07T12:43:44+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/02/23/%E5%85%89%E8%BF%BD1.3/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（三）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="光线、相机与天空"><a href="#光线、相机与天空" class="headerlink" title="光线、相机与天空"></a>光线、相机与天空</h1><h2 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h2><p>如何将抽象的光线具体的表现出来并不困难，在初中物理的时候我们就使用一个点加上一个射线的方式来表示光线，于是我们可以用这样的公式描述它：<code>P(t)=A+t*b</code></p>
<p><img src="https://s2.loli.net/2022/03/05/s71P5mzYDjenywC.png" alt="image.png"></p>
<p><strong>A</strong>表示光线的原点（光源位置），<strong>b</strong>为一个单位向量表示一个方向，t则表示单位时间，通过给t取不同的值，我们可以得到沿路上所有的点的三维坐标，当然，这个值一般来说不会为负数，我们新建ray.h，输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//空构造。</span></span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//带参构造，显然我们需要一个原点和一个方向。</span></span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//通过这个函数拿取原点值。</span></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">		<span class="comment">//通过这个函数拿取方向值。</span></span><br><span class="line">    	<span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//这个函数就对应了上方数学公式中的P(t)，通过传入一个时间t，能得到当前光线传播到的坐标位置。</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>我们把“相机”固定在一个位置，并且固定一下它观察的方向。</p>
<p>接下来需要解决两个问题：</p>
<ol>
<li>光线从哪里射出呢？相机位置。按照常理来说，太阳发出的光线从物体上弹射了多次，最终会被摄像机（或者人眼）捕捉。相机位置应该是光线的终点才对啊，怎么会是起点呢？<strong>原因是我们需要逆光路取色，这是路径追踪的经典光线模型，重点是我们的光线和现实中的光线是反过来的，如果正向光路进行光线追踪会极其困难，几乎寸步难行。</strong></li>
<li>光线朝哪个方向射出呢？这就要引出一个“虚拟视口”的概念。它就像一个相框，摆在相机的前面，相机发射的密集光铺满相框，就得到图像，具体方法为：<strong>按照行优先的顺序，从左上角开始，一排一排的射出光线，射出光线的数目就是像素的数目，换句话说，我们对每一个像素都会射出一根光线</strong>。</li>
</ol>
<p>将相机位置定位（0，0，0）这个场景是这样的：</p>
<p><img src="https://s2.loli.net/2022/03/05/qhcP98ZAYve1SCt.png" alt="image.png"></p>
<p>假设图中的虚拟视口上有800个像素，每个像素长宽都是0.1，最终得到一张40*20的图片，我们只需要瞄准<strong>每一个像素的中心</strong>。</p>
<p>按照行优先左上角开始，发生的第一根光线应该是从（0，0，0）射向（-2+0.05，1-0.05，-1）方向。不必要求这个方向向量是一个单位向量，保持方向向量是单位向量并不能给项目提供更多便利。如此类推：第二个是（-2+0.15，1-0.05，-1）方向、第四十个是（-2+3.95，1-0.05，-1）方向、第八百个是（-2+3.95，1-1.95，-1）方向。</p>
<p>改写main函数，并且为其所在的文件添加一个全局函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个简单的决定光线所带回颜色的函数。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先把这个光线的方向向量单位化。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再根据这个单位化向量的y分量给他设定颜色，得保证t在[0,1]之间。</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 插值函数，t靠近0它就越靠近白色，越靠近1它就越靠近一种蓝色。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//图片数据，这次我们换一种角度去定义图片的长宽，我们定义一个长宽比，再把它的宽度定义出来。</span></span><br><span class="line">    <span class="comment">//长度就可以通过简单的计算得到。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟视口数据，我们保持它的高度（宽度）为2，长度同样通过长宽比得到。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//保持视口和实际图片的长宽比一致。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height; </span><br><span class="line">    <span class="comment">//这是视口离相机的距离，保持为1就好，我们暂时把它写死。</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相机位置</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//相机水平方向，即X轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//相机头顶方向，即Y轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个是虚拟视口左下角所在位置的坐标，在上面那个图片例子里，它就是（-2，-1，-1）。</span></span><br><span class="line">    <span class="comment">//注意因为长宽比不是2/1而是16/9，所以本例子里这个值和图片中的值不同。</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环（render loop）</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//这个uv就是当前像素位置的横纵坐标偏移。</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//创造射线。</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            <span class="comment">//通过全局函数取到本像素颜色。</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="comment">//写颜色到输出流。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/05/qt3BYcAd9NI5kvS.png" alt="image.png"></p>
<p>通过光线在y轴方向上的分量得到一种类似于蓝天的效果，这个图片也将在后来成为我们的背景。</p>
<h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><p>1：循环渲染射出光线瞄准的是哪里呢？仔细计算可以发现，是每个像素的左上角，并不是中心点，其实左上角又或是中心点这一点的颜色都不能代表整个像素的颜色，这个问题后续将会解决。</p>
<p>2：更改ray_color函数可以制作一些更加炫酷的背景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec = r.<span class="built_in">direction</span>() * <span class="number">1</span> - r.<span class="built_in">origin</span>(); </span><br><span class="line">    <span class="keyword">auto</span> absVec = <span class="built_in">vec3</span>(std::<span class="built_in">abs</span>(vec.<span class="built_in">x</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">y</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unit_vector</span>(absVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/05/OVRxAhGDbnywlYm.png" alt="image.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第4节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/21/%E5%85%89%E8%BF%BD1.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/%E5%85%89%E8%BF%BD1.2/" class="post-title-link" itemprop="url">从零实现光追渲染（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T00:00:00+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 12:43:37" itemprop="dateModified" datetime="2022-03-07T12:43:37+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/02/21/%E5%85%89%E8%BF%BD1.2/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（二）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="点、向量、颜色"><a href="#点、向量、颜色" class="headerlink" title="点、向量、颜色"></a>点、向量、颜色</h1><p>既然是光追，肯定离不开点和方向于颜色，在大多数工程中，颜色和方向是四维的向量，但是对于这个工程，三位向量可以满足需求，我们定义一个类来表示它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止被重复引用，用ifndef去包裹所有代码。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要一些cmath类里面的数学函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精确引用，只需要开方函数就只引入最小的命名空间</span></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 空构造，默认构造一个（0，0，0）向量</span></span><br><span class="line">        <span class="built_in">vec3</span>() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 传入三个参数的构造。</span></span><br><span class="line">        <span class="built_in">vec3</span>(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义x，y，z分量。这样就可以用 向量.x() 直接拿取x分量。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//下面进行运算符重载。</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//单目 &#x27;-&#x27; 运算符 ，会对三维向量的每一维取反。</span></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符的const版本，返回右值。</span></span><br><span class="line">    	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符普通版本，返回左值</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;+=&#x27;运算符，const保护参数不被修改，返回引用允许操作符嵌套。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// &#x27;*=&#x27;运算符</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;/=&#x27;运算符，直接使用*=去定义&#x27;/=&#x27;。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//模相关。</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 模的平方。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 模</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 向量中的数组也直接暴露出去了，这里是float也没问题，看你的喜好。</span></span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给vec3类多起几个名字。</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point，在指定三维空间中的点的时候使用这种别名。</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color，在指定颜色的时候使用这种别名。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="类外补充"><a href="#类外补充" class="headerlink" title="类外补充"></a>类外补充</h2><p>接下来是一些加减乘除等操作，其中的有些操作并不可以写在类内，比如double类型<code>*</code>vec3类型，所以统一写在类外：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vec3 类外函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出流符号&quot;&lt;&lt;&quot;</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123; </span><br><span class="line">    <span class="comment">//当用户使用 cout &lt;&lt; vec3的时候，输出vec3中的各个分量值。</span></span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符，它的返回值不是引用，这很合理，我们永远不会把 “a + b”这样的东西放在赋值符号左侧</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，向量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，标量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还是*运算符，但这次参数中标量和向量的顺序是反过来的。</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用*去定义/</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量点乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量叉乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单位化这个向量，就是把它的各个分量除以它的长度，正好，我们可以用上面刚刚写完的/运算符去定义它。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽离与简化"><a href="#抽离与简化" class="headerlink" title="抽离与简化"></a>抽离与简化</h2><p>在第一章时，有三行将0-1的通道映射到0-255的代码，这部分代码是固定的，可以统一将它们抽离出去，创建、<code>color.h</code>文件，以后的关于渲染颜色的代码统一放到这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个全局的函数，接受一个输出流参数，和一个color参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把之前的代码两步并作一步，直接转到[0,255]区间然后直接输出出去。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来main函数的代码将相当简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//直接调用vec3类有参构造构造一个对象</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写颜色！如此的简单！</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第3节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/19/%E5%85%89%E8%BF%BD1.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" class="post-title-link" itemprop="url">从零实现光追渲染（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-19T00:00:00+08:00">2022-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 12:42:13" itemprop="dateModified" datetime="2022-03-07T12:42:13+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" itemprop="url" rel="index"><span itemprop="name">光线追踪</span></a>
                </span>
            </span>

          
            <span id="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" class="post-meta-item leancloud_visitors" data-flag-title="从零实现光追渲染（一）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前言：</strong>前段时间在学习C++ primer的同时，我还有幸接触到了一本非常有趣的书，它通过我们的vs写出的代码直接模拟光线追踪生成图像。地址：<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a>。它非常的有趣也具有很高的学习价值，所以我想把学习的过程记录下来，也欢迎大家来一起学习并找出其中的错误，废话不多说，直接开始！</p>
<h1 id="生成第一张图片"><a href="#生成第一张图片" class="headerlink" title="生成第一张图片"></a>生成第一张图片</h1><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>首先明确我们这里使用的是ppm格式的图片格式，它是通过类似于<code>vector&lt;vector&lt;int&gt;&gt;</code>的方式记录下每个色素的RGB值。</p>
<p><img src="https://s2.loli.net/2022/03/04/enLDpxsbyNRazIu.png" alt="image.png"></p>
<p>此外在开头还需要做一些说明：</p>
<ul>
<li>P3#代表颜色使用ASCII码表示</li>
<li>3 2#代表3行两列，它使得我们接下来的数字不需要按照行列摆放工整，而是可以</li>
<li>255#表示使用0-255来表示一个通道的颜色</li>
</ul>
<p>可以试着通过代码来生成一张这样的图片：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义图片的宽度和高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印ppm文件的开头</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以左下角为原点，从左上方依次打印像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//将r和g通道控制在0-1内</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line">			<span class="comment">//之后统一将它们映射到0-255</span></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">			<span class="comment">//依次输出rgb，注意中间空格</span></span><br><span class="line">            std::cout &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码之后，我们以release方式运行，之所以不选择debug模式，主要还是因为太耗费时间，在保证代码不出现错误的情况下，使用release可以节省一些时间。</p>
<p><img src="https://s2.loli.net/2022/03/04/RCEOVqXUlxdi9TI.png" alt="image.png"></p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>以上代码只能让信息输出到控制台，而我们希望将其输出到一个文件内，所以我们可以使用命令行实现：</p>
<ul>
<li>打开命令行输入项目所在硬盘加冒号之后回车，如：<code>D:</code></li>
<li>接着输入，cd+空格+项目文件下的release文件夹地址后回车，如：<code>cd D:\C++\RayTracing\x64\Release</code>同时还要注意是X86还是X64。</li>
<li>之后输入<code>raycast.exe &gt; image.ppm</code>，raycast.exe为我们的程序，使用<code>&gt;</code>重定向将数据输出到文件名为image1.1的文件中，同时指定文件格式为ppm</li>
</ul>
<p>最后依次回车之后我们就可以在release文件夹下看到一个image的图片文件，如果打不开，可以下载一个极速看图软件。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220304224339897.png" alt="image-20220304224339897"></p>
<p>一张非常绚丽的图，正如我们代码中的那样，从左到右越来越红，从下到上越来越绿。</p>
<h2 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h2><p>现在我们并不知道图片能够多久加载完成，当所需要的图片像素点非常多时，这个问题会更加明显，所以我们使用std::cerr来显式加载的进度，它主要用于显示错误消息，且不被缓冲，可以发送到显示器，并且不被重定向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 提示还有多少行数据没有处理完。</span></span><br><span class="line">       std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提示已经完全搞定。</span></span><br><span class="line">   std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>同时使用“\r”可以把光标强行移回本行开头，这样这次输出的内容就会覆盖掉这一行原本的内容，就好像每次到来的新东西会“冲洗”掉之前输出的东西。</p>
<p>注意这一行的结尾是std::flush，它表示再输出完这一行之后，会强行把内存中缓冲区内的数据打出到错误输出流里（清空缓冲区）。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sss_0916/article/details/95622404?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5.pc_relevant_default&spm=1001.2101.3001.4242.4&utm_relevant_index=8">endl、ends和flush的区别</a></p>
<p>再次使用命令行就可以看到</p>
<p><img src="https://s2.loli.net/2022/03/04/hHqw6jYGFof7dPX.png" alt="image.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第2节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十六章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-15T00:00:00+08:00">2022-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:42" itemprop="dateModified" datetime="2022-03-04T12:58:42+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
            <span id="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="C++ Primer 第十六章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> string&amp; v1, <span class="keyword">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl &lt; v2) <span class="keyword">return</span> -l; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; v1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于像这样除了类型意外一模一样的函数，我们可以使用模板来适配各种各样的类型。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板，而不是为每一个类型定义一个新的函数。则compare的模板可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; vl) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板定义以关键字template开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(&lt;)和大于号(&gt;）包围起来。</p>
<p><strong>在模板定义中,模板参数列表不能为空。</strong></p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>调用一个函数模板时，编译器用函数的实参来推断模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt; endl; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>

<p>编译会推断出实参int，并绑定到T，这样推断出来的为我们<strong>实例化</strong>一个特定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T为int</span></span><br><span class="line"><span class="comment">//实例化出int compare (const vector&lt;int&gt;&amp;,const vector&lt;int&gt;&amp;)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;, vec2&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1, vec2) &lt;&lt;endl; <span class="comment">// T为vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里编译器会实例化两个不同版本的compare。其中一个T为int，另一个T为vector<int>，编译器生成的版本成为模板的实例。</p>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>我们的compare函数有一个模板类型参数(type parameter)。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:返回类型和参数类型相同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">Tfoo</span> (T* p)&#123;</span><br><span class="line">	T tmp = *p; <span class="comment">// tmp 的类型将是指针p指向的类型/ / ...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数前必须使用关键字class或typename:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:U之前必须加上class或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;)</span> </span>;</span><br><span class="line"><span class="comment">//正确:在模板参数列表中,typename和class没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="built_in">calc</span> (<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;) ;</span><br></pre></td></tr></table></figure>

<p>因为可以使用非类的类型作为模板实参，所以使用typename更为直观。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了模板参数，我们还可以定义非类型参数，简言之就是一个固定的值，当模板被实例化后，非类型模板参数就被这个值所取代，这个值也必须时常量表达式，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span> (p1, p2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span> ( <span class="string">&quot;hi&quot;</span>, <span class="string">&#x27;mom&quot;)</span></span><br></pre></td></tr></table></figure>

<p>最后编译器使用字面常量大小代替N和M：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1) [<span class="number">3</span>],<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。</p>
<p>通常在需要常量表达式的地方需要用到此参数。</p>
<h4 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:inline说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误:inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>通过const＋引用的方式，我们保证了函数可以用于不能拷贝的类型。</p>
<p>此外，我们没必要即使用<code>&lt;</code>又使用<code>&gt;</code>运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//期望的比较操作</span></span><br><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -l;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//即使用于指针也正确的compare版本;参见14.8.2节（第510页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">( less&lt;T&gt;()(vl, v2))</span> <span class="keyword">return</span> -1</span>;</span><br><span class="line"><span class="keyword">if</span> ( less&lt;T&gt;() (v2, v1)) <span class="keyword">return</span> l;<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的（据查阅资料，less<T>的默认实现用的就是&lt;，所以这其实并未起到让这种比较有一个良好定义的作用—译者注)。</p>
<p><strong>模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>编译器遇到模板时，只有当实例化除模板特例时，才会生成代码。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同:为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>关键概念:模板和头文件</strong></p>
<p>模板包含两种名字:</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p>当使用模板时,所有不依赖于模板参数的名字都必须是可见的,这是由模板的提供者来保证的。而且,模板的提供者必须保证，当模板被实例化时,模板的定义,包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件,包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件,以及用来实例化模板的任何类型的头文件。</p>
<h4 id="实例化器件错误报告"><a href="#实例化器件错误报告" class="headerlink" title="实例化器件错误报告"></a>实例化器件错误报告</h4><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<p>例如原始版本的<code>if (vl &lt; v2) return -l;//要求类型T的对象支持&lt;操作</code>其中如果调用者传入类型没有<code>&lt;</code>运算符，则会在第三个阶段报错。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板是用来蓝图的，编译器不能为类推断参数类型。必须在尖括号中提供额外的信息，用来代替参数的模板实参列表。</p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>我们实现StrBlib的模板版本，为Bolb，不在针对string，使用时用户需要指出元素类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t ypedef T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;T&gt; : :size_type size_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: : initializer_list&lt;T&gt; il);</span><br><span class="line">	<span class="comment">// Blob中的元素数目</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="comment">//移动版本，参见13.6.3节（第484页)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std : : <span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (size_type i); <span class="comment">// 在14.5节(第501页)中定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: : shared ptr&lt;std : : vector&lt;T&gt;&gt; data;<span class="comment">//若data[i]无效，则抛出msg</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std: :string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例如，我们将元素访问操作的返回类型定义为T&amp;。当用户实例化Blob时，T就会被替换为特定的模板实参类型。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>使用类模板时，提供额外信息，这些信息实际上是显示模板实参列表，它们被绑定到模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;					<span class="comment">//空Blob&lt;int&gt;</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; 	<span class="comment">//有5个元素的Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是编译器生成一个类似这样的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;<span class="keyword">int</span>&gt;: :size_type size_type; </span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: :initializer_list&lt;<span class="keyword">int</span>&gt; il); <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: :shared ptr&lt;std: :vector&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std : : string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联,也不会对任何其他B1ob类型的成员有特殊访问权限。</strong></p>
<h4 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h4><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的data 成员使用了两个模板，vector和 shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是Blob的模板参数。因此，data的定义如下:</p>
<p><code>std: :shared_ ptr&lt;std: : vector&lt;T&gt;&gt; data;</code></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</p>
<p>当我们定义一个成员函数时，模板实参与模板形参相同。对于strBlob的一个给定的成员函数</p>
<p><code>ret-type StrBlob : : member-name(parm-list)</code></p>
<p>对应的Blob的成员应该是这样的:</p>
<p><code>template &lt;typename T&gt; ret-type Blob&lt;T&gt;: :member-name(parm-list)</code></p>
<h4 id="check和元素访问成员"><a href="#check和元素访问成员" class="headerlink" title="check和元素访问成员"></a>check和元素访问成员</h4><p>我们首先定义check成员，它检查一个给定的索引:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">check</span>(size_type i,<span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;=data-&gt;<span class="built_in">size</span> ())</span><br><span class="line">		<span class="keyword">throw</span> std: :<span class="built_in">out_of_range</span>(msg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用模板参数指出返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;: : <span class="built_in">back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>); <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt; : : <span class="keyword">operator</span>[](size_type i) &#123;</span><br><span class="line">	<span class="comment">//如果i太大，check会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    <span class="built_in">check</span> (i, <span class="string">&quot;subscript out of range&quot;</span> ) ;</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pop_back函数与原StrBlob的成员几乎相同:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Blob构造函数"><a href="#Blob构造函数" class="headerlink" title="Blob构造函数"></a>Blob构造函数</h4><p>与类模板外函数一样，构造函数先定义模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span> (std: :make_shared&lt;std: :vector&lt;T&gt;&gt;())&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>分配一个空vcector，并将指向vector的指针保存在data中，还要有接受一个initializer_list参数的构造函数将其类型参数工作为initializer list参数的元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std: :initializer_list&lt;T&gt; il):</span><br><span class="line">			<span class="built_in">data</span>(std: :make_shared&lt;std: :vector&lt;T&gt;&gt;(il))&#123; &#125;	</span><br></pre></td></tr></table></figure>

<p>为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob的元素类型兼容:</p>
<p><code>Blob&lt;string&gt; articles = &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot; &#125;;</code></p>
<h4 id="类模板成员的实例化"><a href="#类模板成员的实例化" class="headerlink" title="类模板成员的实例化"></a>类模板成员的实例化</h4><p>只有当程序用到它时才会进行实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; squares = &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt; : :size ( ) const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != squares.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	squares[i] = i*i;<span class="comment">//实例化Blob&lt;int&gt; : : operator[] (size_t)</span></span><br></pre></td></tr></table></figure>

<p>实例化了 Blob<int>类和它的三个成员函数: operator[ ] 、 size和接受initializer_list<int>的构造函数。</p>
<p><strong>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
<h4 id="在类内简化模板类名"><a href="#在类内简化模板类名" class="headerlink" title="在类内简化模板类名"></a>在类内简化模板类名</h4><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若试图访问一个不存在的元素，BlobPtr抛出一个异常template &lt;typename T&gt; class BlobPtr &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, <span class="keyword">size_t</span> sz - <span class="number">0</span>):</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; </span><br><span class="line">        <span class="comment">// (*p)为本对象指向的vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递增和递减</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置运算符</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--( );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check 返回一个指向vector的shared_ptr</span></span><br><span class="line">	std: :shared_ptr&lt;std: :vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std : : <span class="keyword">size_t</span>, <span class="keyword">const</span> std : : string&amp;) <span class="keyword">const</span>; </span><br><span class="line">	<span class="comment">// 保存一个weak ptr，表示底层vector可能被销毁</span></span><br><span class="line">	std : : weak_ptr&lt;std : : vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std : : <span class="keyword">size_t</span> curr; <span class="comment">//数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在递增和递减函数中，我们返回的是BlobPtr&amp;，而不使用BlobPtr<T>&amp;，因为当处于一个类模板的作用域时，自身引用时就等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>

<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>由于在类外，只有遇到类名才代表进入类的作用域，所以类外函数返回自身需要使用BlobPtr<T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置:递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;: :<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查;调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//保存当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>;<span class="comment">//推进一个元素;前置++检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数体已经进入类内，所以可以直接使用BlobPtr。</p>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</strong></p>
<h4 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h4><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<h4 id="一对一友好关系"><a href="#一对一友好关系" class="headerlink" title="一对一友好关系"></a>一对一友好关系</h4><p>我们的Blob类应该将BlobPtr类和模板版本的Blob相等运算符定义为友元，此外我们在Blob加入可以用==运算符的友元函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在 Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span><span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;); </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">		(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">	<span class="comment">//其他成员定义，与12.1.1（第405页）相同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里在Blob类中出现的5个T，说明它将对应的类与函数声明为友元，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;<span class="comment">// BlobPtr&lt;char&gt;和operator==&lt;char&gt;都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;<span class="comment">// BlobPtr&lt;int&gt;和operator==&lt;int&gt;都是本对象的友元</span></span><br></pre></td></tr></table></figure>

<h4 id="通过和特定的模板友好关系"><a href="#通过和特定的模板友好关系" class="headerlink" title="通过和特定的模板友好关系"></a>通过和特定的模板友好关系</h4><p>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> &#123;</span><span class="comment">//C是一个普通的非模板类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;<span class="comment">//用类c实例化的Pal是c的一个友元/l Pal2的所有实例都是c的友元;这种情况无须前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">c2</span> &#123;</span><span class="comment">// C2本身是一个类模板</span></span><br><span class="line">	<span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;; <span class="comment">// Pal的模板声明必须在作用域之内</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> x&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">	<span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span><span class="comment">//不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
<h4 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Type; <span class="comment">//将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成为Bar<Foo>的友元，sales data将成为Bar<Sales data>的友元，依此类推。</p>
<h4 id="模板的类型别名"><a href="#模板的类型别名" class="headerlink" title="模板的类型别名"></a>模板的类型别名</h4><p>可以给已经实例化的类起别名：<code>typedef Blob&lt;string&gt; StrBlob;</code>模板起别名的方式为则不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以固定多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">// books是一个pair&lt;string,unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars是一个pair&lt;Vehicle,unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids是一个pair&lt;Student,unsigned&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>类模板也可以声明static成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> std: :<span class="function"><span class="keyword">size_t</span> <span class="title">count</span> <span class="params">()</span></span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">//其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> std: : <span class="keyword">size_t</span> ctr;<span class="comment">//其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的static成员会在同一个类型内共享，如Foo<X>这个类型的所有对象，共享这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化static成员Foo&lt;string&gt; ::ctr和Foo&lt;string&gt; : :count</span></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line"><span class="comment">//所有三个对象共享相同的Foo&lt;int&gt; : :ctr和Foo&lt;int&gt; : : count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2,fi3;</span><br></pre></td></tr></table></figure>

<p>数据成员也同样如此，且必须有且仅有一个定义，所有该特定类的对象共享此成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt; : : ctr = <span class="number">0</span>; <span class="comment">//定义并初始化ctr</span></span><br></pre></td></tr></table></figure>

<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问static成员，我们必须引用一个特定的实例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;						<span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">count</span> () ;	 <span class="comment">//实例化Foo&lt;int&gt; ; :count</span></span><br><span class="line">ct = fi.<span class="built_in">count</span> ();					<span class="comment">//使用Foo&lt;int&gt; : : count</span></span><br><span class="line">ct= Foo: :<span class="built_in">count</span> ();					<span class="comment">//错误:使用哪个模板实例的count?</span></span><br></pre></td></tr></table></figure>

<p>static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板参数的名字不仅可以是T还可以是其他任何命名。</p>
<h4 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h4><p>一个模板参数可用范围是在其声明之后，至模板声明或定义结束之前。与其他任何名字一样的是模板参数隐藏外层作用域声明的相同的名字，不同的是，在模板内不能重用模板参数名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a,B b)</span></span></span><br><span class="line"><span class="function">	A tmp </span>= a;<span class="comment">// tmp的类型为模板参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;<span class="comment">//错误:重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于模板名字不能重用，所以在模板参数列表也只能出现一次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:非法重用模板参数名v</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> v, <span class="keyword">typename</span> v&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>模板的声明必须包括模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明但不定义compare和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
<h4 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h4><p>由于使用：：运算符在模板参数上就会有困难，如：T：：men，它不知道men声明类型成员和static数据成员，所以必须知道这个T是否表示一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>如果希望使用一个类型成员就必须显示使用typename关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p><strong>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用 class。</strong></p>
<h4 id="默认的模板实参"><a href="#默认的模板实参" class="headerlink" title="默认的模板实参"></a>默认的模板实参</h4><p>就像函数的默认实参一样，我们也可以为模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2，Ff = <span class="built_in">F</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(vl, v2) ) <span class="keyword">return</span> -l;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户调用时，可以自己提供，也可以使用默认的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = <span class="built_in">compare</span> (<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//使用less; i为-1</span></span><br><span class="line"><span class="comment">//结果依赖于item1和item2中的isbn</span></span><br><span class="line"><span class="function">sales_data <span class="title">item1</span><span class="params">(cin)</span>, <span class="title">item2</span><span class="params">(cin)</span> </span>;</span><br><span class="line"><span class="keyword">bool</span> j = <span class="built_in">compare</span> (iteml, item2,compareIsbn);</span><br></pre></td></tr></table></figure>

<p>与函数默认实参一样,对于一个模板参数,只有当它右侧的所有参数都有默认实参时它才可以有默认实参。</p>
<h4 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h4><p>同样的，类可以使用默认模板参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> &#123;</span><span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Numbers</span>(T V = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line">	<span class="comment">//对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>

<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><h4 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h4><p>若一个普通类中有一个模板函数，便被称为成员模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象类，对给定指针执行delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DebugDelete</span>(std::ostream&amp; s = std::cerr) :<span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">	<span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std : : endl; <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::ostream &amp; os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个类似unique_ptr的使用的默认删除器，根据不同的类型进行销毁操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">//可像delete表达式一样使用的对象</span></span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用 DebugDelete: :operator() (double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在一个临时 DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip) ;</span><br></pre></td></tr></table></figure>

<p>我们就可以用这个类型替换unique_ptr中的删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁p指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;int&gt; (int *)</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>，DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>,DebugDelete())</span></span>;</span><br><span class="line"><span class="comment">//销毁sp指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;string&gt; (string* )</span></span><br><span class="line"><span class="function">unique _ptr&lt;string,DebugDelete&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> string,DebugDelete() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>当unique_ptr析构函数调用时，De—类便会实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebugDelete的成员模板实例化样例</span></span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">int</span> *p) <span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>()(string *p)<span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h4><p>类和成员有各自的模板，即可以像这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="built_in">Blob</span> (It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::<span class="built_in">Blob</span> (It b, It e):</span><br><span class="line">		<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h4><p>为了实例化上一个模板类的成员模板，我们必须同时提供类和函数的实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] =&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">long</span>&gt; vi = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; w = &#123; <span class="string">&quot;now&quot;</span> , <span class="string">&quot;is&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;time&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类及其接受两个int*参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span> <span class="params">(begin(ia), end (ia))</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt; : :iterator的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin (), vi.end ())</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;string&gt;及其接受两个list&lt;const char*&gt; : :iterator参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;string&gt; <span class="title">a3</span> <span class="params">( w.begin (), w.end ())</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义a1时就实例化了如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">Blob</span> (<span class="keyword">int</span>* , <span class="keyword">int</span>* );</span><br></pre></td></tr></table></figure>

<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板,并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>在新标准中，我们可以通过显式实例化(explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;		<span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;				<span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">//declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</span></span><br><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;				<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>

<p>编译器遇到extern声明时，它不会在本文件中生成实例化代码，而是承诺其他地方有这样的实例化，我现在只是使用它，对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p>extern声明必须在任何使用此实例之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cc</span></span><br><span class="line"><span class="comment">//这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sal,sa2; <span class="comment">//实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; al = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(al)</span></span>; <span class="comment">//拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">compare</span>(a1 [<span class="number">0</span>],a2[<span class="number">0</span>]);<span class="comment">//实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>

<p>上面的这些使用extern的实例必须在其他地方有定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">//实例化文件必须为每个在其他文件中声明为extern 的类型和函数提供一个(非extern)的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;<span class="comment">//实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>

<p><strong>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
<h4 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h4><p><strong>在一个类模板的实例化定义中,所用类型必须能用于模板的所有成员函数。</strong></p>
<h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>unique_ptr避免了间接调用删除其的运行时开销，而shared_ptr使用户可以重载删除器。前者有效率，后者有灵活度。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li>const转换:可以将一个非 const对象的引用（或指针）传递给一个const的引用（或指针）形参。</li>
<li>数组或函数指针转换:如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T，T)</span></span>;<span class="comment">//实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 引用</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">s2</span> <span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);<span class="comment">//调用fobj(string,string); const被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);<span class="comment">//调用fref(const string&amp;, const string&amp;)</span></span><br><span class="line"><span class="comment">//将s1转换为const是允许的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b) ;</span><br><span class="line"><span class="comment">//调用f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a,b);</span><br><span class="line"><span class="comment">//错误:数组类型不匹配</span></span><br></pre></td></tr></table></figure>

<p>在最后一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针(参见6.2.4节，第195页)。a和 b的类型是不匹配的，因此调用是错误的。</p>
<p><strong>将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有const转换及数组或函数到指针的转换。</strong></p>
<h4 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h4><p>模板的参数只允许几种有限的类型转换，因此传递的这些形参必须具有相同的类型。我们的compare函数接受两个const T&amp;参数，其实参必须是相同类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);<span class="comment">//错误:不能实例化compare (long, int)</span></span><br></pre></td></tr></table></figure>

<p>如果希望可以类型转换，可以将函数模板定义为两个类型参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span> <span class="params">(<span class="keyword">const</span> A&amp; v1,<span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl&lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2&lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cout,<span class="number">42</span>); <span class="comment">//实例化print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span> <span class="params">( <span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span> (f，<span class="number">10</span>);<span class="comment">//使用print (ostream&amp;, int);将f转换为ostream&amp;</span></span><br></pre></td></tr></table></figure>

<p>第一个函数参数是一个已知类型ostream&amp;。第二个参数 obj 则是模板参数类型。由于os 的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换:</p>
<p><strong>如果函教参教类型不是模板参数，则对实参进行正常的类型转换。</strong></p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>某些时候模板参数无法推断除类型，允许用户控制模板实例化。</p>
<h4 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h4><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">Tl <span class="title">sum</span><span class="params">(T2，T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没有任何参数可供推断出T1的类型，所以调用时必须提供一个显示模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);<span class="comment">// long long sum(int，long)</span></span><br></pre></td></tr></table></figure>

<p>显式模板实参时一一对应的，只有右边的可以忽略，但必须可以从函数参数推断出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//糟糕的设计:用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span> <span class="params">(T2,T1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则我们总是必须为所有三个形参指定实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; (i, lng) ;<span class="comment">//正确:显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>，<span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>所以把需要显示提供的参数放在最前面</p>
<h4 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h4><p>如果模板类型参数已经显式指定，页可以进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);					<span class="comment">//错误:模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare (long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare(int,int)</span></span><br></pre></td></tr></table></figure>

<p>第一个调用由于类型不匹配错误，后面的调用由于显式指定，而可以进行正常的类型转换。</p>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span> (It beg, It end)&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不知道返回结果的准确类型，但所需类型是所处理的序列的元素类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span> (vi.<span class="built_in">begin</span> (), vi.<span class="built_in">end</span>() ); 	<span class="comment">//fcn应该返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span> (ca.<span class="built_in">begin</span> (), ca.<span class="built_in">end</span>());		<span class="comment">// fcn应该返回string&amp;</span></span><br></pre></td></tr></table></figure>

<p>我们知道函数应该返回*beg，而且知道我们可以用decltype (*beg)来获取表达式类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg,It end)</span> -&gt; <span class="title">decitype</span> <span class="params">(*beg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h4><p>如果并不想返回引用而是返回其中的值，可以使用标准库<strong>类型转换</strong>模板。在头文件type_traits中，如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化 remove_reference&lt;int&amp;&gt;，则type 成员将是int。类似的，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string，依此类推。更一般的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span> (*beg) &gt;::type</span><br></pre></td></tr></table></figure>

<p>组合使用它们就可以在函数中返回元素值的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用模板参数的成员，必须用typename，参见16.1.3节（第593页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span> <span class="params">(It beg,It end)</span> -&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span> <span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png" alt="image.png"></p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>可以用一个函数模板对一个函数指针进行赋值，可根据形参生成一个实例，被指针所指：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> ( *pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<p>如果不能从函数指针类型却低估模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本;每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*) (<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span> (compare); <span class="comment">//错误:使用compare的哪个实例?</span></span><br></pre></td></tr></table></figure>

<p>由于既可以接受int和string版本的compare，所以调用失败。不过可以显式的指出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:显式指出实例化哪个compare版本</span></span><br><span class="line"><span class="built_in">func</span> (compare&lt;<span class="keyword">int</span>&gt;);<span class="comment">//传递compare (const int&amp;,const int&amp;)</span></span><br></pre></td></tr></table></figure>

<p><strong>当参数是一个函数模板实例的地址时,程序上下文必须满足:对每个模板参数,能唯一确定其类型或值。</strong></p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><h4 id="左值引用函数参数推断类型"><a href="#左值引用函数参数推断类型" class="headerlink" title="左值引用函数参数推断类型"></a>左值引用函数参数推断类型</h4><p>一个函数参数是模板类型参数的普通引用时，只能传递给它一个左值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参必须是一个左值//对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line"><span class="built_in">f1</span>(i);<span class="comment">// i是一个int;模板参数类型T是int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">// ci是一个const int;模板参数T是const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>); <span class="comment">//错误:传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果是const T&amp;,则推断结果不会是一个const类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">//f2中的参数是const &amp; ;实参中的const是无关的</span></span><br><span class="line"><span class="comment">//在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i);<span class="comment">//i是一个int;模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">//ci是一个const int，但模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);<span class="comment">//一个const&amp;参数可以绑定到一个右值;T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h4><p>如果函数参数是右值引用，如T&amp;&amp;，推断出T的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp; &amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">//实参是一个int类型的右值;模板参数T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h4><p>如果一个函数参数是指向模板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&amp;)。</p>
<h4 id="编写接受右值引用参数的模板函数"><a href="#编写接受右值引用参数的模板函数" class="headerlink" title="编写接受右值引用参数的模板函数"></a>编写接受右值引用参数的模板函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">	Tt = val; <span class="comment">//拷贝还是绑定一个引用?</span></span><br><span class="line">	t = <span class="built_in">fcn</span> (t) ; <span class="comment">//赋值只改变t还是既改变t又改变val?</span></span><br><span class="line">	<span class="keyword">if</span> (val == t)&#123;<span class="comment">/* ...*/</span> &#125;<span class="comment">//若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，如果传入42，则T会推断为int，但如果传入int的左值，则T会推断为int&amp;，则如果修改t的同时也会修改val。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; )</span> </span>;		<span class="comment">//绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;		<span class="comment">//左值和const右值</span></span><br></pre></td></tr></table></figure>

<p>通常是这样重载模板函数，与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>在13.6.2节中我们注意到，虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<h4 id="std-move如何定义"><a href="#std-move如何定义" class="headerlink" title="std::move如何定义"></a>std::move如何定义</h4><p>标准库的的move</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// static_cast是在4.11.3节（第145页）中介绍的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt; (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很短，但其中有些微妙之处。首先，move的函数参数T&amp; &amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span> <span class="params">( <span class="string">&quot;hi! &quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std: :<span class="built_in">move</span>(<span class="built_in">string</span> ( <span class="string">&quot;bye ! &quot;</span>) );<span class="comment">//正确:从一个右值移动数据</span></span><br><span class="line">s2 = std: :<span class="built_in">move</span>(sl);<span class="comment">//正确:但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>

<h4 id="std-move如何工作"><a href="#std-move如何工作" class="headerlink" title="std::move如何工作"></a>std::move如何工作</h4><p>如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型。因此，在<code>std: : move (string ( &quot;bye ! &quot;))</code>中:</p>
<ul>
<li>推断出的T的类型为string。</li>
<li>因此，remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp; 。</li>
<li>move的函数参数t的类型为string&amp; &amp;。</li>
</ul>
<p>因此，这个调用实例化move<string>，即函数<code>string&amp;&amp; move(string &amp;t)</code></p>
<h4 id="左值static-cast到右值引用时允许的"><a href="#左值static-cast到右值引用时允许的" class="headerlink" title="左值static_cast到右值引用时允许的"></a>左值static_cast到右值引用时允许的</h4><p>我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是const的以及实参是左值还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受一个可调用对象和另外两个参数的模板//对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现:顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f,T1 t1,T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用一个接受引用的参数就会出问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span><span class="comment">//注意v2是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;++v2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数第二个参数为引用，说明我们希望通过函数改变原变量的值，但是使用模板调用就会丢失这个引用的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,i);			<span class="comment">//f改变了实参i</span></span><br><span class="line"><span class="built_in">flip1</span>(f,j,<span class="number">42</span>);		<span class="comment">//通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非int&amp;。因此，这个flip1调用会实例化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn) (<span class="keyword">int</span>,<span class="keyword">int</span>&amp; ), <span class="keyword">int</span> t1,<span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h4><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值〉使得我们可以保持const属性,因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&amp;&amp;和 T2&amp;&amp;,通过引用折叠（参见 16.2.5节，第608页）就可以保持翻转实参的左值/右值属性（参见16.2.5节，第608页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2, t1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样调用就传递给t1一个左值j，t1会折叠为int&amp;，则t1会绑定到j上，就可以通过函数改变j的值。</p>
<p><strong>如果一个函数参数是指向模板类型参数的右值引用(如 T&amp;&amp;)，它对应的实参的const属性和左值/右值属性将得到保持。</strong></p>
<p>但是不能用于接受右值引用参数的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp; &amp;i, <span class="keyword">int</span>&amp; j)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传递一个右值给flip2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>);<span class="comment">//错误:不能从一个左值实例化int&amp; &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="std-forward保持类型信息"><a href="#std-forward保持类型信息" class="headerlink" title="std::forward保持类型信息"></a>std::forward保持类型信息</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line">	<span class="built_in">finalFcn</span> (std::forward&lt;Type&gt;(arg));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节。</strong></p>
<p>于是我们可以重写前面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f,T1 &amp; &amp;t1,T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">f</span> (std: :forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h4 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h4><p>首先编写俩个不同的函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	ostringstream ret;	<span class="comment">//参见8.3节（第287页)</span></span><br><span class="line">	ret &lt;&lt; t;			<span class="comment">//使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); 	<span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个对象对应string表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">//注意:此函数不能用于char*;参见16.3节（第617页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p;	<span class="comment">//打印指针本身的值</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;<span class="built_in">debug_rep</span> (*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; null pointer&quot;</span> ;<span class="comment">//或指出 p为空</span></span><br><span class="line">	<span class="keyword">return</span> ret.<span class="built_in">str</span>();<span class="comment">//返回ret绑定的string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内容并不重要，我们先看使用它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">( <span class="string">&quot;hi&quot;</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>这个调用只有第一个版本是可行的，第二个版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。</p>
<p>如果用一个指针调用debug_rep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>两个函数都生成可行的实例:</p>
<ul>
<li>debug rep(const string*&amp;)，由第一个版本的debug_rep实例化而来，T被绑定到string*。</li>
<li>debug rep(string*)，由第二个版本的 debug_rep实例化而来，T被绑定到string。</li>
</ul>
<p>但第二个版本更加精确，第一个版本需要进行普通指针到const的转换，编译器也会选择第二个版本。</p>
<h4 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (sp) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配:</p>
<ul>
<li><code>debug rep(const string*&amp;)</code>，由第一个版本的 debug_rep 实例化而来，T被绑定到<code>string*</code>。</li>
<li><code>debug rep(const string*)</code>，由第二个版本的 debug_rep 实例化而来，T被绑定到const string。</li>
</ul>
<p>再这种时候编译器会选择最特例化的，我的理解是，最简洁的，则选择第一个版本。</p>
<h4 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印双引号包围的string</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27; &quot;&quot; +s + &#x27;</span><span class="string">&quot;&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当同时匹配同样好的模板和非模板函数的时候，编译器一定会选择非模板版本。</p>
<h4 id="重载模板和类型转换"><a href="#重载模板和类型转换" class="headerlink" title="重载模板和类型转换"></a>重载模板和类型转换</h4><p>如果使用这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;<span class="comment">//调用debug_rep(T*)</span></span><br><span class="line"><span class="comment">//本例中所有三个debug _rep版本都是可行的:</span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> T&amp;)</span>，<span class="comment">//T被绑定到char [10]。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span><span class="params">(T*)</span>，<span class="comment">//T被绑定到const char。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> strina&amp;)</span>，<span class="comment">//要求从const char*到string 的类型转换。</span></span></span><br></pre></td></tr></table></figure>

<p>前两个版本都是匹配的，而第二个版本会被认为是精确匹配的，非模板版本是可行的，但需要一次用户定义的类型转换。所以选择第二个。</p>
<p>如果更希望使用字符版本，可以定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符指针转换为string，并调用string版本的 debug_reg</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h4><p>为了使用<code>char*</code>版本的函数，必须提前准备好其中的模板函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *P)</span></span>;</span><br><span class="line"><span class="comment">//为了使debug_rep(char*)的定义正确工作，下面的声明必须在作用域中string debug_rep (const string &amp;);</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function">i</span></span><br><span class="line"><span class="function"><span class="comment">//如果接受一个const string&amp;的版本的声明不在作用域中，</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回语句将调用debug_rep(const T&amp;)的T实例化为string 的版本return debug_rep(string(p) );</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</strong></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个<strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。存在两种参数包:<strong>模板参数包</strong>template parameter packet)，表示零个或多个模板参数;<strong>函数参数包</strong>（function parameteroacket)，表示零个或多个函数参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包; rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与往常一样，编译器从函数的实参推断模板参数类型。对于可变参数模板，编译器会推断保重的参数数目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span> ;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>,d);	<span class="comment">//包中有三个参数</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="built_in">foo</span>(d,s);			<span class="comment">//包中有一个参数</span></span><br><span class="line"><span class="built_in">foo</span> ( <span class="string">&quot;hi&quot;</span>);		<span class="comment">//空包</span></span><br><span class="line"><span class="comment">//编译器会为foo实例化出四个不同的版本:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;，<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> string&amp;)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h4><p>若需要知道包中的运算符，使用sizeof…运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt;endl; <span class="comment">//类型参数的数目</span></span><br><span class="line">	cout&lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;		<span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>. . . Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;...rest)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;，&quot;</span>;			<span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>print (cout, i, s,42); //包中有两个参数</code>来调用上面的函数，首先会匹配到第二个函数，然后递归调用第二个函数，直至最后一个参数由第一个函数打印。</p>
<p><strong>当定义可变参数版本的 print时，非可变参数版本的声明必须在作用域中。否则,可变参数版本会无限递归。</strong></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>除了获取其大小以外，我们还可以<strong>扩展</strong>，我们还要提供扩展元素的<strong>模式</strong>。就时分解为构成的元素，在模式右边放一个省略号(…)触发扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;<span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span><span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);		<span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个扩展操作扩展模板参数包，为 print生成函数参数列表。第二个扩展操作出现在对print的调用中。此模式为print调用生成实参列表。</p>
<h4 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">	<span class="comment">//print (os,debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span> (os,<span class="built_in">debug_rep</span> (rest)... ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看这样的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将包传递给debug_rep; print (os，debug_rep(a1,a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os,<span class="built_in">debug_rep</span>(rest.. .) );<span class="comment">//错误:此调用无匹配函数</span></span><br></pre></td></tr></table></figure>

<p>它们的区别就是第一个对扩展包中的每一个调用函数，第二个是在调用中展开：</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;...)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员的定义，同13.5节（第465页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">chk_n_alloc</span>(); <span class="comment">//如果需要的话重新分配 StrVec内存空间</span></span><br><span class="line">	alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emplace_back的函数体调用了chk_n_alloc（参见13.5节，第465页）来确保有足够的空间容纳一个新元素，然后调用了construct在first_free 指向的位置中创建了一个元素。construct调用中的扩展为</p>
<p><code>std: : forward&lt;Args&gt;(args) ...</code><br>它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素</p>
<p><code>std::forward&lt;T&gt;(t)</code></p>
<p>其中T,表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如.假定svec是一个strVec，如果我们调用</p>
<p><code>svec.emplace_back (10,&#39;c&#39;);//将cccccccccc添加为新的尾元素</code></p>
<p>construct调用中的模式会扩展出</p>
<p><code>std::forward&lt;int&gt; (10), std::forward&lt;char&gt;(c)</code></p>
<p>通过在此调用中使用forward，我们保证如果用一个右值调用emplace back，则construct也会得到一个右值。例如，在下面的调用中:</p>
<p><code>svec.emplace back (s1 + s2);//使用移动构造函数</code></p>
<p>传递给emplace_back的实参是一个右值，它将以如下形式传递给construct</p>
<p><code>std: :forward&lt;string&gt; (string ( &quot;the end&quot; ))</code></p>
<p>forward<string>的结果类型是string&amp;&amp;，因此construct将得到一个右值引用实参。construct会继续将此实参传递给string 的移动构造函数来创建新元素。</p>
<p><strong>建议:转发和可变参数模板</strong></p>
<p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的emp lace_ back函数一样的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">(Args&amp;&amp;... args)</span> <span class="comment">//将Args扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// work的实参既扩展Args又扩展args</span></span><br><span class="line">	<span class="built_in">work</span>(std: : forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们希望将fun的所有实参转发给另一个名为work的函数,假定由它完成函数的实际工作。类似emplace_back中对 construct的调用,work调用中的扩展既扩展了模板参数包也扩展了函数参数包。<br>由于 fun的参数是右值引用,因此我们可以传递给它任意类型的实参;由于我们使用std:: forward传递这些实参，因此它们的所有类型信息在调用work时都会得到保持。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp; )</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们定义了另一个版本的compare，当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用，而传递给它字符指针，就会调用第一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span> ;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);<span class="comment">//调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>( <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;mom&quot;</span> );<span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>因为无法将指针转换为数组的引用，因此参数是p1和p2时，第二个版本compare不可行。</p>
<p>为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例化( template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<h4 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h4><p>特例化一个函数模板时，必须为每个模板参数提供实参，在template后跟&lt;&gt;，指出正在实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个特例化版本时，函数的参数类型必须与先前模板中对应类型匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>特例化中T对应的为const char*，模板函数中为一个常量指针，而我们需要一个指向常量的指针，我们需要在特例化版本中使用的类型是const char * const &amp;，即一个指向const char的const指针的引用。</p>
<h4 id="函数重载与模板特例化"><a href="#函数重载与模板特例化" class="headerlink" title="函数重载与模板特例化"></a>函数重载与模板特例化</h4><p><strong>特例化的本质是实例化一个模板,而非重载它。因此,特例化不影响函数匹配。</strong></p>
<p><strong>关键概念:普通作用域规则应用于特例化</strong></p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且,在任何使用模板实例的代码之前,特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板,很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是,这种错误编译器又无法发现。</p>
<p><strong>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面,然后是这些模板的特例化版本。</strong></p>
<h4 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h4><p>我们将has模板定义一个特例化版本，用它保存Sale_data对象，为了让我们自己的数据类型能使用hash<key_type>，必须定义hash模板的一个特例化版本。一个特例化hash类必须定义:</p>
<ul>
<li>一个重载的调用运算符（参见14.8节，第506页)，它接受一个容器关键字类型的对象，返回一个size_t。</li>
<li>两个类型成员，result type和 argument_type，分别调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义，参见13.1.2节，第443页)。</li>
</ul>
<p>首先打开命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;<span class="comment">//我们正在定义一个特例化版本，模板参数为sales_data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Sales_data&gt; </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> sales_data argument_type;<span class="comment">// 默认情况下，此类型需要==</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> sales_data&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;string&gt;() (s.bookNo) ^</span><br><span class="line">            hash&lt;<span class="keyword">unsigned</span>&gt;() (s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="keyword">double</span>&gt;() (s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//关闭std命名空间;注意:右花括号之后没有分号</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">C++ Primer 第十五章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-12T00:00:00+08:00">2022-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:23" itemprop="dateModified" datetime="2022-03-04T12:58:23+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
            <span id="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="C++ Primer 第十五章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p><strong>面向对象程序设计（object-oriented programming）</strong>的核心思想是<strong>数据抽象</strong>、<strong>继承</strong>和<strong>动态绑定</strong>。</p>
<ul>
<li>使用数据抽象，我们可以将类的接口与实现分离；</li>
<li>使用继承，可以定义相似的类型并对其相似关系建模；</li>
<li>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>通过<strong>继承（inheritance）</strong>联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类(base class)<strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为</strong>派生类( derived class)**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（ virtual function)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过使用类派生列表(class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是 : 首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="comment">//Bulk_quote继承了Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为使用public派生，所以可以使用基类成员，可以把Bulk quote的对象当成Quote的对象来使用。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>用它可以分别处理Quote和Bulk_quote的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据传入item形参的对象类型调用Quote::net_price</span></span><br><span class="line">    <span class="comment">//或者Bulk_quote::net_price</span></span><br><span class="line">	<span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;ISBN:&quot;</span> &lt;&lt; item.<span class="built_in">isbn</span> ()<span class="comment">//调用Quote: :isbn</span></span><br><span class="line">		&lt;&lt;<span class="string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>函数形参中的item是基类的引用，我们既可以使用基类的该函数，又可以使用派生类中的该函数，这回根据对象的类型决定执行哪一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic的类型是Quote; bulk的类型是Bulk_quote</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, basic,<span class="number">20</span>);			<span class="comment">//调用Quote的net_price</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, bulk,<span class="number">20</span>);			<span class="comment">//调用Bulk quote的net price</span></span><br></pre></td></tr></table></figure>

<p>函数的运行版本由实参决定，所以动态绑定又被称为运行时绑定。</p>
<p><strong>在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。</strong></p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">//关于=default请参见7.1.4节（第 237页)</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> std::string &amp;book,<span class="keyword">double</span> sales_price) </span><br><span class="line">        : <span class="built_in">bookNo</span> (book), <span class="built_in">price</span>(sales_price)&#123; &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="comment">//返回给定数量的书籍的销售总额</span></span><br><span class="line">	<span class="comment">//派生类负责改写并使用不同的折扣计算算法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">					</span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span> () = <span class="keyword">default</span>;	<span class="comment">//对析构函数进行动态绑定</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string bookNo;				<span class="comment">//书籍的ISBN 编号</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;				<span class="comment">//代表普通状态下不打折的价格</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如此。</strong></p>
<h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>派生类需要提供自己新定义覆盖从基类而来的虚函数。任何希望在派生类中改变的函数定义为virtual，而不希望改变的直接定义为函数。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用<strong>受保护的( protected）</strong>访问运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须使用类派生列表指出从哪继承而来。派生类必须将继承类的虚函数重新声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;		<span class="comment">//Bulk_quote继承自Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span> (<span class="keyword">const</span> std::string&amp;,<span class="keyword">double</span>,std::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">//覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;		<span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span> ;			<span class="comment">//以小数表示的折扣额</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再派生类中使用public继承，所以回隐式包含isbn函数</p>
<h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类可以不覆盖它继承的虚函数，但必须重新声明：如果没有覆写，其行为类似其他的普通成员。</p>
<p>派生类可以再它覆盖的函数前使用virtual，可以在函数const关键字后添加override。</p>
<h4 id="派生类对象及派生类向基类转换"><a href="#派生类对象及派生类向基类转换" class="headerlink" title="派生类对象及派生类向基类转换"></a>派生类对象及派生类向基类转换</h4><p>派生类大致可以认为是这样分布：</p>
<p><img src="https://s2.loli.net/2022/02/15/wRpdlhZ4XqbNygO.png" alt="image.png"></p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;				<span class="comment">//基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">//p指向Quote对象</span></span><br><span class="line">p = &amp;bulk ;				<span class="comment">// p指向bulk 的 Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;		<span class="comment">// r绑定到bulk 的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>这种派生类到基类的转换回隐式的进行，所以可以将派生类的引用或指针用在基类引用或者指针上。</p>
<h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p>派生类构造函数可以调用基类的构造函数帮助建立自己的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std::string&amp; book,<span class="keyword">double</span> p,</span></span></span><br><span class="line"><span class="params"><span class="function">			std::<span class="keyword">size_t</span> qty,<span class="keyword">double</span> disc)</span>:</span></span><br><span class="line"><span class="function">			Quote(book, p), min_qty(qty), discount (disc)&#123;</span> &#125;</span><br><span class="line">		<span class="comment">//与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除非特别指出，否则派生类的所有成员都会执行默认初始化。编译器会首先初始化基类的部分，然后按顺序声明派生类的成员。</p>
<h4 id="派生类使用基类成员"><a href="#派生类使用基类成员" class="headerlink" title="派生类使用基类成员"></a>派生类使用基类成员</h4><p>派生类可以访问基类的公有成员和受保护成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt;= min_qty)</span><br><span class="line">		<span class="keyword">return</span> cnt *(<span class="number">1</span> - discount) * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员（例如min_qty和discount)的方式与使用基类成员（例如price）的方式没什么不同。</p>
<p><strong>关键概念:遵循基类的接口</strong><br>必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口,即使这个对象是派生类的基类部分也是如此。<br>派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了静态成员，则它在整个继承体系中只存在该成员的唯一定义。不论有几个派生，每个静态成员都只存在唯一实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span> <span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">const</span> Derived&amp;)</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmem</span> ();		<span class="comment">//正确:Base定义了statmem</span></span><br><span class="line">	Derived::<span class="built_in">statmem</span> ();	<span class="comment">//正确:Derived继承了statmem</span></span><br><span class="line">	<span class="comment">//正确:派生类的对象能访问基类的静态成员</span></span><br><span class="line">	derived_obj.<span class="built_in">statmem</span> () ;<span class="comment">//通过Derived对象访问</span></span><br><span class="line">	<span class="built_in">statmem</span> ();				<span class="comment">//通过this对象访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类声明方式和一般类一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote;<span class="comment">//错误:派生列表不能出现在这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>				<span class="comment">//正确:声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>

<h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>如果想将派生类作为基类，则必须已经被定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>;</span>				<span class="comment">//声明但未定义</span></span><br><span class="line"><span class="comment">//错误:Quote必须被定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>派生类包含从基类中来的成员，为了使用它们，必须先知道它们。也表明了一个类不能派生它本身。</p>
<p>一个类是基类，同时也可以是派生类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base &#123;<span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1 &#123;<span class="comment">/* ...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个继承关系中，Base是D1的**直接基类( direct base)<strong>，同时是D2的</strong>间接基类( indirectbase)**。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。</p>
<p>每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员;该直接基类的成员又含有其基类的成员;依此类推直至继承链的顶端。</p>
<h4 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h4><p>类名后加上final可防止类被继承：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span> <span class="comment">/** / &#125;;			//NoDerived不能作为基类</span></span><br><span class="line"><span class="comment">class Base &#123;/* */</span> &#125;;	</span><br><span class="line"><span class="comment">// Last是final的;我们不能继承</span></span><br><span class="line">Lastclass Last <span class="keyword">final</span> : Base &#123;<span class="comment">/**/</span> &#125;;		<span class="comment">// Last不能作为基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> NoDerived&#123;<span class="comment">/**/</span>&#125;;				<span class="comment">//错误:NoDerived是final的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> Last &#123;<span class="comment">/* */</span> &#125;;					<span class="comment">//错误: Last是final的</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>在继承关系的类中，基类的指针和引用可以绑定到派生类对象上，所以使用基类指针或者引用时，并不清楚绑定对象的真实类型。</p>
<p><strong>和内置指针一样,智能指针类也支持派生类向基类的类型转换,这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</strong></p>
<h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><p>在继承关系中必须区分两种类型，表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型，动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当print_total调用net_price 时(参见15.1节，第527页):</span></span><br><span class="line"><span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n) ;</span><br></pre></td></tr></table></figure>

<p>item在前面时用Quote&amp;去定义的，那么Quote&amp;就是item的静态类型，动态类型知道在运行时调用该函数才会知道。如果传递一个Bulk_quote对象给print_total，则item的动态类型于静态类型不一致。只有引用和指针动态和静态类型才会不一致。</p>
<h4 id="不存在基类想派生类的隐式类型转换"><a href="#不存在基类想派生类的隐式类型转换" class="headerlink" title="不存在基类想派生类的隐式类型转换"></a>不存在基类想派生类的隐式类型转换</h4><p>派生类可以向基类转换是因为每一个派生类对象都包含一个基类的部分。所以一个基类对象既可以独立存在可以作为派生类的一部分存在。但任何派生类对象都不可以向基类隐式的转换，包括引用和指针。</p>
<p><strong>总结</strong>：要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样,派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节（第544页)详细介绍可访问性的问题。</li>
</ul>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在我们使用基类的引用或指针调用虚函数时会执行动态绑定。因为知道运行时才知道调用了哪个版本，所以所有的虚函数都必须有定义，不论它是否被用到。</p>
<h4 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h4><p>虚函数执行哪个版本完全依赖于运行时绑定到其对象的实际动态类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, base, <span class="number">10</span>);			<span class="comment">//调用Quote::net price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">derived</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">.19</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, derived, <span class="number">10</span>);			<span class="comment">//调用Bulk_quote::net_price</span></span><br></pre></td></tr></table></figure>

<p>依据调用对象的不同，会调用两种不同的函数。此外动态绑定也只有当通过指针或引用调用虚函数才会发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base = derived;			<span class="comment">//把derived的Quote部分拷贝给base</span></span><br><span class="line">base.<span class="built_in">net_price</span> (<span class="number">20</span>);	<span class="comment">//调用Quote::net price</span></span><br></pre></td></tr></table></figure>

<p><strong>关键概念:C++的多态性</strong><br>OOP的核心思想是多态性（polymorphism)。多态性这个词源自希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型,因为我们能使用这些类型的“多种形式”而无须在意它们的差异。<strong>引用或指针的静态类型与动态类型不同</strong>这一事实正是C++语言支持多态性的根本所在。</p>
<p>当我们使用基类的引用或指针调用基类中定义的一个函数时,我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本,判断的依据是引用或指针所绑定的对象的真实类型。</p>
<p>另一方面,对非虚函数的调用在编译时进行绑定。类似的,通过对象进行的函数(虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此,通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。</p>
<p><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</strong></p>
<h4 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>当我们在派生类中可以再一次使用virtual关键字指出函数的性质。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参、返回类型必须与被覆盖的基类函数完全一致。有一个例外是当类的虚函数返回类型是类本身的指针和引用时，规则无效：也就是说，如果D由B派生得到，则基类的虚函数可以返回B<code>*</code>而派生类的对应函数可以返回D<code>*</code>，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
<h4 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h4><p>我们使用override来覆盖继承而来的虚函数，但该函数并没有覆盖已存在的虚函数，此时编译器将会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span> <span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;		<span class="comment">//正确:f1与基类中的f1匹配</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;				<span class="comment">//错误:B没有形如2 (int)的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:f3不是虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">	<span class="comment">//从B继承f2()和f3 ()，覆盖f1 (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;<span class="comment">//不允许后续的其他类覆盖f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 正确:覆盖从间接基类B继承而来的f2</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//错误:D2已经将f2声明成final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>final和 override说明符出现在形参列表(包括任何const或引用修饰符）以及尾置返回类型之后。</strong></p>
<h4 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h4><p>虚函数可以有默认实参，如果某次函数调用使用默认实参，则实参值由静态类型决定：</p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。</p>
<p><strong>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>
<h4 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h4><p>如果希望虚函数调用不要进行动态绑定，而是强迫其执行某个版本，可以使用作用域运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>此代码在编译时就可以完成解析</p>
<p><em>通常情况下,只有成员函数(或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。</em></p>
<p><em>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归</em></p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>我们可以将一个函数定义为纯虚函数，这样做的目的时为了告诉用户，当前此函数没有任何意义，所以它无需定义，通过在函数体位置添加=0就可以声明一个纯虚函数，它只能出现在类内部虚函数声明语句处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Disc_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">		std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Quote</span>(book, price),</span><br><span class="line">		<span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//折扣适用的购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount - <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//表示折扣的小数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<h4 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h4><p>含有纯虚函数的类是<strong>抽象基类</strong>，这种类只负责定义接口，后续的其他类可以覆盖接口，我们不可以直接创建一个抽象基类的对象，因为此时的其中的纯虚函数并没有被定义，我们可以在派生类中覆盖此函数，然后就可以创建派生类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></span><br><span class="line">Disc_quote discounted;		<span class="comment">//错误:不能定义 Disc quote的对象</span></span><br><span class="line">Bulk_quote bulk;			<span class="comment">//正确:Bulk quote中没有纯虚函数</span></span><br></pre></td></tr></table></figure>

<p>如果不给出纯虚函数的定义，它任然是抽象基类。</p>
<h4 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h4><p>重新实现Bulk_quote，让它继承Disc_quote：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当同一书籍的销售量超过某个值时启用折扣</span></span><br><span class="line"><span class="comment">//折扣的值是一个小于1的正的小数值，以此来降低正常销售价格</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">			std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;;<span class="comment">//覆盖基类中的函数版本以实现一种新的折扣策略</span></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的 Bulk_quote 的直接基类是 Disc_quote，间接基类是 Quote。每个Bulk quote对象包含三个子对象:一个(空的)Bulk_quote部分、一个 Disc_quote子对象和一个Quote子对象。</p>
<p>每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，也必须提供构造函数，在构造函数中调用直接基类的构造函数，进而继续调用间接基类 的构造函数。</p>
<p><strong>关键概念:重构</strong><br>在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。</p>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<p>值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。</p>
<h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问</strong>（ accessible)。</p>
<h4 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h4><p>如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是 public和 private 中和后的产物:</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;						<span class="comment">// protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky: :prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">//不能访问Base: :prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//正确:clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误:clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp; b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>例子中派生类成员函数使用基类对象访问受保护的成员是不可行的。</p>
<h4 id="公有、私有、受保护继承"><a href="#公有、私有、受保护继承" class="headerlink" title="公有、私有、受保护继承"></a>公有、私有、受保护继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// public成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">	<span class="comment">// protected成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> priv_mem;</span><br><span class="line">	<span class="comment">// private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="comment">// 正确:派生类能访问protected成员int f() &#123; return prot_mem; &#125;</span></span><br><span class="line">	<span class="comment">//错误:private成员对于派生类来说是不可访问的char g() &#123; return priv_mem;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">// 依旧不能访问</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生访问说明符对派生类的成员（及友元）能否访问直接基类成员没有影响。访问权限只与基类中的访问说明符有关。派生类只能访问直接基类的受保护的与共有的成员。</p>
<p>派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内）对于基类成员的访问权限，概括来说：</p>
<ul>
<li>如果是共有继承，那么继承而来的成员访问等级不变。</li>
<li>受保护继承，继承而来的访问等级上升一级，public变为protect。</li>
<li>私有继承，所有继承成员访问等级上升到最高，及全部为private</li>
</ul>
<h4 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h4><p>派生类向基类的转换（参见15.2.2 节，第530页)是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B:</p>
<ul>
<li>只有当D 公有地继承B时，用户代码才能使用派生类向基类的转换;如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换;派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换;反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<p><strong>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的;反之则不行。</strong></p>
<p><strong>关键概念:类的设计与受保护的成员</strong><br>不考虑继承的话,我们可以认为一个类有两种不同的用户:普通用户和类的实现者。</p>
<p>其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有(实现)部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的。</p>
<h4 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h4><p>就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="comment">//添加friend声明，其他成员与之前的版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span>			<span class="comment">// Pal在访问Base的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; 		<span class="comment">//正确: Pal是 Base的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;			<span class="comment">//错误: Pal不是Sneaky的友元</span></span><br><span class="line">    <span class="comment">//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125;		<span class="comment">//正确: Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在f2中j是Sneaky成员而不是Base成员，由于pal只是Base的友元所以不能访问其派生类成员。而f3访问的是Sneaky中的Base成员所以可以访问。</p>
<p>当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D2对Base 的 protected和private成员不具有特殊的访问能力class D2 : public Pal &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b.prot_mem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//错误:友元关系不能继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h4><p>使用using声明可以改变和继承某个名字的访问级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std : : <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">//注意:private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base : : size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base : : n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>using使得不论如何继承而来的成员在保持using前一个访问说明符的访问等级，如size是public，n是protect。但是派生的类只能为可以访问的名字提供using声明</p>
<h4 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h4><p>默认情况下class定义派生类是私有继承，而struct是共有继承。但更建议显示的声明出来。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p><strong>派生类的作用域嵌套在基类内</strong>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt;bulk.<span class="built_in">isbn</span> () ;</span><br></pre></td></tr></table></figure>

<p>名字isbn的解析将按照下述过程所示:</p>
<ul>
<li>因为我们是通过Bulk_quote的对象调用isbn的，所以首先在Bulk_quote中查找，这一步没有找到名字isbn</li>
<li>因为Bulk quote是 Disc quote 的派生类，所以接下来在 Disc_quote 中查找，仍然找不到。</li>
<li>因为 Disc_quote是 Quote的派生类，所以接着查找Quote;此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中的isbn。</li>
</ul>
<h4 id="编译时进行名字查找"><a href="#编译时进行名字查找" class="headerlink" title="编译时进行名字查找"></a>编译时进行名字查找</h4><p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况)，但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p>这是因为当使用基类指针时，可使用的成员已经确定，如果使用它绑定一个派生类对象，且派生类对象又新增了几个成员，此时对于这个指针来说，它并不知道这些多出来的成员，自然也无法使用它们。</p>
<h4 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h4><p>如果派生类中定义了其基类同名的成员，那么此成员将会隐藏基类中的同名成员，就像局部变量被优先使用。主要还是因为派生类的作用域嵌套在基类内。</p>
<h4 id="通过作用域运算符使用隐藏成员"><a href="#通过作用域运算符使用隐藏成员" class="headerlink" title="通过作用域运算符使用隐藏成员"></a>通过作用域运算符使用隐藏成员</h4><p>通过在同名成员前加上作用域就可以调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base : :mem;&#125; <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>建议还是不要同名。</p>
<p>*<em>关键概念:名字查找与继承</em><br>理解函数调用的解析过程对于理解C++的继承至关重要,假定我们调用p-&gt;mem ()（或者obj .mem())，则依次执行以下4个步骤:</p>
<ul>
<li>首先确定p(或obj)的静态类型。因为我们调用的是一个成员,所以该类型必然是类类型。</li>
<li>在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到,则编译器将报错。</li>
<li>一旦找到了mem,就进行常规的类型检查(参见6.1节,第183页)以确认对于当前找到的 mem，本次调用是否合法。</li>
<li>假设调用合法,则编译器将根据调用的是否是虚函数而产生不同的代码:<ul>
<li>如果 mem是虚函数且我们是通过引用或指针进行的调用,则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用,则编译器将产生一个常规函数调用。</li>
</ul>
</li>
</ul>
<h4 id="一如既往，名字查找先于类型检查"><a href="#一如既往，名字查找先于类型检查" class="headerlink" title="一如既往，名字查找先于类型检查"></a>一如既往，名字查找先于类型检查</h4><p>如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类(即内层作用域）的成员与基类（即外层作用域)的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致。</p>
<h4 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h4><p>现在可以理解为什么基类与派生类的虚函数必须有相同的形参列表了，如果不相同就会隐藏同名成员，而不是覆写。不然就无法通过基类引用或指针访问派生类的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//隐藏基类的fcn，这个fcn不是虚函数</span></span><br><span class="line">    <span class="comment">// D1继承了Base : :fcn ()的定义</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//形参列表与Base 中的fcn不一致</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//是一个新的虚函数，在 Base中不存在</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">//是一个非虚函数，隐藏了D1 : : fcn (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;		<span class="comment">//覆盖了Base的虚函数fcn</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//覆盖了D1的虚函数f2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过基类调用隐藏的虚函数"><a href="#通过基类调用隐藏的虚函数" class="headerlink" title="通过基类调用隐藏的虚函数"></a>通过基类调用隐藏的虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1l = &amp;bobj, * bp2 = &amp;dlobj, * bp3 = &amp;d2obj; </span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用，将在运行时调用 Base : : fcn</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用 Base : : fcn</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用D2 : :fcn</span></span><br><span class="line">D1* dlp = &amp;dlobj; D2* d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;<span class="built_in">f2</span>();			<span class="comment">//错误:Base没有名为f2的成员</span></span><br><span class="line">dlp-&gt;<span class="built_in">f2</span>();			<span class="comment">//虚调用，将在运行时调用D1 : :f2()</span></span><br><span class="line">d2p-&gt;<span class="built_in">f2</span>();			<span class="comment">// 虚调用，将在运行时调用D2: : f2()</span></span><br></pre></td></tr></table></figure>

<p>对于调用非虚函数，并不会发生动态绑定，由指针的类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *pl = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//错误:Base中没有接受一个int的fcn</span></span><br><span class="line">p2-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//静态绑定，调用D1 : :fcn(int)</span></span><br><span class="line">p3-&gt;<span class="built_in">fcn</span> ( <span class="number">42</span>);			<span class="comment">//静态绑定，调用D2 : :fcn (int)</span></span><br></pre></td></tr></table></figure>

<h4 id="覆盖重载函数"><a href="#覆盖重载函数" class="headerlink" title="覆盖重载函数"></a>覆盖重载函数</h4><p>和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。</p>
<p>一种好的解决方案是为重载的成员提供一条using声明语句（参见15.5节，第546页)，这样我们就无须覆盖基类中的每一个重载版本了。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见15.2.1节，第528页)，这样我们就能动态分配继承体系中的对象了。</p>
<p>当delete一个动态分配的对象的指针时执行析构函数，但如果指针指向了其“子孙”，则有可能出现指针静态类型与被删除对象的动态类型不符。所以必须在基类中将析构函数定义为析构函数保证函数的执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如果基类的析构函数不是虚函数,则delete一个指向派生类对象的基类指针将产生未定义的行为。</strong></p>
<p>在之前的准则中：如果一个类需要一个析构函数，那么它同样也需要拷贝和赋值操作。但基类的析构是一个重要的例外。它的虚函数并没有内容所以可以没有其他操作。</p>
<h4 id="虚析构函数阻止合成移动"><a href="#虚析构函数阻止合成移动" class="headerlink" title="虚析构函数阻止合成移动"></a>虚析构函数阻止合成移动</h4><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>这里的合成的拷贝，赋值或析构与普通类似，</p>
<p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构<br>函数类似:它们对类本身的成贝依城优对一个对象的直接基类部分进行初始化、赋值或销成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如，</p>
<ul>
<li>合成的Bulk quote默认构造函数运行Disc_quote 的默认构造函数，后者又运行Quote的默认构造函数。</li>
<li>Quote 的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0。</li>
<li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化 qty和discount。</li>
<li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它什么具体工作也不做。</li>
</ul>
<p>拷贝构造也是类似，此外基类成员是合成或自定义都没有影响，但唯一的要求是成员应该可以访问比关切不是被删除的。</p>
<p>如前所述，Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作。如我们即将看到的那样，Quote没有移动操作意味着它的派生类也没有。</p>
<h4 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h4><ul>
<li>如果基类中基础操作（构造、拷贝。。。）是删除的函数或不可访问，那么派生类对应的成员也是被删除的，因为派生类不能通过这些基类成员来为基类执行这些操作。</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</li>
<li>和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>();</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">//其他成员，不含有移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">	<span class="comment">//没有声明任何构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D d;					<span class="comment">//正确:D的合成默认构造函数使用B的默认构造函数</span></span><br><span class="line"><span class="function">D <span class="title">d2</span><span class="params">(d)</span></span>;				<span class="comment">//错误:D的合成拷贝构造函数是被删除的</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std: : move(d))</span></span>;	<span class="comment">//错误:隐式地使用D的被删除的拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h4><p>如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦 Quote定义了自己的移动操作，那么它必须同时显式地定义铂贝操作（参见13.6.2节，第476页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次进行默认初始化</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//移动赋值virtual ~Quote() = default;</span></span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数不仅仅要负责自己的成员初始化还有基类成员。而析构函数只负责销毁派生类自己分配的资源</p>
<p><strong>当派生类定义了拷贝或移动操作时,该操作负责铂贝或移动包括基类部分成员在内的整个对象。</strong></p>
<h4 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h4><p>派生类拷贝或移动构造通常是应用对应的基类构造来初始化对象的基类部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中</span></span><br><span class="line">    <span class="comment">//显式地调用该构造函数</span></span><br><span class="line">	<span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d) : <span class="built_in">Base</span>(d)</span><br><span class="line">		<span class="comment">//拷贝基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ...*/</span>	&#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">Base</span>(std : : <span class="built_in">move</span>(d))<span class="comment">//移动基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将D类型的对象d传递给基类的拷贝构造函数。这个构造负责将d的基类部分拷贝给要创建的对象。如果d并没有基类初始值，则默认初始化。</p>
<p><strong>在默认情况下,基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝(或移动)构造函数。</strong></p>
<h4 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h4><p>派生类的赋值运算符也必须显示地为其基类部分赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base: : operator=(const Base&amp;)不会被自动调用</span></span><br><span class="line">D D: :<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base: :<span class="keyword">operator</span>=(rhs); <span class="comment">//为基类部分赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类的成员赋值</span></span><br><span class="line">	<span class="comment">//酌情处理自赋值及释放已有资源等情况return *this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用基类的赋值操作无论基类的构造函数或赋值运算符是合成还是自定义，派生类的对应操作都能够使用它们。</p>
<h4 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h4><p>派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Base : : ~Base被自动调用执行</span></span><br><span class="line">	~<span class="built_in">D</span>() &#123;<span class="comment">/*该处由用户定义清除派生类成员的操作*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象销毁的顺序与创建的顺序相反。从子孙到祖先。</p>
<h4 id="在构造和析构函数中调用虚函数"><a href="#在构造和析构函数中调用虚函数" class="headerlink" title="在构造和析构函数中调用虚函数"></a>在构造和析构函数中调用虚函数</h4><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>一个类只能初始化的直接基类，一个类也只能继承其直接类的构造函数。类不能默认继承默认的拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为派生类合成。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。举个例子，我们可以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote : : Disc_quote;<span class="comment">//继承Disc_quote的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>生成的构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">derived</span> (parms) : <span class="built_in">base</span> (args)&#123; &#125;</span><br><span class="line"><span class="comment">//在我们的 Bulk_quote类中，继承的构造函数等价于:</span></span><br><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span></span></span><br><span class="line"><span class="params"><span class="function">	std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc)</span> :</span></span><br><span class="line"><span class="function">	Disc quote(book, price, qty, disc) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。</p>
<h4 id="继承的构造函数的特点"><a href="#继承的构造函数的特点" class="headerlink" title="继承的构造函数的特点"></a>继承的构造函数的特点</h4><p>和普通using不一样的是，构造函数的using声明不会改变构造函数的访问级别，且using声明也不能指定exlicit或者constexpr。继承的构造函数会具有相同的属性。</p>
<p>当基类的构造函数含有默认的实参时，这些实参并不会被继承，相反的是，派生类会获得多个继承的构造函数，每个构造函数分别省略掉由默认实参的形参。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p><strong>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”,因此容器和存在继承关系的类型无法兼容。</strong></p>
<h4 id="在容器中放置智能指针而非对象"><a href="#在容器中放置智能指针而非对象" class="headerlink" title="在容器中放置智能指针而非对象"></a>在容器中放置智能指针而非对象</h4><p>容器中防止继承关系的对象时，通常存放的是基类的指针（智能指针更好）。</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>我们定义一个表示购物篮的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Basket使用合成的默认构造函数和拷贝控制成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; sale)</span> </span>&#123; items.<span class="built_in">insert</span>(sale); &#125;</span><br><span class="line">	<span class="comment">//打印每本书的总价和购物篮中所有书的总价</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(std : : ostream&amp;)</span><span class="keyword">const</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//该函数用于比较shared_ptr，multiset成员会用到它</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs-&gt;<span class="built_in">isbn</span>() &lt; rhs-&gt;<span class="built_in">isbn</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//multiset保存多个报价，按照compare成员排序</span></span><br><span class="line">	std::multiset&lt;std::shared ptr&lt;Quote&gt;, <span class="keyword">decltype</span> (compare)*&gt; items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的类使用一个multiset（参见11.2.1节，第377页)来存放交易信息，这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在一起（参见11.2.2节，第 378页)。</p>
<p>这个声明看起来不太容易理解，但是从左向右读的话，我们就能明白它其实是定义了一个指向Quote对象的shared ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。multiset成员的名字是 items，我们初始化items并令其使用我们的compare函数。</p>
<h4 id="定义Basket的成员"><a href="#定义Basket的成员" class="headerlink" title="定义Basket的成员"></a>定义Basket的成员</h4><p>这个成员的名字是total_receipt，它负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Basket : : <span class="built_in">total_receipt</span>(ostream&amp; os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0.0</span>;		<span class="comment">//保存实时计算出的总价格</span></span><br><span class="line">	<span class="comment">// iter指向ISBN相同的一批元素中的第一个</span></span><br><span class="line">	<span class="comment">// upper_bound返回一个迭代器，该迭代器指向这批元素的尾后位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = items.<span class="built_in">cbegin</span>();</span><br><span class="line">			iter != items.<span class="built_in">cend</span>();</span><br><span class="line">			iter = items.<span class="built_in">upper_bound</span>(*iter))&#123;</span><br><span class="line">		<span class="comment">//我们知道在当前的Basket中至少有一个该关键字的元素</span></span><br><span class="line">        <span class="comment">//打印该书籍对应的项目</span></span><br><span class="line">		sum += <span class="built_in">print_total</span>(os, **iter, items.<span class="built_in">count</span>(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Total sale: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//打印最终的总价格</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的for循环中upper函数会跳过相同的书直接指到下一种书。此外在print_total函数中，第二个参数第一次解引用得到一个指向该对象的指针指针，再一次解引用才能得到这个Quto对象（或派生对象）。使用multiset统计有多少个相同元素。</p>
<h4 id="隐藏指针"><a href="#隐藏指针" class="headerlink" title="隐藏指针"></a>隐藏指针</h4><p>接下的需要定义add_item成员，先看使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.<span class="built_in">add_item</span> (make_shared&lt;Quote&gt; ( <span class="string">&quot;123&quot;</span>,<span class="number">45</span>));</span><br><span class="line">bsk,<span class="built_in">add_item</span> (make_shared&lt;Bulk_quote&gt; (<span class="string">&quot;345&quot;</span>，<span class="number">45</span>，<span class="number">3</span>，<span class="number">.15</span>));</span><br></pre></td></tr></table></figure>

<p>下一步重新定义add_item使它接受一个Quote对象而非shared_ptr，新版本的add_item将负责内存的分配。定义两个版本，一个拷贝它给定的对象，另一个采取移动操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span> </span>;			<span class="comment">//拷贝给定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(Quote&amp;&amp; sale)</span> </span>;				<span class="comment">//移动给定的对象</span></span><br></pre></td></tr></table></figure>

<p>此时遇到的问题是，函数不知道分配的类型，若<code>new Quote(sale)</code>，则可能不正确，传入其派生类的对象时，会被切掉一部分。</p>
<h4 id="模拟虚拷贝"><a href="#模拟虚拷贝" class="headerlink" title="模拟虚拷贝"></a>模拟虚拷贝</h4><p>我们给Quote添加一个虚函数，函数申请一份当前对象的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">	<span class="comment">//这些成员使用的引用限定符参见13.6.3节（第483页)</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">							</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span>(std : : <span class="built_in">move</span> (*<span class="keyword">this</span>)); &#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line">	<span class="function">Bulk_quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; <span class="params">(<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (*<span class="keyword">this</span>); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    Bulk_quote* clone () &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">						&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (std: : move ( *<span class="keyword">this</span>)) ;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">//其他成员与之前的版本一致</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<p>因为我们拥有add_item的拷贝和移动版本，所以我们分别定义clone的左值和右值版本。</p>
<p>使用clone写出新版的add_item:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span>	<span class="comment">//拷贝给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(std: :shared_ptr&lt;Quote&gt;(sale.<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span>		<span class="comment">//移动给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(</span><br><span class="line">			std: :shared_ptr&lt;Quote&gt;(std: :<span class="built_in">move</span>(sale).<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clone根据作用与左值右值分不同的版本，add_item也有调用不同版本的重载。Sale的动态类型决定了运行Quote还是Bulk_quote函数。然后为这个对象绑定智能指针放在容器内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  



  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>