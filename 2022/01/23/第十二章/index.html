<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="动态内存我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部static对象（就是局部对象加上static）、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，在其定义的程序块运行时才存在: static 对象在使用之前分配，在程序结束时销毁。 除了静态内存和栈内存，每个程">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 第十二章">
<meta property="og:url" content="http://mackrui.com/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:description" content="动态内存我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部static对象（就是局部对象加上static）、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，在其定义的程序块运行时才存在: static 对象在使用之前分配，在程序结束时销毁。 除了静态内存和栈内存，每个程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/QGMjaLHzpiNKeFV.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/UYdeStwyJBpqVKG.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/04/UGd3SAoe1xhXtra.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/04/H8pSNcUh6Z9yQzO.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/04/Swc3g5LlOX2bQsx.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/04/CaKVzphwGWYIXc4.png">
<meta property="article:published_time" content="2022-01-22T16:00:00.000Z">
<meta property="article:modified_time" content="2022-02-07T15:11:54.174Z">
<meta property="article:author" content="Collider">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="书籍">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/01/27/QGMjaLHzpiNKeFV.png">

<link rel="canonical" href="http://mackrui.com/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Primer 第十二章 | 祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer 第十二章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-23T00:00:00+08:00">2022-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-07 23:11:54" itemprop="dateModified" datetime="2022-02-07T23:11:54+08:00">2022-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
            <span id="/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="C++ Primer 第十二章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部static对象（就是局部对象加上static）、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，在其定义的程序块运行时才存在: static 对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间( free store)或堆(heap)。程序用堆来存储动态分配(dynamically allocate)的对象一即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>在C++中，动态内存的管理是通过一对运算符来完成的: <strong>new</strong>，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化; <strong>delete</strong>, 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
<p>新标准提供了两个智能指针类型类管理动态对象。他们行为类似常规指针，却可以自动的释放锁指向的对象，这两种指针的区别在于管理底层指针的方式：</p>
<p><strong>shared_ ptr</strong>允许多个指针指向同-一个对象; <strong>unique_ ptr</strong>则“独占”所指向的对象。标准库还定义了一个名为<strong>weak_ ptr</strong>的伴随类，它是一种弱引用，指向shared_ ptr所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>创建时我们也需要提供指向的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;				<span class="comment">// shared_ _ptr, 可以指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="keyword">int</span>&gt;&gt; p2;			<span class="comment">// shared_ ptr， 可以指向int的list</span></span><br></pre></td></tr></table></figure>

<p>默认初始化的指针中保存着一个空指针，</p>
<p>智能之后着呢使用方式与普通指针类似，解引用返回指向的对象，在if使用，是检测它是否为空：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果p1不为空，检查它是否指向一个空string</span></span><br><span class="line"><span class="keyword">if</span> (p1 &amp;&amp; pl-&gt;<span class="built_in">empty</span>())</span><br><span class="line">	*p1 = <span class="string">&quot;hi&quot;</span>; 			<span class="comment">//如果p1指向一个空string,解引用p1,将一个新值赋予string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/27/QGMjaLHzpiNKeFV.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/27/UYdeStwyJBpqVKG.png" alt="image.png"></p>
<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><p>他是最安全的分配和使用动态内存的方法，函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，一样要给出创建对象类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向一个值为42的int的shared_ ptr</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="comment">// p4指向一个值为&quot;999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="number">10</span>， <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line"><span class="comment">// p5指向一个值初始化的(参见3.3.1节，第88页)int,即，值为0</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;() ;</span><br></pre></td></tr></table></figure>

<p>通常使用auto来指向它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;() ;</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr拷贝和赋值"><a href="#shared-ptr拷贝和赋值" class="headerlink" title="shared_ptr拷贝和赋值"></a>shared_ptr拷贝和赋值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>

<p>每一个shared_ptr都会有一个关联的计数器，为引用计数。拷贝一个shared_ptr、作为参数传递给函数或者作为返回值就会递增，给shared_ptr赋予新值或者它被销毁计数器会递减。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_ shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// r指向的int只有一个引用者</span></span><br><span class="line">r = q;	<span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line">		<span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line">		<span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line">		<span class="comment">// r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr销毁管理对象"><a href="#shared-ptr销毁管理对象" class="headerlink" title="shared_ptr销毁管理对象"></a>shared_ptr销毁管理对象</h4><p>当指向一个对象的最后一个智能指针被销毁，指针的析构函数会递减指向对象的析构函数的引用计数，计数为0，指针的析构函数会销毁对象，释放内存。</p>
<p>且动态对象不再被使用时，shared_ptr类会自动的释放对象，特性使得动态内存的使用变得容易，例如在函数创建智能指针在离开作用域后会自动的释放掉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory 返回一个shared_ ptr, 指向一个动态分配的对象</span></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function">	<span class="comment">//恰当地处理arg</span></span></span><br><span class="line"><span class="function">	<span class="comment">// shared_ ptr负责释放内存</span></span></span><br><span class="line"><span class="function">	<span class="keyword">return</span> make_shared&lt;Foo&gt; <span class="params">(arg)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function">	shared_ptr&lt;Foo&gt; P </span>= <span class="built_in">factory</span>(arg) ;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">&#125; 	<span class="comment">// p离开了作用城，它指向的内存会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<h4 id="使用了动态生存期的资源的类"><a href="#使用了动态生存期的资源的类" class="headerlink" title="使用了动态生存期的资源的类"></a>使用了动态生存期的资源的类</h4><p>程序使用动态内存出于以下三种原因之一:</p>
<ol>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ol>
<p>目前使用的类分配资源都与对应对象生存期一致。例如每个vector拥有自己的元素，当拷贝一个vector时，原vector和副本vector是相互分离的。</p>
<p>如果我们希望有一个类，当它进行拷贝时，不是拷贝其中成员，而是不同对象之间共享相同的元素。所以当两个对象共享底层数据，当其中一个被销毁，我们不能单方面的销毁底层数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;string&gt; bl; <span class="comment">// 空Blob</span></span><br><span class="line">&#123; 	<span class="comment">//新作用域</span></span><br><span class="line">	Blob&lt;string&gt; b2 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">	bl = b2;<span class="comment">//bl和b2共享相同的元素</span></span><br><span class="line">&#125; 	<span class="comment">// b2被销毁了，但b2中的元素不能销毁</span></span><br><span class="line">	<span class="comment">// bl指向最初由b2创建的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="定义StrBlob"><a href="#定义StrBlob" class="headerlink" title="定义StrBlob"></a>定义StrBlob</h4><p>这里想要实现一个StrBlob类管理string元素，如果我们在类内直接使用一个vector来保存元素，那么当多个对象中的一个被销毁时就会把底层vector销毁，所以这里使用vector保存在动态内存中。</p>
<p>为了实现数据共享，我们为StrBlob设置一个shared_ptr来管理动态内存分配的vector。该指针可以记录有多少个StrBlob共享相同的vector。</p>
<p>还需要提供一些操作，当访问一个不存在的元素，会抛出异常，且有一个默认构造和单一构造：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrB1ob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="built_in">StrBlob</span>() ;</span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il) ;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>() ; &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> std: :string &amp;t)</span> </span>&#123;data-&gt;<span class="function">push_ <span class="title">back</span><span class="params">(t)</span></span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string&amp; <span class="title">front</span> <span class="params">()</span> </span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">back</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std::string &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="StrBlob构造函数"><a href="#StrBlob构造函数" class="headerlink" title="StrBlob构造函数"></a>StrBlob构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrBlob::<span class="built_in">StrB1ob</span> (): <span class="built_in">data</span> (make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span> (initializer_list&lt;string&gt; il) :</span><br><span class="line"><span class="built_in">data</span> (make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问成员函数"><a href="#元素访问成员函数" class="headerlink" title="元素访问成员函数"></a>元素访问成员函数</h4><p>由于操作访问函数需要先检查存不存在，所以定义一个私有的工具函数check：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="keyword">const</span> string &amp;msg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(i &gt;= data-&gt;size())</span>	</span></span><br><span class="line"><span class="function">	<span class="keyword">throw</span> <span class="title">out_of_range</span><span class="params">(msg)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他操作首先调用check，如成功则继续下一步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">StrBlob::front</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果vector为空，check 会抛出一个异常</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;front on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span> () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;back on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>) ;</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还应对front和back的const版本进行重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string&amp; <span class="title">StrBlob::front</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果vector为空，check 会抛出一个异常</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;front on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span> () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;back on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StrBlob的拷贝、赋值和销毁"><a href="#StrBlob的拷贝、赋值和销毁" class="headerlink" title="StrBlob的拷贝、赋值和销毁"></a>StrBlob的拷贝、赋值和销毁</h4><p>该类型对象被拷贝’赋值或者销毁时，执行相应操作的是shared_ptr成员而不是vector，直到最后一个指向vector的指针对象被销毁。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>还可以使用new和delete来分配内存，但非常容出错。</p>
<h4 id="使用new动态分配内存和初始化对象"><a href="#使用new动态分配内存和初始化对象" class="headerlink" title="使用new动态分配内存和初始化对象"></a>使用new动态分配内存和初始化对象</h4><p>new分配的内存是无名的，返回一个指向该对象的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; 			<span class="comment">// pi指向一个动态分配的、未初始化的无名对象</span></span><br><span class="line"><span class="comment">// 默认情况下，动态分配内存是默认初始化的，意味着内置类型或组合类型的值是未定义的。</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string; 	<span class="comment">//初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;			<span class="comment">// pi指向一个未初始化的int</span></span><br></pre></td></tr></table></figure>

<p>也可以使用列表初始化，或值初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);			<span class="comment">// pi指向的对象的值为1024</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>， <span class="string">&#x27;9&#x27;</span>);	<span class="comment">// *ps 为&quot;999999999&quot;</span></span><br><span class="line"><span class="comment">// vector 有10个元素，值依次从0到9</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">string *ps1 = <span class="keyword">new</span> string;			<span class="comment">//默认初始化为空string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>() ;			<span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pil = <span class="keyword">new</span> <span class="keyword">int</span>;					<span class="comment">//默认初始化; *pi1 的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();					<span class="comment">//值初始化为0; *pi2为0</span></span><br></pre></td></tr></table></figure>

<p>建议对动态分配的对象进行初始化操作。</p>
<p>如果提供了一个括号包围的初始化器，可以使用auto自动接管动态内存，但括号内必须仅有单一初始化器才可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span> (obj) ;				<span class="comment">// p指向一个与obj类型相同的对象</span></span><br><span class="line"><span class="comment">//该对象用obj进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125; ;				<span class="comment">// 错误:括号中只能有单个初始化器</span></span><br></pre></td></tr></table></figure>

<h4 id="动态分配const对象"><a href="#动态分配const对象" class="headerlink" title="动态分配const对象"></a>动态分配const对象</h4><p>一个动态内存的const对象必须进行初始化，对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显示初始化。new返回的也是一个const指针。</p>
<h4 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h4><p>当程序用光了所有可用内存，new就会失败，会抛出一个bad_alloc的异常，可以改变new的方式来阻止异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>; <span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p>这种new为<strong>定位new</strong>，这种形式允许我们传递额外参数，nothow就是告诉它不能抛出异常。以上类型都在头文件new中。</p>
<h4 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h4><p>我们使用delete来释放内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure>

<p>但传递给delete的指针必须是指向动态分配的内存或空指针，其他行为是未定义的。</p>
<p>const对象的值不能被改变，但是本身可以销毁，同样delete指向它的指针。</p>
<h4 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h4><p>如果不使用智能指针，那么必须显示的释放它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory 返回一个指针，指向一个动态分配的对象</span></span><br><span class="line"><span class="function">Foo* <span class="title">factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//视情况处理arg</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>(arg);	 <span class="comment">// 调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Foo *p = <span class="built_in">factory</span>(arg) ;	<span class="comment">//使用p但不delete它</span></span><br><span class="line">&#125;<span class="comment">//p离开了它的作用域，但它所指向的内存没有被释放!</span></span><br></pre></td></tr></table></figure>

<p>所以必须在use_factory中delete掉这个p，或者return出去让外部释放。</p>
<p><em>坚持使用智能指针，避免所有这些问题。</em></p>
<h4 id="delete之后重置指针"><a href="#delete之后重置指针" class="headerlink" title="delete之后重置指针"></a>delete之后重置指针</h4><p>delete指针之后，指针值就无效了，虽然指针已经无效，但有些仍保存着地址，为<strong>空悬指针</strong>：即指向一块曾经保存数据对象但现在已经无效的内存指针。</p>
<p>它和未初始化指针很像，解决办法是，在指针即将离开其作用域之前释放它所关联的内存，这样没有机会继续使用，也可以在delete之后给其赋值为nullptr。</p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>我们可以用new返回的指针来初始化智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">double</span>&gt; p1; 			<span class="comment">//shared_ ptr可以指向一个double</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; 	<span class="comment">//p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>接受参数的智能指针是explicit的，因此我们不能将一个内置指针隐式转换为智能指针，必须使用直接初始化形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">1024</span>);		<span class="comment">// 错误:必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;			<span class="comment">// 正确:使用了直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p) ; <span class="comment">// 错误:隐式转换为shared ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">shared_ ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> shared_ ptr&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p)) ;<span class="comment">//正确:显式地用int*创建shared_ ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可混用普通与智能指针"><a href="#不可混用普通与智能指针" class="headerlink" title="不可混用普通与智能指针"></a>不可混用普通与智能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>))</span> </span>;</span><br><span class="line"><span class="comment">//危险: x是一个普通指针，不是一个智能指针</span></span><br><span class="line"><span class="built_in">process</span>(x); <span class="comment">//错误:不能将int*转换为一个shared_ ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(shared_ptr&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">// 合法的，但内存会被释放!</span></span><br><span class="line"><span class="keyword">int</span> j = *x;<span class="comment">//未定义的:x是一个空悬指针!</span></span><br></pre></td></tr></table></figure>

<p>将临时的shared_ptr传递给函数，在调用结束后就会被销毁，则x变为空悬指针。</p>
<p>当将一个shared_ptr绑定到一个 普通指针时，我们就将内存的管理责任交给了这个shared_ptr.-旦这样做了 ，我们就不应该再使用内置指针来访问shared__ptr所指向的内存了。</p>
<h4 id="也不要使用get初始化另一个智能指针或者为智能指针赋值"><a href="#也不要使用get初始化另一个智能指针或者为智能指针赋值" class="headerlink" title="也不要使用get初始化另一个智能指针或者为智能指针赋值"></a>也不要使用get初始化另一个智能指针或者为智能指针赋值</h4><p>智能指针定义了名为get的函数，返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况二设计的：是为了不能使用智能指针的代码使用，但此指针不能delete。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//引用计数为1</span></span><br><span class="line"><span class="keyword">int</span> *q = p.<span class="built_in">get</span>(); <span class="comment">//正确:但使用q时要注意，不要让它管理的指针被释放</span></span><br><span class="line">&#123; <span class="comment">//新程序块</span></span><br><span class="line"><span class="comment">//未定义:两个独立的shared_ptr指向相同的内存</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; (q) ;</span><br><span class="line">&#125; <span class="comment">//程序块结束，q被销毁，它指向的内存被释放</span></span><br><span class="line"><span class="keyword">int</span> foo = *p; <span class="comment">//未定义: p指向的内存已经被释放了</span></span><br></pre></td></tr></table></figure>

<h4 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h4><p>使用reset将一个新指针赋予它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>) ;		<span class="comment">//错误:不能将一个指针赋予shared_ ptr</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">1024</span>)) ;	<span class="comment">//正确: p指向一个新对象</span></span><br></pre></td></tr></table></figure>

<p>通常与unique一起使用，控制多个shared_ptr共享的对象，检查自己是当前对象仅有的用户，如果不是，在改变之前要做一次新的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">	p.<span class="built_in">reset</span> (<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">// 我们不是唯一用户;分配新的拷贝</span></span><br><span class="line">*p += newVal; <span class="comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>

<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>在函数中使用智能指针，即使函数发生了异常，局部对象也会被销毁，而如果使用new，则在delete之前出现异常不会自动释放。</p>
<h4 id="智能指针指针和哑类"><a href="#智能指针指针和哑类" class="headerlink" title="智能指针指针和哑类"></a>智能指针指针和哑类</h4><p>有一些为C和C++两种语言设计的类，通常要求用户显示的释放所使用的任何资源。我们可以使用管理动态内存类似的技术管理不具有良好定义的析构函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span>						<span class="comment">//表示我们正在连接什么</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span>						<span class="comment">//使用连接所需的信息</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span> <span class="params">(destination*)</span> </span>;		<span class="comment">//打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connection)</span> </span>;			<span class="comment">//关闭给定的连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/*其他参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获得一个连接;记住使用完后要关闭它</span></span><br><span class="line">	connection C = <span class="built_in">connect</span>(&amp;d) ;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//如果我们在f退出前忘记调用disconnect,就无法关闭c了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果connection没有析构函数，就会造成内存泄漏，可以使用shared_ptr保证connection被正确关闭。</p>
<h4 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h4><p>首先定义一个函数来代替delete，这个<strong>删除器</strong>函数必须能够完成对shared_ptr保存的指针进行释放的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span> <span class="params">(connection *p)</span> </span>&#123; <span class="built_in">disconnect</span>(*p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(destination &amp;d <span class="comment">/*其他参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	connection C = <span class="built_in">connect</span> (&amp;d) ;</span><br><span class="line">	<span class="function">shared_ptr&lt;connection&gt; <span class="title">P</span><span class="params">(&amp;C, end_connection)</span> </span>;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//当f退出时(即使是由于异常而退出), connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当p被销毁时，他会使用end_connection来代替delste，从而确保链接关闭。</p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的<br>前提下。为了正确使用智能指针，我们必须坚持一些基本规范:</p>
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针。</li>
<li>不delete get()返回的指针。</li>
<li>不使用get()初始化或reset另一个智能指针。</li>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr“拥有”它所指的对象，且只能有一个unique_ptr指向给定对象，指针被销毁时对象也会被销毁。定义它时，没有make_shared类似的函数，需要绑定一个new返回的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ ptr &lt;<span class="keyword">double</span>&gt; p1; <span class="comment">//可以指向一个double的unique_ ptr</span></span><br><span class="line"><span class="function">unique_ ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>且不支持拷贝或赋值操作</p>
<p><img src="https://s2.loli.net/2022/02/04/UGd3SAoe1xhXtra.png" alt="image.png"></p>
<p>但可以通过调用release或reset将指针转移所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有权从p1 (指向string Stegosaurus)转移给p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">// release 将p1置为空</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">//将所有权从p3转移给p2</span></span><br><span class="line">p2.<span class="built_in">reset</span> (p3.<span class="built_in">release</span>()); <span class="comment">// reset 释放了p2原来指向的内存</span></span><br></pre></td></tr></table></figure>

<p>release成员返回unique_ptr当前保存的指针并置空，并且切断了它和原指针的联系，如果不移交给智能指针，一定要delete。</p>
<p>reset成员接受可选指针，然后重新指向给定指针。</p>
<h4 id="函数中的unique-ptr"><a href="#函数中的unique-ptr" class="headerlink" title="函数中的unique_ptr"></a>函数中的unique_ptr</h4><p>我们可以拷贝或赋值一个精要呗销毁的unique_ptr，如函数返回它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//正确:从int*创建一个unique_ ptr&lt;int&gt;</span></span><br><span class="line"><span class="keyword">return</span> unique_ ptr&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p) ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以返回一个局部对象的拷贝:</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (p) )</span> </span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种特殊的拷贝，将在之后介绍它。</p>
<h4 id="传递删除器"><a href="#传递删除器" class="headerlink" title="传递删除器"></a>传递删除器</h4><p>与shared_ptr类似，可以重载删除器，一样需要提供删除器类型，在创建或reset时提供指定类型的可调用的删除器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT, delT&gt; <span class="title">P</span> <span class="params">(<span class="keyword">new</span> objT, fcn)</span> </span>;</span><br></pre></td></tr></table></figure>

<p>用unique_ptr代替shared_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/*其他需要的参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	connection c = <span class="built_in">connect</span> (&amp;d); <span class="comment">//打开连接</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接将会关闭</span></span><br><span class="line">	<span class="function">unique_ptr&lt;connection, <span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">P</span><span class="params">(&amp;C， end_connection)</span> </span>;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//当f退出时(即使是由于异常而退出), connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中我们使用了decltype来指明函数指针类型。由于decltype (end_ connection) 返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>它是一种不控制所指向对象生存期的智能指针，它指向由一个shared（后面都简写）管理的对象将weak绑定到shared不会增加shared的引用计数，计数归0，即使有weak对象也会被释放。weak名字意为这种指针“弱”共享对象。</p>
<p><img src="https://s2.loli.net/2022/02/04/H8pSNcUh6Z9yQzO.png" alt="image.png"></p>
<p>创建weak时需要用shared初始化它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> P = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; <span class="comment">// wp弱共享p; p的引用计数未改变</span></span><br></pre></td></tr></table></figure>

<p>因为weak若共享特性，它指向的对象可能不存在，所以在访问时必须调用lock判断，它返回一个指向共享对象的shared：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">//如果np不为空则条件成立</span></span><br><span class="line"><span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核查指针类"><a href="#核查指针类" class="headerlink" title="核查指针类"></a>核查指针类</h4><p>如果将StrBolb类定义一个伴随指针，保存一个weak_ptr，指向StrBolob的data成员，使用weak不会影响StrBlob指向vector的生存期，但可以阻止用户访问不存在的vector。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于访问一个不存在元素的尝试，StrBlobPtr抛出一个异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StrBlobPtr</span>():<span class="built_in">curr</span> (<span class="number">0</span>) &#123; &#125;</span><br><span class="line">	<span class="built_in">StrBlobPtr</span>(StrB1ob &amp;a， <span class="keyword">size_t</span> sz = <span class="number">0</span>) :</span><br><span class="line">	<span class="built_in">wptr</span>(a.data)，<span class="built_in">curr</span>(sz) &#123; &#125;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">deref</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">StrBlobPtr&amp; <span class="title">incr</span><span class="params">()</span></span>; <span class="comment">// 前缀递增</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check返回一个指向vector的shared_ptr</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">	<span class="built_in">check</span>(std::<span class="keyword">size_t</span>，<span class="keyword">const</span> std::string&amp;) <span class="keyword">const</span> ;</span><br><span class="line">	<span class="comment">//保存一个weak_ptr,意味着底层vector可能会被销毁</span></span><br><span class="line">	std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">	std::<span class="keyword">size_t</span> curr; <span class="comment">// 在数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此类需要注意不能将StrBlobPtr绑定到一个const StrBlob对象是因为构造函数只接受非const对象的引用</p>
<p>check函数也与之前不同需要检查指向的vector是否还存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;std: :vector&lt;std: :string&gt;&gt;</span><br><span class="line">StrBlobPtr::<span class="built_in">check</span>(std::<span class="keyword">size_t</span> i, <span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> ret = wptr.<span class="built_in">lock</span>(); <span class="comment">// vector还存在吗?</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">&quot;unbound StrBlobPtr&quot;</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= ret-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span> (msg) ;</span><br><span class="line">	<span class="keyword">return</span> ret; <span class="comment">// 否则，返回指向vector的shared_ptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><p>现在我们将定义deref和incr的函数来解引用和递增StrBlobPtr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">StrBlobPtr::deref</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> (*p)[curr]; <span class="comment">// (*p) 是对象所指向的vector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前缀递增:返回递增后的对象的引用</span></span><br><span class="line"><span class="function">StrBlobPtr&amp; <span class="title">StrBlobPtr::incr</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果curr已经指向容器的尾后位置，就不能递增它</span></span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot; increment past end of StrBlobPtr&quot;</span>) ;</span><br><span class="line">	++curr; <span class="comment">//推进当前位置</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外为了访问data成员需要声明StrBlob的friend</span></span><br><span class="line"><span class="comment">//对于StrBlob 中的友元声明来说， 此前置声明是必要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line">	<span class="comment">//其他成员与12.1.1节(第405页)中声明相同</span></span><br><span class="line">	<span class="comment">//返回指向首元素和尾后元素的StrBlobPtr</span></span><br><span class="line">	<span class="function">StrBlobPtr <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">StrBlobPtr</span>(*<span class="keyword">this</span>) ; &#125;</span><br><span class="line">	<span class="function">StrBlobPtr <span class="title">end</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">auto</span> ret = <span class="built_in">StrBlobPtr</span>(*<span class="keyword">this</span>， data-&gt;<span class="built_in">size</span>()); <span class="keyword">return</span> ret;&#125;</span><br><span class="line">    <span class="comment">//这里就是</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>如果需要可变数量的对象时，可以使用在StraBlob中采取的方法。</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用get_size确定分配多少个int</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">get_size</span>()]; <span class="comment">// pia指向第一个int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用一个表示数组类型的类型别名分配：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];	<span class="comment">// arrT表示42个int的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;		<span class="comment">//分配一个42个int的数组; p指向第一个int</span></span><br></pre></td></tr></table></figure>

<p>最后的代码等于<code>int *P new int[42];</code></p>
<p>在分配后得到元素类型的指针，所以不能使用begin或end，不可以用范围for来处理动态数组的元素</p>
<p><strong>要记住我们所说的动态数组并不是数组类型，这是很重要的。</strong></p>
<h4 id="初始化动态分配的数组"><a href="#初始化动态分配的数组" class="headerlink" title="初始化动态分配的数组"></a>初始化动态分配的数组</h4><p>可以使用默认初始化或者值初始化（跟一对空括号）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];				<span class="comment">// 10 个未初始化的int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]() ;		<span class="comment">// 10个值初始化为0的int</span></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>] ;		<span class="comment">// 10个空string .</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>](); 	<span class="comment">// 10 个空string</span></span><br></pre></td></tr></table></figure>

<p>还可以提供初始化器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10个int分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//10个string,前4个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>]&#123;<span class="string">&quot;a&quot;</span>， <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>) &#125;;</span><br></pre></td></tr></table></figure>

<p>与内置初始化一样，初始化器会初始化开始部分的元素，剩余执行值初始化。</p>
<p>我们不可以在括号内给出初始化器，且不能用auto分配数组。</p>
<h4 id="动态分配空数组"><a href="#动态分配空数组" class="headerlink" title="动态分配空数组"></a>动态分配空数组</h4><p>可以用任意表达式唉确定分配相对数目</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = <span class="built_in">get_size</span>(); 	<span class="comment">//get_size 返回需要的元素的数目</span></span><br><span class="line"><span class="keyword">int</span>* P = <span class="keyword">new</span> <span class="keyword">int</span>[n];		<span class="comment">//分配数组保存元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>* q = p; q != p + n; ++q) .</span><br><span class="line">	<span class="comment">/*处理数组*/</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即使为0，也能够正常运作</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">0</span>] ;			<span class="comment">//错误:不能定义长度为0的数组.</span></span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]; <span class="comment">// 正确:但cp不能解引用</span></span><br></pre></td></tr></table></figure>

<p>cp可以就像尾后迭代器一样使用</p>
<h4 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> P;		<span class="comment">// p必须指向一个动态分配的对象或为空</span></span><br><span class="line"><span class="keyword">delete</span> [] pa; 	<span class="comment">//pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure>

<p>释放元素是按逆序销毁，且方括号是必须的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>] ;		<span class="comment">// arrT是42个int的数组的类型别名</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;			<span class="comment">//分配一个42个int的数组; p指向第一个元素</span></span><br><span class="line"><span class="keyword">delete</span> [] p;				<span class="comment">//方括号是必需的，因为我们当初分配的是一个数组</span></span><br></pre></td></tr></table></figure>

<h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><p>标准库提供了一个可以管理new分配的数组的unique版本。但必须在对象后跟一对空方括号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//up指向一个包含10个未初始化int的数组</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">up</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span> </span>;</span><br><span class="line">up.<span class="built_in">release</span>(); <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>

<p>当一个unique指向一个数组时，我们可以使用下标运算来访问数组中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="number">10</span>; ++i)</span><br><span class="line">	up[i] = i; <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/04/Swc3g5LlOX2bQsx.png" alt="image.png"></p>
<p>与unique不同的是shared不支持管理动态数组。如果希望使用shared管理动态数组需要自定义删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr，必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]， [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] P; &#125;)</span> </span>;</span><br><span class="line">sp.<span class="built_in">reset</span>(); <span class="comment">//使用我们提供的lambda释放数组，它使用delete []</span></span><br></pre></td></tr></table></figure>

<p>这里直接传递一个lambda表达式作为删除器。如果不提供删除器，则后果与delete不加[]一样。此外他也不支持下标运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ ptr未定义下标运算符，并且不支持指针的算术运算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="number">10</span>; ++i)</span><br><span class="line">	* (sp.<span class="built_in">get</span>() + i) = i; <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure>

<p>所以只能使用get获取内置指针来访问数组元素</p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些缺陷：因为它将内存分配与对象构造组合在一起，所以会导致不必要的浪费：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string *<span class="keyword">const</span> P = <span class="keyword">new</span> string[n]; <span class="comment">// 构造n个空string</span></span><br><span class="line">string s;</span><br><span class="line">string *q = P;		<span class="comment">// q指向第一个string</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; s &amp;&amp; q != P + n)</span><br><span class="line">	*q++ = s;			<span class="comment">//赋予*q一个新值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> size = q - P;		<span class="comment">//记住我们读取了多少个string</span></span><br><span class="line"><span class="comment">//使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// P指向一个数组;记得用delete[]来释放</span></span><br></pre></td></tr></table></figure>

<p>这里创建了n个string，但可能并不需要这么多，所以造成了浪费。</p>
<h4 id="新的方法allocalltor"><a href="#新的方法allocalltor" class="headerlink" title="新的方法allocalltor"></a>新的方法allocalltor</h4><p>它定义在头文件memory中，帮助我们将内存分配和对象构造分开。分配时需要给出类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;				<span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> P = alloc.<span class="built_in">allocate</span> (n) ;		<span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/04/CaKVzphwGWYIXc4.png" alt="image.png"></p>
<h4 id="分配未构造的内存"><a href="#分配未构造的内存" class="headerlink" title="分配未构造的内存"></a>分配未构造的内存</h4><p>使用alloc.construct构造对象，额外的参数用于调用对象的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; 						<span class="comment">//q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);				<span class="comment">//*q为空字符串</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++，<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);		<span class="comment">//*q为cccccccccc  </span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hi&quot;</span>);			 <span class="comment">//*q为hi !</span></span><br></pre></td></tr></table></figure>

<p>在没有构造的情况下访问内存试错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *p &lt;&lt;endl; <span class="comment">//正确:使用string的输出运算符</span></span><br><span class="line">cout &lt;&lt; *q &lt;&lt;endl; <span class="comment">//灾难:q指向未构造的内存!</span></span><br></pre></td></tr></table></figure>

<p>当用完对象后，必须对每个构造元素调用destroy来销毁它们。接受一个指针对指向对象执行析构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">	alloc.<span class="built_in">destroy</span>(--q);<span class="comment">//释放我们真正构造的string</span></span><br></pre></td></tr></table></figure>

<p>销毁元素后可以重新使用内存，也可以归还系统</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n) ;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，第二个大小参数必须与调用allocate时一样。</p>
<h4 id="拷贝和填充未初始化内存"><a href="#拷贝和填充未初始化内存" class="headerlink" title="拷贝和填充未初始化内存"></a>拷贝和填充未初始化内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配比vi中元素所占用空间大一倍的动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p = alloc.<span class="built_in">allocate</span>(vi.<span class="built_in">size</span> () * <span class="number">2</span>);</span><br><span class="line"><span class="comment">//通过拷贝vi中的元素来构造从p开始的元素</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">uninitialized_copy</span> (vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), p);</span><br><span class="line"><span class="comment">//将剩余元素初始化为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(g, vi.<span class="built_in">size</span>() , <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用标准库：文本查询程序"><a href="#使用标准库：文本查询程序" class="headerlink" title="使用标准库：文本查询程序"></a>使用标准库：文本查询程序</h2><p>此部分将单独作为一章。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
              <a href="/tags/%E4%B9%A6%E7%B1%8D/" rel="tag"># 书籍</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" rel="prev" title="C++ Primer 第十一章">
      <i class="fa fa-chevron-left"></i> C++ Primer 第十一章
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/" rel="next" title="C++ Primer文本查询程序">
      C++ Primer文本查询程序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NDkwMi8zMTM3MQ"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.1.</span> <span class="nav-text">动态内存与智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr%E7%B1%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">shared_ptr类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#make-shared%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">make_shared函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">shared_ptr拷贝和赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">shared_ptr销毁管理对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8A%A8%E6%80%81%E7%94%9F%E5%AD%98%E6%9C%9F%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E7%B1%BB"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">使用了动态生存期的资源的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89StrBlob"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">定义StrBlob</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StrBlob%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">StrBlob构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">元素访问成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StrBlob%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E9%94%80%E6%AF%81"><span class="nav-number">1.1.1.8.</span> <span class="nav-text">StrBlob的拷贝、赋值和销毁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">1.1.2.</span> <span class="nav-text">直接管理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8new%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">使用new动态分配内存和初始化对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8Dconst%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">动态分配const对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">内存耗尽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">释放动态内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F%E7%9B%B4%E5%88%B0%E8%A2%AB%E9%87%8A%E6%94%BE%E6%97%B6%E4%B8%BA%E6%AD%A2"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">动态对象的生存期直到被释放时为止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete%E4%B9%8B%E5%90%8E%E9%87%8D%E7%BD%AE%E6%8C%87%E9%92%88"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">delete之后重置指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">shared_ptr和new结合使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E6%B7%B7%E7%94%A8%E6%99%AE%E9%80%9A%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">不可混用普通与智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%9F%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8get%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%BA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">也不要使用get初始化另一个智能指针或者为智能指针赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96shared-ptr%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">其他shared_ptr操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.1.4.</span> <span class="nav-text">智能指针和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%8C%87%E9%92%88%E5%92%8C%E5%93%91%E7%B1%BB"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">智能指针指针和哑类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">使用自己的释放操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-ptr"><span class="nav-number">1.1.5.</span> <span class="nav-text">unique_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84unique-ptr"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">函数中的unique_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%88%A0%E9%99%A4%E5%99%A8"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">传递删除器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak-ptr"><span class="nav-number">1.1.6.</span> <span class="nav-text">weak_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E6%9F%A5%E6%8C%87%E9%92%88%E7%B1%BB"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">核查指针类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">指针操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.</span> <span class="nav-text">动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">new和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">初始化动态分配的数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%A9%BA%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">动态分配空数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">释放动态数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">智能指针和动态数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allocator%E7%B1%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">allocator类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95allocalltor"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">新的方法allocalltor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%AA%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">分配未构造的内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%A1%AB%E5%85%85%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">拷贝和填充未初始化内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9A%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">使用标准库：文本查询程序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>