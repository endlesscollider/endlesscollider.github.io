<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="拷贝控制拷贝、赋值与销毁拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。 1234567class Foo &amp;#123;public:	Foo() ;	&#x2F;&#x2F;默认构造函数	Foo (const Foo&amp;);&#x2F;&#x2F;拷贝构造函数    &#x2F;&#x2F; ...&amp;#125;;  第一个参数必须是引用，且通常都是const的，拷贝构造通常是隐式使用">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 第十三章">
<meta property="og:url" content="http://mackrui.com/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:description" content="拷贝控制拷贝、赋值与销毁拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。 1234567class Foo &amp;#123;public:	Foo() ;	&#x2F;&#x2F;默认构造函数	Foo (const Foo&amp;);&#x2F;&#x2F;拷贝构造函数    &#x2F;&#x2F; ...&amp;#125;;  第一个参数必须是引用，且通常都是const的，拷贝构造通常是隐式使用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-26T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-04T04:57:30.305Z">
<meta property="article:author" content="Collider">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="书籍">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mackrui.com/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Primer 第十三章 | 祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">43</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer 第十三章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-27T00:00:00+08:00">2022-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:57:30" itemprop="dateModified" datetime="2022-03-04T12:57:30+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>() ;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Foo</span> (<span class="keyword">const</span> Foo&amp;);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数必须是引用，且通常都是const的，拷贝构造通常是隐式使用，不应该是explicit的。</p>
<h4 id="合成的拷贝构造"><a href="#合成的拷贝构造" class="headerlink" title="合成的拷贝构造"></a>合成的拷贝构造</h4><p>无论我们有没有定义其他拷贝构造，编译器都会自动和合成一个拷贝构造函数。合成的拷贝构造函数会从给定对象中依次将每个非static成员拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定了它如何拷贝:对类类型的成员，会使用其拷贝构造函数来拷贝;内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。</p>
<h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span> <span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(dots)</span> </span>;<span class="comment">//直接初始化</span></span><br><span class="line">string s2 = dots;<span class="comment">//拷贝初始化</span></span><br><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line">string nines = <span class="built_in">string</span> (<span class="number">100</span>,<span class="string">&#x27;9&#x27;</span>) ;<span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>

<p>如果类中有一个移动构造函数，则拷贝初始化有时会使用移动构造而非拷贝构造，所谓移动构造就是指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。所以我们应了解何时发生拷贝构造：</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生·</p>
<ul>
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p>
</li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p>
</li>
<li><p>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>
</li>
</ul>
<p>此外当初始化标准容器或调用insert或push时，会使用拷贝初始化，而emplace成员创建的元素都是直接初始化。</p>
<h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>函数调用过程中，具有非引用类型的参数都要进行拷贝初始化，函数返回值为非引用时，返回值也会被用来做为接受对象拷贝初始化的参数。</p>
<p>所以拷贝初始化的参数必须是引用类型，不然就一直调用也不会成功。</p>
<h4 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h4><p>值初始化和拷贝初始化不是一模一样的，如果使用explicit构造函数，我们就不能隐式的调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//正确:直接初始化</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;<span class="comment">//错误:接受大小参数的构造函数是explicit的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;)</span></span>;<span class="comment">// f的参数进行拷贝初始化</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//错误:不能用一个explicit的构造函数考贝一个实参</span></span><br><span class="line"><span class="built_in">f</span>(vector&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>));<span class="comment">//正确:从一个int直接构造一个临时vector</span></span><br></pre></td></tr></table></figure>

<p>必须显示的调用explicit函数。</p>
<h4 id="编译器可以绕过拷贝构造函数"><a href="#编译器可以绕过拷贝构造函数" class="headerlink" title="编译器可以绕过拷贝构造函数"></a>编译器可以绕过拷贝构造函数</h4><p>拷贝/移动构造可以被忽略，直接创建对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="comment">//改写为</span></span><br><span class="line"><span class="function">string <span class="title">null_book</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>; <span class="comment">//编译器略过了拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>可以跳过拷贝/移动构造，但必须有且可访问。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><h4 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h4><p>重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数（参见7.1.2节，第231页)。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Foo&amp;); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>赋值运算符应该返回一个引用！</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>和前几个构造函数一样，如果类内未定义，就会自动生成。作为一个例子，下面的代码等价于sales_data的合成拷贝赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sales_data&amp; Sales_data::<span class="keyword">operator</span>= (<span class="keyword">const</span> Sales_data &amp;rhs) &#123;</span><br><span class="line">	bookNo = rhs.bookNo;<span class="comment">//调用string : : operator=</span></span><br><span class="line">	units_sold = rhs.units_sold;<span class="comment">//使用内置的int赋值</span></span><br><span class="line">	revenue = rhs.revenue;<span class="comment">//使用内置的double赋值</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回一个此对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它和拷贝构造函数的区别是，拷贝构造是从无到有，而拷贝赋值时本来就有，只是值发生改变。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>它与构造函数相反，构造函数初始化非static数据成员，还有其他工作，析构函数释放对象使用资源，销毁对象非static数据成员。它没有返回值，也不接受参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Foo</span>();<span class="comment">//析构函数</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于没有参数，所以不能被重载。</p>
<h4 id="函数任务"><a href="#函数任务" class="headerlink" title="函数任务"></a>函数任务</h4><p>它所有顺序都与构造函数相反，先执行函数体，然后销毁成员，且按出现次序逆序销毁。且析构部分时隐式的，销毁完全取决与类型。</p>
<p><em>隐式销毁内置指针类型的成员不会delete指向的对象</em></p>
<h4 id="何时调用析构"><a href="#何时调用析构" class="headerlink" title="何时调用析构"></a>何时调用析构</h4><p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line"><span class="comment">// p和p2指向动态分配的对象</span></span><br><span class="line">	Sales_data *p = <span class="keyword">new</span> sales_data;		<span class="comment">// p是一个内置指针</span></span><br><span class="line">	<span class="keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();<span class="comment">// p2是一个shared_ptr</span></span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;	<span class="comment">//拷贝构造函数将*p拷贝到item中</span></span><br><span class="line">	vector&lt;sales_data&gt; vec;	<span class="comment">//局部对象</span></span><br><span class="line">	vec.<span class="built_in">push_back</span> (*p2);	<span class="comment">//拷贝 p2指向的对象</span></span><br><span class="line">    <span class="keyword">delete</span> p;	<span class="comment">//对p指向的对象执行析构函数</span></span><br><span class="line">&#125;<span class="comment">//退出局部作用域;对item、p2和vec调用析构函数</span></span><br><span class="line"><span class="comment">//销毁p2会递减其引用计数;如果引用计数变为0，对象被释放//销毁vec会销毁它的元素</span></span><br></pre></td></tr></table></figure>

<p><em>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</em></p>
<h4 id="合成的析构函数"><a href="#合成的析构函数" class="headerlink" title="合成的析构函数"></a>合成的析构函数</h4><p>概念如前，下面等同合成析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员会被自动销毁，除此之外不需要做其他事情</span></span><br><span class="line">    ~<span class="built_in">Sales_data</span>() &#123; &#125;</span><br><span class="line">	<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><h4 id="需要析构函数的类也需要拷贝和拷贝赋值"><a href="#需要析构函数的类也需要拷贝和拷贝赋值" class="headerlink" title="需要析构函数的类也需要拷贝和拷贝赋值"></a>需要析构函数的类也需要拷贝和拷贝赋值</h4><p>如果一个类需要析构函数，那么肯定也需要一个拷贝函数和一个拷贝赋值运算符。例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std: : string &amp;s = std: :<span class="built_in">string</span> () ):</span><br><span class="line">		<span class="built_in">ps</span>(<span class="keyword">new</span> std: :<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line">	<span class="comment">//错误:HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用合成拷贝，则会简单的拷贝指针成员，则有可能多个对象指向相同内存。</p>
<h4 id="需要拷贝操作的类也需要赋值，反之亦然"><a href="#需要拷贝操作的类也需要赋值，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值，反之亦然"></a>需要拷贝操作的类也需要赋值，反之亦然</h4><p>作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个铂贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是，这个类不需要自定义析构函数。</p>
<h3 id="使用-defult"><a href="#使用-defult" class="headerlink" title="使用=defult"></a>使用=defult</h3><p>这段代码可以显示的要求编译生成合成版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//拷贝控制成员;使用default</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">sales_data</span>(<span class="keyword">const</span> sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    sales_data&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> sales_data &amp;);</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>使用此语句，合成函数将隐式声明为内联，如果不希望是内联的，应该对类外使用它（如上面的拷贝赋值）。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>对于某些类来说，拷贝和赋值时没有意义的，如iostream，所以组织拷贝，以避免多个对象的写入过读取相同的IO缓冲。</p>
<h4 id="定义删除的函数"><a href="#定义删除的函数" class="headerlink" title="定义删除的函数"></a>定义删除的函数</h4><p>通过将拷贝和拷贝赋值函数定义为<strong>删除的函数</strong>来组织拷贝，这是一种我们虽然声明，但不能使用的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">	<span class="built_in">Nocopy</span> () = <span class="keyword">default</span>;	<span class="comment">//使用合成的默认构造函数</span></span><br><span class="line">	<span class="built_in">NoCopy</span>(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">//阻止拷贝</span></span><br><span class="line">	NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Nocopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;	<span class="comment">//使用合成的析构函数</span></span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与=default不同：</p>
<ul>
<li>=delete必须在函数第一次声明的时候出现，而=default知道编译器生成代码时才需要，可以出现在定义处。</li>
<li>另一个是可以对任意函数使用（虽然主要是阻止拷贝），但=default只可以使用在有合成版本的函数。</li>
</ul>
<h4 id="析构函数不能删除"><a href="#析构函数不能删除" class="headerlink" title="析构函数不能删除"></a>析构函数不能删除</h4><p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。所以不可删除。</p>
<h4 id="合成的拷贝控制成员可能是删除的"><a href="#合成的拷贝控制成员可能是删除的" class="headerlink" title="合成的拷贝控制成员可能是删除的"></a>合成的拷贝控制成员可能是删除的</h4><p>本质上，这些规则的含义是:如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。</p>
<h4 id="private拷贝控制"><a href="#private拷贝控制" class="headerlink" title="private拷贝控制"></a>private拷贝控制</h4><p>新标准以前，组织是通过将函数放在private里的，但现在应该使用=delete。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>类行对象有两种拷贝语意，一种像值：拷贝像值对象，副本和源对象完全独立，改变副本不会对源对象有影响，如string。一种像指针：拷贝这种对象，共同使用底层数据，改变自己也会改变源对象，如shared_ptr。</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>像值的行为，每个对象应该拥有一份自己的拷贝。HasPtr</p>
<ul>
<li>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</li>
<li>定义一个析构函数来释放string</li>
<li>定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝string</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">		<span class="built_in">ps</span> (<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="comment">//对ps指向的string，每个HasPtr对象都有自己的拷贝</span></span><br><span class="line">    <span class="built_in">HasPtr</span> (<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">		<span class="built_in">ps</span> (<span class="keyword">new</span> std::<span class="built_in">string</span>(*p.ps)) , <span class="built_in">i</span>(p.i) &#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="类值拷贝赋值运算符"><a href="#类值拷贝赋值运算符" class="headerlink" title="类值拷贝赋值运算符"></a>类值拷贝赋值运算符</h4><p>赋值类运算符通常是组合了析构和构造函数，赋值的操作其实会销毁左侧运算对象的资源，其次需要保证再异常发发生时代码也是安全的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span> ( *rhs.ps); <span class="comment">//拷贝底层string</span></span><br><span class="line">	<span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">	ps = newp;<span class="comment">//从右侧运算对象拷贝数据到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写赋值运算符时，有两点需要记住:</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和铂贝构造函数的工作。</li>
</ul>
<p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后,销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
<p>如果直接删除自身数据，然后将指针指向赋予对象的数据，那么在将自身赋予自身时就会出现访问无效内存的异常。</p>
<h3 id="定义行为像指针"><a href="#定义行为像指针" class="headerlink" title="定义行为像指针"></a>定义行为像指针</h3><p>这个类拷贝指针成员本身不是它指向的string，我们的类拷贝时拷贝的是指针而不是指向的对象。同时在析构时也需要在最后一个指向对象的HasPtr销毁时，销毁对象。</p>
<p>这时就需要一个类似引用计数的东西，类似shared_ptr。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>它的工作方式：</p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
</ul>
<p>计时器不可以放在类中，否则无法正确更新它，最好的办法就是保存在动态内存中，把它当作底层数据，多个对象共享，同样在最后一个指向它的对象销毁时销毁。</p>
<h4 id="定义使用引用计数的类"><a href="#定义使用引用计数的类" class="headerlink" title="定义使用引用计数的类"></a>定义使用引用计数的类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数分配新的string和新的计数器，将计数器置为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span> ()):</span><br><span class="line">		<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p) :</span><br><span class="line">		<span class="built_in">ps</span>(p.ps) , <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123;++*use;&#125;</span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">	~<span class="built_in">HasPtr</span> ();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *ps;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	std::<span class="keyword">size_t</span> *use; <span class="comment">//用来记录有多少个对象共享*ps 的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="拷贝与析构"><a href="#拷贝与析构" class="headerlink" title="拷贝与析构"></a>拷贝与析构</h4><p>当拷贝时，应该复制指针本身，并且递增关联的计数器。析构不能无脑delete，必须注意计数器数量，到0才可以delete。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span> (―-*use ==<span class="number">0</span>)&#123;<span class="comment">//如果引用计数变为0</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">//释放string内存</span></span><br><span class="line">		<span class="keyword">delete</span> use; <span class="comment">//释放计数器内存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	++*rhs.use; <span class="comment">//递增右侧运算对象的引用计数</span></span><br><span class="line">	<span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;<span class="comment">//然后递减本对象的引用计数</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">//如果没有其他用户</span></span><br><span class="line">		<span class="keyword">delete</span> use;<span class="comment">//释放本对象分配的成员</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;	<span class="comment">//将数据从rhs拷贝到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>通常的资源管理类都会有swap函数。如果类定义了自己的swap，算法将使用自定义版本，否则会使用标准库的swap，一次交换操作实际上包含了一次拷贝和两次赋值。如：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp = v1;	//创建v1的值的一个临时副本</span><br><span class="line">v1 = v2.;	//将v2的值赋予v1</span><br><span class="line">v2 = temp;	//将保存的v1的值赋予v2</span><br></pre></td></tr></table></figure>

<p>但理论上可以省取这些内存分配的过程，直接交换指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *temp = v1.ps;	<span class="comment">//为v1.ps中的指针创建一个副本</span></span><br><span class="line">vl.ps = v2.ps;	<span class="comment">//将v2.ps 中的指针赋予v1.ps</span></span><br><span class="line">v2.ps = temp;	<span class="comment">//将保存的v1.ps中原来的指针赋予v2.ps</span></span><br></pre></td></tr></table></figure>

<h4 id="编写swap函数"><a href="#编写swap函数" class="headerlink" title="编写swap函数"></a>编写swap函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp; )</span> </span>;</span><br><span class="line">    <span class="comment">//其他成员定义，与13.2.1节（第 453页）中一样</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(HasPtr &amp;lhs,HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span> (lhs.ps, rhs.ps);	<span class="comment">//交换指针，而不是string数据</span></span><br><span class="line">    <span class="built_in">swap</span> (lhs.i, rhs.i) ;	<span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将swap定义为friend，一遍能够访问HasPtr的数据成员。swap不是必要的，但是重要的优化手段。</p>
<h4 id="与std-swap不同"><a href="#与std-swap不同" class="headerlink" title="与std::swap不同"></a>与std::swap不同</h4><p>使用时不应该加上std::</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span> ( lhs.h, rhs.h) ; <span class="comment">//使用HasPtr版本的swap</span></span><br><span class="line">    <span class="comment">//交换类型Foo的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在赋值运算中使用swap"><a href="#在赋值运算中使用swap" class="headerlink" title="在赋值运算中使用swap"></a>在赋值运算中使用swap</h4><p>定义swap后会用来用它定义赋值运算符。是将左侧对象与右侧对象的副本进行交换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数</span></span><br><span class="line"><span class="comment">//将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交换左侧运算对象和局部变量rhs的内容</span></span><br><span class="line">	<span class="built_in">swap</span> (*<span class="keyword">this</span>, rhs);	<span class="comment">// rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//rhs被销毁，从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此版本参数不是引用，因此右侧传递进来的是一个副本，所以不需要额外的拷贝操作，它保证异常安全的同时也与原来的赋值运算实现一样。</p>
<h2 id="拷贝控制示例（单独成章）"><a href="#拷贝控制示例（单独成章）" class="headerlink" title="拷贝控制示例（单独成章）"></a>拷贝控制示例（单独成章）</h2><h2 id="动态内存管理类（单独成章）"><a href="#动态内存管理类（单独成章）" class="headerlink" title="动态内存管理类（单独成章）"></a>动态内存管理类（单独成章）</h2><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准中有可以移动而非拷贝的能力。很多时候对象拷贝完立刻被销毁了，移动可以大大提升性能。移动的另一个原因是源于IO类或unique_ptr这样的类包含不能被共享的资源，所以可以移动不能拷贝。</p>
<p><em>标准库容器、string和shared ptr类既支持移动也支持拷贝。IO类和unique ptr类可以移动但不能拷贝。</em></p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>符号为&amp;&amp;，它必须绑定到右值且只能绑定到一个将要销毁的对象，所以可以自由的移动到另一个对象中。</p>
<p>回忆左值和右值：一般而言，一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值。</p>
<p>右值引用也不过是对象的另一个名字，对于常规引用，我们可以称之为左值引用。</p>
<p>区别：我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;<span class="keyword">int</span> &amp;r n i;	<span class="comment">//正确:r引用i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;			<span class="comment">//错误:不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;		<span class="comment">//错误:i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>;<span class="comment">//正确:我们可以将一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;		<span class="comment">//正确:将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。<ul>
<li>我们可以将一个左值引用绑定到这类表达式的结果上。</li>
</ul>
</li>
<li>返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。<ul>
<li>我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const的左值引用或者一个右值引用绑定到这类表达式上。</li>
</ul>
</li>
</ul>
<h4 id="左值持久：右值短暂"><a href="#左值持久：右值短暂" class="headerlink" title="左值持久：右值短暂"></a>左值持久：右值短暂</h4><p>考察左值和右值表达式的列表，两者相互区别之处就很明显了:左值有持久的状态,而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。所以</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<h4 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h4><p>变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是,我们不能将一个右值引用绑定到一个右值引用类型的变量上,这有些令人惊讶:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;<span class="comment">//正确:字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">//错误:表达式rr1是左值!</span></span><br></pre></td></tr></table></figure>

<p>其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。</p>
<h4 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h4><p>虽然不能将右值引用绑定到左值，但可以显示将左值转换为对应右值引用类型，我们可以调用move来获得绑定到左值上的右值引用，在头文件utility中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span> (rr1); l l ok</span><br></pre></td></tr></table></figure>

<p>move对左值使用之后，可以像右值一样处理，但之后除了赋值或者销毁它外，但不能使用该对象的值。且应该直接使用std::move。</p>
<h3 id="移动构造和移动赋值函数"><a href="#移动构造和移动赋值函数" class="headerlink" title="移动构造和移动赋值函数"></a>移动构造和移动赋值函数</h3><p>我们可以为自己的类定义移动操作，他们就是从给定对象窃取而不是拷贝资源。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态—–销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源—–这些资源的所有权已经归属新创建的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strVec::<span class="built_in">strVec</span> (strVec &amp;&amp;s) <span class="keyword">noexcept</span><span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line"><span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">	: <span class="built_in">elements</span> (s.elements), <span class="built_in">first_free</span> (s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">	s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与拷贝构造函数不同，移动构造函数不分配任何新内存;它接管给定的Strvec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。strVec的析构函数在first_free 上调用deallocate。如果我们忘记了改变s.first free，则销毁移后源对象就会释放掉我们刚刚移动的内存。</p>
<h4 id="移动操作与异常"><a href="#移动操作与异常" class="headerlink" title="移动操作与异常"></a>移动操作与异常</h4><p>由于移动操作不分配任何资源，所以不会抛出任何异常，我们应该将此事通知给标准库，提升一些性能消耗。</p>
<p>方法就是在小括号之后冒号之前加上noexcept</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strvec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Strvec</span>(strvec&amp; &amp;)<span class="keyword">noexcept</span>; <span class="comment">//移动构造函数//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">	StrVec::<span class="built_in">StrVec</span> (StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/*成员初始化器*/</span>&#123;<span class="comment">/*构造函数体*/</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p>它与移动构造函数一个，应该标记为noexcept：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//直接检测自赋值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">		<span class="built_in">free</span>();	<span class="comment">//释放已有元素</span></span><br><span class="line">		elements = rhs.elements; <span class="comment">//从rhs接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">		cap = rhs.cap;</span><br><span class="line">		<span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">		rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多了一步操作就是检测this与rhs地址是否相同，也就是是否是同一个对象（这也是赋值运算需要重点考虑的：将自身赋予自身时能否不出错）。如果相同什么都不用做。</p>
<h4 id="移后源可以析构"><a href="#移后源可以析构" class="headerlink" title="移后源可以析构"></a>移后源可以析构</h4><p>编写移动操作必须保证移后对象可析构，在strVec中，将移后源对象的指针成员设置为nullptr来实现。</p>
<h4 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h4><p>编译器不会为某些类生成合成的移动函数，如果没有移动函数，类会使用对应的拷贝操作来代替移动。</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasx合成移动操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;			<span class="comment">//内置类型可以移动</span></span><br><span class="line">	std::string s;	<span class="comment">//string定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasx</span> &#123;</span></span><br><span class="line">	X mem;			<span class="comment">//×有合成的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">X x,x2 = std::<span class="built_in">move</span>(x) ;<span class="comment">//使用合成的移动构造函数</span></span><br><span class="line">hasx hx,hx2 = std::<span class="built_in">move</span> (hx) ;<span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>移动操作只有当我们显示要求编译器生成=default的移动操作而却不是所有成员都可以移动时才会将移动操作定义为删除的函数。</p>
<h4 id="移动右值，拷贝左值"><a href="#移动右值，拷贝左值" class="headerlink" title="移动右值，拷贝左值"></a>移动右值，拷贝左值</h4><p>如果一共类既有移动函数也有拷贝构造函数，那么会根据匹配规则使用，如在strvec类中，拷贝构造函数接受一个 const strvec的引用。因此，它可以用于任何可以转换为strVec的类型。而移动构造函数接受一个strVec&amp;&amp;，因此只能用于实参是（非static）右值的情形:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2 ;</span><br><span class="line">v1 = v2;					<span class="comment">// v2是左值;使用拷贝赋值</span></span><br><span class="line"><span class="function">Strvec <span class="title">getvec</span><span class="params">(istream &amp;)</span></span>;	<span class="comment">// getvec返回一个右值</span></span><br><span class="line">v2 = <span class="built_in">getvec</span> (cin) ;			<span class="comment">// getVec (cin)是一个右值;使用移动赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="如果没有移动构造，会调用拷贝"><a href="#如果没有移动构造，会调用拷贝" class="headerlink" title="如果没有移动构造，会调用拷贝"></a>如果没有移动构造，会调用拷贝</h4><p>由于不会默认合成移动构造，所以用拷贝代替，且是绝对安全的</p>
<h4 id="拷贝赋值和移动赋值合并"><a href="#拷贝赋值和移动赋值合并" class="headerlink" title="拷贝赋值和移动赋值合并"></a>拷贝赋值和移动赋值合并</h4><p>如果为类添加一个移动构造函数，实际上也会获得移动赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//添加的移动构造函数</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : <span class="built_in">ps</span> (p.ps), <span class="built_in">i</span>(p.i)&#123;p.ps = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">//赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">						&#123; <span class="built_in">swap</span> (*<span class="keyword">this</span>, rhs); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="comment">//其他成员的定义，同13.2.1节（第453页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<strong>左值被拷贝，右值被移动</strong>。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。<br>例如，假定hp和 hp2都是HasPtr对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp = hp2; <span class="comment">// hp2是一个左值;hp2通过拷贝构造函数来拷贝</span></span><br><span class="line">hp = std::<span class="built_in">move</span> (hp2);<span class="comment">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>

<p><strong>建议:更新三/五法则</strong><br>所有五个拷贝控制成员应该看作一个整体:一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义持贝构造函数、拷贝赋值运算符和析构函数才能正确工作。一般来说拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
              <a href="/tags/%E4%B9%A6%E7%B1%8D/" rel="tag"># 书籍</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" rel="prev" title="C++ Primer 第十二章">
      <i class="fa fa-chevron-left"></i> C++ Primer 第十二章
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" rel="next" title="C++ Primer 第十四章">
      C++ Primer 第十四章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NDkwMi8zMTM3MQ"></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-number">1.1.</span> <span class="nav-text">拷贝、赋值与销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">合成的拷贝构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">参数和返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">拷贝初始化的限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%BB%95%E8%BF%87%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">编译器可以绕过拷贝构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">拷贝赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">重载赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">合成的拷贝赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">函数任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">何时调用析构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">合成的析构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-number">1.1.4.</span> <span class="nav-text">三&#x2F;五法则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E4%B9%9F%E9%9C%80%E8%A6%81%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">需要析构函数的类也需要拷贝和拷贝赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E4%B9%9F%E9%9C%80%E8%A6%81%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%BA%A6%E7%84%B6"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">需要拷贝操作的类也需要赋值，反之亦然</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-defult"><span class="nav-number">1.1.5.</span> <span class="nav-text">使用&#x3D;defult</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.6.</span> <span class="nav-text">阻止拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">定义删除的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%88%A0%E9%99%A4"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">析构函数不能删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E5%8F%AF%E8%83%BD%E6%98%AF%E5%88%A0%E9%99%A4%E7%9A%84"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">合成的拷贝控制成员可能是删除的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#private%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">private拷贝控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">拷贝控制和资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">行为像值的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%80%BC%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">类值拷贝赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88"><span class="nav-number">1.2.2.</span> <span class="nav-text">定义行为像指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">定义使用引用计数的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">拷贝与析构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">交换操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99swap%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">编写swap函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8Estd-swap%E4%B8%8D%E5%90%8C"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">与std::swap不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E4%B8%AD%E4%BD%BF%E7%94%A8swap"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">在赋值运算中使用swap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%8D%95%E7%8B%AC%E6%88%90%E7%AB%A0%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">拷贝控制示例（单独成章）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%EF%BC%88%E5%8D%95%E7%8B%AC%E6%88%90%E7%AB%A0%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">动态内存管理类（单独成章）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.6.</span> <span class="nav-text">对象移动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E6%8C%81%E4%B9%85%EF%BC%9A%E5%8F%B3%E5%80%BC%E7%9F%AD%E6%9A%82"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">左值持久：右值短暂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%98%AF%E5%B7%A6%E5%80%BC"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">变量是左值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93move%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">标准库move函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">移动构造和移动赋值函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">移动操作与异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">移动赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%90%8E%E6%BA%90%E5%8F%AF%E4%BB%A5%E6%9E%90%E6%9E%84"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">移后源可以析构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">合成的移动操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%8F%B3%E5%80%BC%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%B7%A6%E5%80%BC"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">移动右值，拷贝左值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%EF%BC%8C%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">如果没有移动构造，会调用拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E5%90%88%E5%B9%B6"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">拷贝赋值和移动赋值合并</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz',
      appKey     : '6k9HROMoqf6vzPadEMksx26r',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>