<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第十六章定义模板1234567&#x2F;&#x2F;如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1int compare(const string&amp; v1, const string&amp; v2) &amp;#123;	if (vl &lt; v2) return -l; if (v2 &lt; v1) return 1; return 0;&amp;#125;int compare(const doub">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 第十六章">
<meta property="og:url" content="http://mackrui.com/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:description" content="第十六章定义模板1234567&#x2F;&#x2F;如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1int compare(const string&amp; v1, const string&amp; v2) &amp;#123;	if (vl &lt; v2) return -l; if (v2 &lt; v1) return 1; return 0;&amp;#125;int compare(const doub">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png">
<meta property="article:published_time" content="2022-02-14T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-04T04:58:42.910Z">
<meta property="article:author" content="Collider">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="书籍">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png">

<link rel="canonical" href="http://mackrui.com/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Primer 第十六章 | 祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">24</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer 第十六章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-15T00:00:00+08:00">2022-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:42" itemprop="dateModified" datetime="2022-03-04T12:58:42+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
            <span id="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="C++ Primer 第十六章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> string&amp; v1, <span class="keyword">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl &lt; v2) <span class="keyword">return</span> -l; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; v1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于像这样除了类型意外一模一样的函数，我们可以使用模板来适配各种各样的类型。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板，而不是为每一个类型定义一个新的函数。则compare的模板可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; vl) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板定义以关键字template开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(&lt;)和大于号(&gt;）包围起来。</p>
<p><strong>在模板定义中,模板参数列表不能为空。</strong></p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>调用一个函数模板时，编译器用函数的实参来推断模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt; endl; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>

<p>编译会推断出实参int，并绑定到T，这样推断出来的为我们<strong>实例化</strong>一个特定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T为int</span></span><br><span class="line"><span class="comment">//实例化出int compare (const vector&lt;int&gt;&amp;,const vector&lt;int&gt;&amp;)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;, vec2&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1, vec2) &lt;&lt;endl; <span class="comment">// T为vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里编译器会实例化两个不同版本的compare。其中一个T为int，另一个T为vector<int>，编译器生成的版本成为模板的实例。</p>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>我们的compare函数有一个模板类型参数(type parameter)。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:返回类型和参数类型相同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">Tfoo</span> (T* p)&#123;</span><br><span class="line">	T tmp = *p; <span class="comment">// tmp 的类型将是指针p指向的类型/ / ...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数前必须使用关键字class或typename:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:U之前必须加上class或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;)</span> </span>;</span><br><span class="line"><span class="comment">//正确:在模板参数列表中,typename和class没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="built_in">calc</span> (<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;) ;</span><br></pre></td></tr></table></figure>

<p>因为可以使用非类的类型作为模板实参，所以使用typename更为直观。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了模板参数，我们还可以定义非类型参数，简言之就是一个固定的值，当模板被实例化后，非类型模板参数就被这个值所取代，这个值也必须时常量表达式，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span> (p1, p2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span> ( <span class="string">&quot;hi&quot;</span>, <span class="string">&#x27;mom&quot;)</span></span><br></pre></td></tr></table></figure>

<p>最后编译器使用字面常量大小代替N和M：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1) [<span class="number">3</span>],<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。</p>
<p>通常在需要常量表达式的地方需要用到此参数。</p>
<h4 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:inline说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误:inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>通过const＋引用的方式，我们保证了函数可以用于不能拷贝的类型。</p>
<p>此外，我们没必要即使用<code>&lt;</code>又使用<code>&gt;</code>运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//期望的比较操作</span></span><br><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -l;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//即使用于指针也正确的compare版本;参见14.8.2节（第510页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">( less&lt;T&gt;()(vl, v2))</span> <span class="keyword">return</span> -1</span>;</span><br><span class="line"><span class="keyword">if</span> ( less&lt;T&gt;() (v2, v1)) <span class="keyword">return</span> l;<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的（据查阅资料，less<T>的默认实现用的就是&lt;，所以这其实并未起到让这种比较有一个良好定义的作用—译者注)。</p>
<p><strong>模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>编译器遇到模板时，只有当实例化除模板特例时，才会生成代码。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同:为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>关键概念:模板和头文件</strong></p>
<p>模板包含两种名字:</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p>当使用模板时,所有不依赖于模板参数的名字都必须是可见的,这是由模板的提供者来保证的。而且,模板的提供者必须保证，当模板被实例化时,模板的定义,包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件,包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件,以及用来实例化模板的任何类型的头文件。</p>
<h4 id="实例化器件错误报告"><a href="#实例化器件错误报告" class="headerlink" title="实例化器件错误报告"></a>实例化器件错误报告</h4><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<p>例如原始版本的<code>if (vl &lt; v2) return -l;//要求类型T的对象支持&lt;操作</code>其中如果调用者传入类型没有<code>&lt;</code>运算符，则会在第三个阶段报错。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板是用来蓝图的，编译器不能为类推断参数类型。必须在尖括号中提供额外的信息，用来代替参数的模板实参列表。</p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>我们实现StrBlib的模板版本，为Bolb，不在针对string，使用时用户需要指出元素类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t ypedef T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;T&gt; : :size_type size_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: : initializer_list&lt;T&gt; il);</span><br><span class="line">	<span class="comment">// Blob中的元素数目</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="comment">//移动版本，参见13.6.3节（第484页)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std : : <span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (size_type i); <span class="comment">// 在14.5节(第501页)中定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: : shared ptr&lt;std : : vector&lt;T&gt;&gt; data;<span class="comment">//若data[i]无效，则抛出msg</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std: :string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例如，我们将元素访问操作的返回类型定义为T&amp;。当用户实例化Blob时，T就会被替换为特定的模板实参类型。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>使用类模板时，提供额外信息，这些信息实际上是显示模板实参列表，它们被绑定到模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;					<span class="comment">//空Blob&lt;int&gt;</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; 	<span class="comment">//有5个元素的Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是编译器生成一个类似这样的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;<span class="keyword">int</span>&gt;: :size_type size_type; </span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: :initializer_list&lt;<span class="keyword">int</span>&gt; il); <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: :shared ptr&lt;std: :vector&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std : : string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联,也不会对任何其他B1ob类型的成员有特殊访问权限。</strong></p>
<h4 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h4><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的data 成员使用了两个模板，vector和 shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是Blob的模板参数。因此，data的定义如下:</p>
<p><code>std: :shared_ ptr&lt;std: : vector&lt;T&gt;&gt; data;</code></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</p>
<p>当我们定义一个成员函数时，模板实参与模板形参相同。对于strBlob的一个给定的成员函数</p>
<p><code>ret-type StrBlob : : member-name(parm-list)</code></p>
<p>对应的Blob的成员应该是这样的:</p>
<p><code>template &lt;typename T&gt; ret-type Blob&lt;T&gt;: :member-name(parm-list)</code></p>
<h4 id="check和元素访问成员"><a href="#check和元素访问成员" class="headerlink" title="check和元素访问成员"></a>check和元素访问成员</h4><p>我们首先定义check成员，它检查一个给定的索引:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">check</span>(size_type i,<span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;=data-&gt;<span class="built_in">size</span> ())</span><br><span class="line">		<span class="keyword">throw</span> std: :<span class="built_in">out_of_range</span>(msg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用模板参数指出返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;: : <span class="built_in">back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>); <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt; : : <span class="keyword">operator</span>[](size_type i) &#123;</span><br><span class="line">	<span class="comment">//如果i太大，check会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    <span class="built_in">check</span> (i, <span class="string">&quot;subscript out of range&quot;</span> ) ;</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pop_back函数与原StrBlob的成员几乎相同:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Blob构造函数"><a href="#Blob构造函数" class="headerlink" title="Blob构造函数"></a>Blob构造函数</h4><p>与类模板外函数一样，构造函数先定义模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span> (std: :make_shared&lt;std: :vector&lt;T&gt;&gt;())&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>分配一个空vcector，并将指向vector的指针保存在data中，还要有接受一个initializer_list参数的构造函数将其类型参数工作为initializer list参数的元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std: :initializer_list&lt;T&gt; il):</span><br><span class="line">			<span class="built_in">data</span>(std: :make_shared&lt;std: :vector&lt;T&gt;&gt;(il))&#123; &#125;	</span><br></pre></td></tr></table></figure>

<p>为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob的元素类型兼容:</p>
<p><code>Blob&lt;string&gt; articles = &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot; &#125;;</code></p>
<h4 id="类模板成员的实例化"><a href="#类模板成员的实例化" class="headerlink" title="类模板成员的实例化"></a>类模板成员的实例化</h4><p>只有当程序用到它时才会进行实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; squares = &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt; : :size ( ) const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != squares.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	squares[i] = i*i;<span class="comment">//实例化Blob&lt;int&gt; : : operator[] (size_t)</span></span><br></pre></td></tr></table></figure>

<p>实例化了 Blob<int>类和它的三个成员函数: operator[ ] 、 size和接受initializer_list<int>的构造函数。</p>
<p><strong>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
<h4 id="在类内简化模板类名"><a href="#在类内简化模板类名" class="headerlink" title="在类内简化模板类名"></a>在类内简化模板类名</h4><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若试图访问一个不存在的元素，BlobPtr抛出一个异常template &lt;typename T&gt; class BlobPtr &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, <span class="keyword">size_t</span> sz - <span class="number">0</span>):</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; </span><br><span class="line">        <span class="comment">// (*p)为本对象指向的vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递增和递减</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置运算符</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--( );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check 返回一个指向vector的shared_ptr</span></span><br><span class="line">	std: :shared_ptr&lt;std: :vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std : : <span class="keyword">size_t</span>, <span class="keyword">const</span> std : : string&amp;) <span class="keyword">const</span>; </span><br><span class="line">	<span class="comment">// 保存一个weak ptr，表示底层vector可能被销毁</span></span><br><span class="line">	std : : weak_ptr&lt;std : : vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std : : <span class="keyword">size_t</span> curr; <span class="comment">//数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在递增和递减函数中，我们返回的是BlobPtr&amp;，而不使用BlobPtr<T>&amp;，因为当处于一个类模板的作用域时，自身引用时就等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>

<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>由于在类外，只有遇到类名才代表进入类的作用域，所以类外函数返回自身需要使用BlobPtr<T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置:递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;: :<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查;调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//保存当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>;<span class="comment">//推进一个元素;前置++检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数体已经进入类内，所以可以直接使用BlobPtr。</p>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</strong></p>
<h4 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h4><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<h4 id="一对一友好关系"><a href="#一对一友好关系" class="headerlink" title="一对一友好关系"></a>一对一友好关系</h4><p>我们的Blob类应该将BlobPtr类和模板版本的Blob相等运算符定义为友元，此外我们在Blob加入可以用==运算符的友元函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在 Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span><span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;); </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">		(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">	<span class="comment">//其他成员定义，与12.1.1（第405页）相同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里在Blob类中出现的5个T，说明它将对应的类与函数声明为友元，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;<span class="comment">// BlobPtr&lt;char&gt;和operator==&lt;char&gt;都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;<span class="comment">// BlobPtr&lt;int&gt;和operator==&lt;int&gt;都是本对象的友元</span></span><br></pre></td></tr></table></figure>

<h4 id="通过和特定的模板友好关系"><a href="#通过和特定的模板友好关系" class="headerlink" title="通过和特定的模板友好关系"></a>通过和特定的模板友好关系</h4><p>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> &#123;</span><span class="comment">//C是一个普通的非模板类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;<span class="comment">//用类c实例化的Pal是c的一个友元/l Pal2的所有实例都是c的友元;这种情况无须前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">c2</span> &#123;</span><span class="comment">// C2本身是一个类模板</span></span><br><span class="line">	<span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;; <span class="comment">// Pal的模板声明必须在作用域之内</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> x&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">	<span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span><span class="comment">//不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
<h4 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Type; <span class="comment">//将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成为Bar<Foo>的友元，sales data将成为Bar<Sales data>的友元，依此类推。</p>
<h4 id="模板的类型别名"><a href="#模板的类型别名" class="headerlink" title="模板的类型别名"></a>模板的类型别名</h4><p>可以给已经实例化的类起别名：<code>typedef Blob&lt;string&gt; StrBlob;</code>模板起别名的方式为则不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以固定多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">// books是一个pair&lt;string,unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars是一个pair&lt;Vehicle,unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids是一个pair&lt;Student,unsigned&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>类模板也可以声明static成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> std: :<span class="function"><span class="keyword">size_t</span> <span class="title">count</span> <span class="params">()</span></span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">//其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> std: : <span class="keyword">size_t</span> ctr;<span class="comment">//其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的static成员会在同一个类型内共享，如Foo<X>这个类型的所有对象，共享这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化static成员Foo&lt;string&gt; ::ctr和Foo&lt;string&gt; : :count</span></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line"><span class="comment">//所有三个对象共享相同的Foo&lt;int&gt; : :ctr和Foo&lt;int&gt; : : count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2,fi3;</span><br></pre></td></tr></table></figure>

<p>数据成员也同样如此，且必须有且仅有一个定义，所有该特定类的对象共享此成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt; : : ctr = <span class="number">0</span>; <span class="comment">//定义并初始化ctr</span></span><br></pre></td></tr></table></figure>

<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问static成员，我们必须引用一个特定的实例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;						<span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">count</span> () ;	 <span class="comment">//实例化Foo&lt;int&gt; ; :count</span></span><br><span class="line">ct = fi.<span class="built_in">count</span> ();					<span class="comment">//使用Foo&lt;int&gt; : : count</span></span><br><span class="line">ct= Foo: :<span class="built_in">count</span> ();					<span class="comment">//错误:使用哪个模板实例的count?</span></span><br></pre></td></tr></table></figure>

<p>static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板参数的名字不仅可以是T还可以是其他任何命名。</p>
<h4 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h4><p>一个模板参数可用范围是在其声明之后，至模板声明或定义结束之前。与其他任何名字一样的是模板参数隐藏外层作用域声明的相同的名字，不同的是，在模板内不能重用模板参数名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a,B b)</span></span></span><br><span class="line"><span class="function">	A tmp </span>= a;<span class="comment">// tmp的类型为模板参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;<span class="comment">//错误:重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于模板名字不能重用，所以在模板参数列表也只能出现一次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:非法重用模板参数名v</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> v, <span class="keyword">typename</span> v&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>模板的声明必须包括模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明但不定义compare和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
<h4 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h4><p>由于使用：：运算符在模板参数上就会有困难，如：T：：men，它不知道men声明类型成员和static数据成员，所以必须知道这个T是否表示一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>如果希望使用一个类型成员就必须显示使用typename关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p><strong>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用 class。</strong></p>
<h4 id="默认的模板实参"><a href="#默认的模板实参" class="headerlink" title="默认的模板实参"></a>默认的模板实参</h4><p>就像函数的默认实参一样，我们也可以为模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2，Ff = <span class="built_in">F</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(vl, v2) ) <span class="keyword">return</span> -l;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户调用时，可以自己提供，也可以使用默认的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = <span class="built_in">compare</span> (<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//使用less; i为-1</span></span><br><span class="line"><span class="comment">//结果依赖于item1和item2中的isbn</span></span><br><span class="line"><span class="function">sales_data <span class="title">item1</span><span class="params">(cin)</span>, <span class="title">item2</span><span class="params">(cin)</span> </span>;</span><br><span class="line"><span class="keyword">bool</span> j = <span class="built_in">compare</span> (iteml, item2,compareIsbn);</span><br></pre></td></tr></table></figure>

<p>与函数默认实参一样,对于一个模板参数,只有当它右侧的所有参数都有默认实参时它才可以有默认实参。</p>
<h4 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h4><p>同样的，类可以使用默认模板参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> &#123;</span><span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Numbers</span>(T V = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line">	<span class="comment">//对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>

<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><h4 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h4><p>若一个普通类中有一个模板函数，便被称为成员模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象类，对给定指针执行delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DebugDelete</span>(std::ostream&amp; s = std::cerr) :<span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">	<span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std : : endl; <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::ostream &amp; os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个类似unique_ptr的使用的默认删除器，根据不同的类型进行销毁操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">//可像delete表达式一样使用的对象</span></span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用 DebugDelete: :operator() (double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在一个临时 DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip) ;</span><br></pre></td></tr></table></figure>

<p>我们就可以用这个类型替换unique_ptr中的删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁p指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;int&gt; (int *)</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>，DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>,DebugDelete())</span></span>;</span><br><span class="line"><span class="comment">//销毁sp指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;string&gt; (string* )</span></span><br><span class="line"><span class="function">unique _ptr&lt;string,DebugDelete&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> string,DebugDelete() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>当unique_ptr析构函数调用时，De—类便会实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebugDelete的成员模板实例化样例</span></span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">int</span> *p) <span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>()(string *p)<span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h4><p>类和成员有各自的模板，即可以像这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="built_in">Blob</span> (It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::<span class="built_in">Blob</span> (It b, It e):</span><br><span class="line">		<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h4><p>为了实例化上一个模板类的成员模板，我们必须同时提供类和函数的实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] =&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">long</span>&gt; vi = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; w = &#123; <span class="string">&quot;now&quot;</span> , <span class="string">&quot;is&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;time&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类及其接受两个int*参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span> <span class="params">(begin(ia), end (ia))</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt; : :iterator的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin (), vi.end ())</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;string&gt;及其接受两个list&lt;const char*&gt; : :iterator参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;string&gt; <span class="title">a3</span> <span class="params">( w.begin (), w.end ())</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义a1时就实例化了如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">Blob</span> (<span class="keyword">int</span>* , <span class="keyword">int</span>* );</span><br></pre></td></tr></table></figure>

<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板,并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>在新标准中，我们可以通过显式实例化(explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;		<span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;				<span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">//declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</span></span><br><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;				<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>

<p>编译器遇到extern声明时，它不会在本文件中生成实例化代码，而是承诺其他地方有这样的实例化，我现在只是使用它，对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p>extern声明必须在任何使用此实例之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cc</span></span><br><span class="line"><span class="comment">//这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sal,sa2; <span class="comment">//实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; al = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(al)</span></span>; <span class="comment">//拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">compare</span>(a1 [<span class="number">0</span>],a2[<span class="number">0</span>]);<span class="comment">//实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>

<p>上面的这些使用extern的实例必须在其他地方有定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">//实例化文件必须为每个在其他文件中声明为extern 的类型和函数提供一个(非extern)的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;<span class="comment">//实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>

<p><strong>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
<h4 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h4><p><strong>在一个类模板的实例化定义中,所用类型必须能用于模板的所有成员函数。</strong></p>
<h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>unique_ptr避免了间接调用删除其的运行时开销，而shared_ptr使用户可以重载删除器。前者有效率，后者有灵活度。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li>const转换:可以将一个非 const对象的引用（或指针）传递给一个const的引用（或指针）形参。</li>
<li>数组或函数指针转换:如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T，T)</span></span>;<span class="comment">//实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 引用</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">s2</span> <span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);<span class="comment">//调用fobj(string,string); const被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);<span class="comment">//调用fref(const string&amp;, const string&amp;)</span></span><br><span class="line"><span class="comment">//将s1转换为const是允许的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b) ;</span><br><span class="line"><span class="comment">//调用f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a,b);</span><br><span class="line"><span class="comment">//错误:数组类型不匹配</span></span><br></pre></td></tr></table></figure>

<p>在最后一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针(参见6.2.4节，第195页)。a和 b的类型是不匹配的，因此调用是错误的。</p>
<p><strong>将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有const转换及数组或函数到指针的转换。</strong></p>
<h4 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h4><p>模板的参数只允许几种有限的类型转换，因此传递的这些形参必须具有相同的类型。我们的compare函数接受两个const T&amp;参数，其实参必须是相同类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);<span class="comment">//错误:不能实例化compare (long, int)</span></span><br></pre></td></tr></table></figure>

<p>如果希望可以类型转换，可以将函数模板定义为两个类型参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span> <span class="params">(<span class="keyword">const</span> A&amp; v1,<span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl&lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2&lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cout,<span class="number">42</span>); <span class="comment">//实例化print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span> <span class="params">( <span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span> (f，<span class="number">10</span>);<span class="comment">//使用print (ostream&amp;, int);将f转换为ostream&amp;</span></span><br></pre></td></tr></table></figure>

<p>第一个函数参数是一个已知类型ostream&amp;。第二个参数 obj 则是模板参数类型。由于os 的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换:</p>
<p><strong>如果函教参教类型不是模板参数，则对实参进行正常的类型转换。</strong></p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>某些时候模板参数无法推断除类型，允许用户控制模板实例化。</p>
<h4 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h4><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">Tl <span class="title">sum</span><span class="params">(T2，T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没有任何参数可供推断出T1的类型，所以调用时必须提供一个显示模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);<span class="comment">// long long sum(int，long)</span></span><br></pre></td></tr></table></figure>

<p>显式模板实参时一一对应的，只有右边的可以忽略，但必须可以从函数参数推断出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//糟糕的设计:用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span> <span class="params">(T2,T1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则我们总是必须为所有三个形参指定实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; (i, lng) ;<span class="comment">//正确:显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>，<span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>所以把需要显示提供的参数放在最前面</p>
<h4 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h4><p>如果模板类型参数已经显式指定，页可以进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);					<span class="comment">//错误:模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare (long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare(int,int)</span></span><br></pre></td></tr></table></figure>

<p>第一个调用由于类型不匹配错误，后面的调用由于显式指定，而可以进行正常的类型转换。</p>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span> (It beg, It end)&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不知道返回结果的准确类型，但所需类型是所处理的序列的元素类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span> (vi.<span class="built_in">begin</span> (), vi.<span class="built_in">end</span>() ); 	<span class="comment">//fcn应该返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span> (ca.<span class="built_in">begin</span> (), ca.<span class="built_in">end</span>());		<span class="comment">// fcn应该返回string&amp;</span></span><br></pre></td></tr></table></figure>

<p>我们知道函数应该返回*beg，而且知道我们可以用decltype (*beg)来获取表达式类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg,It end)</span> -&gt; <span class="title">decitype</span> <span class="params">(*beg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h4><p>如果并不想返回引用而是返回其中的值，可以使用标准库<strong>类型转换</strong>模板。在头文件type_traits中，如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化 remove_reference&lt;int&amp;&gt;，则type 成员将是int。类似的，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string，依此类推。更一般的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span> (*beg) &gt;::type</span><br></pre></td></tr></table></figure>

<p>组合使用它们就可以在函数中返回元素值的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用模板参数的成员，必须用typename，参见16.1.3节（第593页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span> <span class="params">(It beg,It end)</span> -&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span> <span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png" alt="image.png"></p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>可以用一个函数模板对一个函数指针进行赋值，可根据形参生成一个实例，被指针所指：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> ( *pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<p>如果不能从函数指针类型却低估模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本;每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*) (<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span> (compare); <span class="comment">//错误:使用compare的哪个实例?</span></span><br></pre></td></tr></table></figure>

<p>由于既可以接受int和string版本的compare，所以调用失败。不过可以显式的指出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确:显式指出实例化哪个compare版本</span></span><br><span class="line"><span class="built_in">func</span> (compare&lt;<span class="keyword">int</span>&gt;);<span class="comment">//传递compare (const int&amp;,const int&amp;)</span></span><br></pre></td></tr></table></figure>

<p><strong>当参数是一个函数模板实例的地址时,程序上下文必须满足:对每个模板参数,能唯一确定其类型或值。</strong></p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><h4 id="左值引用函数参数推断类型"><a href="#左值引用函数参数推断类型" class="headerlink" title="左值引用函数参数推断类型"></a>左值引用函数参数推断类型</h4><p>一个函数参数是模板类型参数的普通引用时，只能传递给它一个左值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参必须是一个左值//对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line"><span class="built_in">f1</span>(i);<span class="comment">// i是一个int;模板参数类型T是int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">// ci是一个const int;模板参数T是const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>); <span class="comment">//错误:传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果是const T&amp;,则推断结果不会是一个const类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">//f2中的参数是const &amp; ;实参中的const是无关的</span></span><br><span class="line"><span class="comment">//在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i);<span class="comment">//i是一个int;模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">//ci是一个const int，但模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);<span class="comment">//一个const&amp;参数可以绑定到一个右值;T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h4><p>如果函数参数是右值引用，如T&amp;&amp;，推断出T的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp; &amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">//实参是一个int类型的右值;模板参数T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h4><p>如果一个函数参数是指向模板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&amp;)。</p>
<h4 id="编写接受右值引用参数的模板函数"><a href="#编写接受右值引用参数的模板函数" class="headerlink" title="编写接受右值引用参数的模板函数"></a>编写接受右值引用参数的模板函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">	Tt = val; <span class="comment">//拷贝还是绑定一个引用?</span></span><br><span class="line">	t = <span class="built_in">fcn</span> (t) ; <span class="comment">//赋值只改变t还是既改变t又改变val?</span></span><br><span class="line">	<span class="keyword">if</span> (val == t)&#123;<span class="comment">/* ...*/</span> &#125;<span class="comment">//若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，如果传入42，则T会推断为int，但如果传入int的左值，则T会推断为int&amp;，则如果修改t的同时也会修改val。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; )</span> </span>;		<span class="comment">//绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;		<span class="comment">//左值和const右值</span></span><br></pre></td></tr></table></figure>

<p>通常是这样重载模板函数，与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>在13.6.2节中我们注意到，虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<h4 id="std-move如何定义"><a href="#std-move如何定义" class="headerlink" title="std::move如何定义"></a>std::move如何定义</h4><p>标准库的的move</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// static_cast是在4.11.3节（第145页）中介绍的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt; (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很短，但其中有些微妙之处。首先，move的函数参数T&amp; &amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span> <span class="params">( <span class="string">&quot;hi! &quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std: :<span class="built_in">move</span>(<span class="built_in">string</span> ( <span class="string">&quot;bye ! &quot;</span>) );<span class="comment">//正确:从一个右值移动数据</span></span><br><span class="line">s2 = std: :<span class="built_in">move</span>(sl);<span class="comment">//正确:但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>

<h4 id="std-move如何工作"><a href="#std-move如何工作" class="headerlink" title="std::move如何工作"></a>std::move如何工作</h4><p>如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型。因此，在<code>std: : move (string ( &quot;bye ! &quot;))</code>中:</p>
<ul>
<li>推断出的T的类型为string。</li>
<li>因此，remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp; 。</li>
<li>move的函数参数t的类型为string&amp; &amp;。</li>
</ul>
<p>因此，这个调用实例化move<string>，即函数<code>string&amp;&amp; move(string &amp;t)</code></p>
<h4 id="左值static-cast到右值引用时允许的"><a href="#左值static-cast到右值引用时允许的" class="headerlink" title="左值static_cast到右值引用时允许的"></a>左值static_cast到右值引用时允许的</h4><p>我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是const的以及实参是左值还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受一个可调用对象和另外两个参数的模板//对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现:顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f,T1 t1,T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用一个接受引用的参数就会出问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span><span class="comment">//注意v2是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;++v2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数第二个参数为引用，说明我们希望通过函数改变原变量的值，但是使用模板调用就会丢失这个引用的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,i);			<span class="comment">//f改变了实参i</span></span><br><span class="line"><span class="built_in">flip1</span>(f,j,<span class="number">42</span>);		<span class="comment">//通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非int&amp;。因此，这个flip1调用会实例化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn) (<span class="keyword">int</span>,<span class="keyword">int</span>&amp; ), <span class="keyword">int</span> t1,<span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h4><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值〉使得我们可以保持const属性,因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&amp;&amp;和 T2&amp;&amp;,通过引用折叠（参见 16.2.5节，第608页）就可以保持翻转实参的左值/右值属性（参见16.2.5节，第608页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2, t1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样调用就传递给t1一个左值j，t1会折叠为int&amp;，则t1会绑定到j上，就可以通过函数改变j的值。</p>
<p><strong>如果一个函数参数是指向模板类型参数的右值引用(如 T&amp;&amp;)，它对应的实参的const属性和左值/右值属性将得到保持。</strong></p>
<p>但是不能用于接受右值引用参数的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp; &amp;i, <span class="keyword">int</span>&amp; j)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传递一个右值给flip2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>);<span class="comment">//错误:不能从一个左值实例化int&amp; &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="std-forward保持类型信息"><a href="#std-forward保持类型信息" class="headerlink" title="std::forward保持类型信息"></a>std::forward保持类型信息</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line">	<span class="built_in">finalFcn</span> (std::forward&lt;Type&gt;(arg));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节。</strong></p>
<p>于是我们可以重写前面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f,T1 &amp; &amp;t1,T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">f</span> (std: :forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h4 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h4><p>首先编写俩个不同的函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	ostringstream ret;	<span class="comment">//参见8.3节（第287页)</span></span><br><span class="line">	ret &lt;&lt; t;			<span class="comment">//使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); 	<span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个对象对应string表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">//注意:此函数不能用于char*;参见16.3节（第617页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p;	<span class="comment">//打印指针本身的值</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;<span class="built_in">debug_rep</span> (*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; null pointer&quot;</span> ;<span class="comment">//或指出 p为空</span></span><br><span class="line">	<span class="keyword">return</span> ret.<span class="built_in">str</span>();<span class="comment">//返回ret绑定的string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内容并不重要，我们先看使用它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">( <span class="string">&quot;hi&quot;</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>这个调用只有第一个版本是可行的，第二个版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。</p>
<p>如果用一个指针调用debug_rep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>两个函数都生成可行的实例:</p>
<ul>
<li>debug rep(const string*&amp;)，由第一个版本的debug_rep实例化而来，T被绑定到string*。</li>
<li>debug rep(string*)，由第二个版本的 debug_rep实例化而来，T被绑定到string。</li>
</ul>
<p>但第二个版本更加精确，第一个版本需要进行普通指针到const的转换，编译器也会选择第二个版本。</p>
<h4 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (sp) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配:</p>
<ul>
<li><code>debug rep(const string*&amp;)</code>，由第一个版本的 debug_rep 实例化而来，T被绑定到<code>string*</code>。</li>
<li><code>debug rep(const string*)</code>，由第二个版本的 debug_rep 实例化而来，T被绑定到const string。</li>
</ul>
<p>再这种时候编译器会选择最特例化的，我的理解是，最简洁的，则选择第一个版本。</p>
<h4 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印双引号包围的string</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27; &quot;&quot; +s + &#x27;</span><span class="string">&quot;&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当同时匹配同样好的模板和非模板函数的时候，编译器一定会选择非模板版本。</p>
<h4 id="重载模板和类型转换"><a href="#重载模板和类型转换" class="headerlink" title="重载模板和类型转换"></a>重载模板和类型转换</h4><p>如果使用这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;<span class="comment">//调用debug_rep(T*)</span></span><br><span class="line"><span class="comment">//本例中所有三个debug _rep版本都是可行的:</span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> T&amp;)</span>，<span class="comment">//T被绑定到char [10]。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span><span class="params">(T*)</span>，<span class="comment">//T被绑定到const char。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> strina&amp;)</span>，<span class="comment">//要求从const char*到string 的类型转换。</span></span></span><br></pre></td></tr></table></figure>

<p>前两个版本都是匹配的，而第二个版本会被认为是精确匹配的，非模板版本是可行的，但需要一次用户定义的类型转换。所以选择第二个。</p>
<p>如果更希望使用字符版本，可以定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符指针转换为string，并调用string版本的 debug_reg</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h4><p>为了使用<code>char*</code>版本的函数，必须提前准备好其中的模板函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *P)</span></span>;</span><br><span class="line"><span class="comment">//为了使debug_rep(char*)的定义正确工作，下面的声明必须在作用域中string debug_rep (const string &amp;);</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function">i</span></span><br><span class="line"><span class="function"><span class="comment">//如果接受一个const string&amp;的版本的声明不在作用域中，</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回语句将调用debug_rep(const T&amp;)的T实例化为string 的版本return debug_rep(string(p) );</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</strong></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个<strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。存在两种参数包:<strong>模板参数包</strong>template parameter packet)，表示零个或多个模板参数;<strong>函数参数包</strong>（function parameteroacket)，表示零个或多个函数参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包; rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与往常一样，编译器从函数的实参推断模板参数类型。对于可变参数模板，编译器会推断保重的参数数目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span> ;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>,d);	<span class="comment">//包中有三个参数</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="built_in">foo</span>(d,s);			<span class="comment">//包中有一个参数</span></span><br><span class="line"><span class="built_in">foo</span> ( <span class="string">&quot;hi&quot;</span>);		<span class="comment">//空包</span></span><br><span class="line"><span class="comment">//编译器会为foo实例化出四个不同的版本:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;，<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> string&amp;)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h4><p>若需要知道包中的运算符，使用sizeof…运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt;endl; <span class="comment">//类型参数的数目</span></span><br><span class="line">	cout&lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;		<span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>. . . Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;...rest)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;，&quot;</span>;			<span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>print (cout, i, s,42); //包中有两个参数</code>来调用上面的函数，首先会匹配到第二个函数，然后递归调用第二个函数，直至最后一个参数由第一个函数打印。</p>
<p><strong>当定义可变参数版本的 print时，非可变参数版本的声明必须在作用域中。否则,可变参数版本会无限递归。</strong></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>除了获取其大小以外，我们还可以<strong>扩展</strong>，我们还要提供扩展元素的<strong>模式</strong>。就时分解为构成的元素，在模式右边放一个省略号(…)触发扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;<span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span><span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);		<span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个扩展操作扩展模板参数包，为 print生成函数参数列表。第二个扩展操作出现在对print的调用中。此模式为print调用生成实参列表。</p>
<h4 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">	<span class="comment">//print (os,debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span> (os,<span class="built_in">debug_rep</span> (rest)... ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看这样的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将包传递给debug_rep; print (os，debug_rep(a1,a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os,<span class="built_in">debug_rep</span>(rest.. .) );<span class="comment">//错误:此调用无匹配函数</span></span><br></pre></td></tr></table></figure>

<p>它们的区别就是第一个对扩展包中的每一个调用函数，第二个是在调用中展开：</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;...)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员的定义，同13.5节（第465页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">chk_n_alloc</span>(); <span class="comment">//如果需要的话重新分配 StrVec内存空间</span></span><br><span class="line">	alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emplace_back的函数体调用了chk_n_alloc（参见13.5节，第465页）来确保有足够的空间容纳一个新元素，然后调用了construct在first_free 指向的位置中创建了一个元素。construct调用中的扩展为</p>
<p><code>std: : forward&lt;Args&gt;(args) ...</code><br>它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素</p>
<p><code>std::forward&lt;T&gt;(t)</code></p>
<p>其中T,表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如.假定svec是一个strVec，如果我们调用</p>
<p><code>svec.emplace_back (10,&#39;c&#39;);//将cccccccccc添加为新的尾元素</code></p>
<p>construct调用中的模式会扩展出</p>
<p><code>std::forward&lt;int&gt; (10), std::forward&lt;char&gt;(c)</code></p>
<p>通过在此调用中使用forward，我们保证如果用一个右值调用emplace back，则construct也会得到一个右值。例如，在下面的调用中:</p>
<p><code>svec.emplace back (s1 + s2);//使用移动构造函数</code></p>
<p>传递给emplace_back的实参是一个右值，它将以如下形式传递给construct</p>
<p><code>std: :forward&lt;string&gt; (string ( &quot;the end&quot; ))</code></p>
<p>forward<string>的结果类型是string&amp;&amp;，因此construct将得到一个右值引用实参。construct会继续将此实参传递给string 的移动构造函数来创建新元素。</p>
<p><strong>建议:转发和可变参数模板</strong></p>
<p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的emp lace_ back函数一样的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">(Args&amp;&amp;... args)</span> <span class="comment">//将Args扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// work的实参既扩展Args又扩展args</span></span><br><span class="line">	<span class="built_in">work</span>(std: : forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们希望将fun的所有实参转发给另一个名为work的函数,假定由它完成函数的实际工作。类似emplace_back中对 construct的调用,work调用中的扩展既扩展了模板参数包也扩展了函数参数包。<br>由于 fun的参数是右值引用,因此我们可以传递给它任意类型的实参;由于我们使用std:: forward传递这些实参，因此它们的所有类型信息在调用work时都会得到保持。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp; )</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们定义了另一个版本的compare，当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用，而传递给它字符指针，就会调用第一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span> ;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);<span class="comment">//调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>( <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;mom&quot;</span> );<span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>因为无法将指针转换为数组的引用，因此参数是p1和p2时，第二个版本compare不可行。</p>
<p>为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例化( template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<h4 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h4><p>特例化一个函数模板时，必须为每个模板参数提供实参，在template后跟&lt;&gt;，指出正在实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个特例化版本时，函数的参数类型必须与先前模板中对应类型匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>特例化中T对应的为const char*，模板函数中为一个常量指针，而我们需要一个指向常量的指针，我们需要在特例化版本中使用的类型是const char * const &amp;，即一个指向const char的const指针的引用。</p>
<h4 id="函数重载与模板特例化"><a href="#函数重载与模板特例化" class="headerlink" title="函数重载与模板特例化"></a>函数重载与模板特例化</h4><p><strong>特例化的本质是实例化一个模板,而非重载它。因此,特例化不影响函数匹配。</strong></p>
<p><strong>关键概念:普通作用域规则应用于特例化</strong></p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且,在任何使用模板实例的代码之前,特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板,很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是,这种错误编译器又无法发现。</p>
<p><strong>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面,然后是这些模板的特例化版本。</strong></p>
<h4 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h4><p>我们将has模板定义一个特例化版本，用它保存Sale_data对象，为了让我们自己的数据类型能使用hash<key_type>，必须定义hash模板的一个特例化版本。一个特例化hash类必须定义:</p>
<ul>
<li>一个重载的调用运算符（参见14.8节，第506页)，它接受一个容器关键字类型的对象，返回一个size_t。</li>
<li>两个类型成员，result type和 argument_type，分别调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义，参见13.1.2节，第443页)。</li>
</ul>
<p>首先打开命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;<span class="comment">//我们正在定义一个特例化版本，模板参数为sales_data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Sales_data&gt; </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> sales_data argument_type;<span class="comment">// 默认情况下，此类型需要==</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> sales_data&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;string&gt;() (s.bookNo) ^</span><br><span class="line">            hash&lt;<span class="keyword">unsigned</span>&gt;() (s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="keyword">double</span>&gt;() (s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//关闭std命名空间;注意:右花括号之后没有分号</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
              <a href="/tags/%E4%B9%A6%E7%B1%8D/" rel="tag"># 书籍</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" rel="prev" title="C++ Primer 第十五章">
      <i class="fa fa-chevron-left"></i> C++ Primer 第十五章
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/19/%E5%85%89%E8%BF%BD1.1/" rel="next" title="从零实现光追渲染（一）">
      从零实现光追渲染（一） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NDkwMi8zMTM3MQ"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0"><span class="nav-number">1.</span> <span class="nav-text">第十六章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.</span> <span class="nav-text">定义模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.1.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">实例化函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">模板类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">非类型模板参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline%E5%92%8Cconstexpr%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">inline和constexpr的函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">模板编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%99%A8%E4%BB%B6%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">实例化器件错误报告</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.2.</span> <span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">定义类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">实例化类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%BC%95%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">在模板作用域中引用模板类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">类模板的成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check%E5%92%8C%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">check和元素访问成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Blob%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">Blob构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">类模板成员的实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%86%85%E7%AE%80%E5%8C%96%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%90%8D"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">在类内简化模板类名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%A4%96%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%90%8D"><span class="nav-number">1.1.2.9.</span> <span class="nav-text">在类模板外使用类模板名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%8F%8B%E5%85%83"><span class="nav-number">1.1.2.10.</span> <span class="nav-text">类模板和友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%8F%8B%E5%A5%BD%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.2.11.</span> <span class="nav-text">一对一友好关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%92%8C%E7%89%B9%E5%AE%9A%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%8B%E5%A5%BD%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.2.12.</span> <span class="nav-text">通过和特定的模板友好关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A4%E6%A8%A1%E6%9D%BF%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E6%88%90%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="nav-number">1.1.2.13.</span> <span class="nav-text">令模板自己的类型参数成为友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">1.1.2.14.</span> <span class="nav-text">模板的类型别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84static%E6%88%90%E5%91%98"><span class="nav-number">1.1.2.15.</span> <span class="nav-text">类模板的static成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">模板参数与作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%A3%B0%E6%98%8E"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">模板声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">使用类的类型成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">默认的模板实参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E4%B8%8E%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">模板默认实参与类模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.4.</span> <span class="nav-text">成员模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">普通类的成员模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">类模板的成员模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">实例化与成员模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.5.</span> <span class="nav-text">控制实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%9A%E4%B9%89%E4%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%89%80%E6%9C%89%E6%88%90%E5%91%98"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">实例化定义会实例化所有成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%88%E7%8E%87%E4%B8%8E%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">效率与灵活性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="nav-number">1.2.</span> <span class="nav-text">模板实参推断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">类型转换与模板类型参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">使用相同模板参数类型的函数形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BA%94%E7%94%A8%E4%BA%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">正常类型转换应用于普通函数实参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E5%8F%82"><span class="nav-number">1.2.2.</span> <span class="nav-text">函数模板显式实参</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%98%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">指定显式模板实参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BA%94%E7%94%A8%E4%BA%8E%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AE%9E%E5%8F%82"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">正常类型转换应用于显式指定的实参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.3.</span> <span class="nav-text">尾置返回类型与类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">进行类型转换的标准库模板类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="nav-number">1.2.4.</span> <span class="nav-text">函数指针和实参推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">模板实参推断和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">左值引用函数参数推断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">从右值引用函数参数推断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">引用折叠和右值引用参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%97%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">编写接受右值引用参数的模板函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3std-move"><span class="nav-number">1.2.6.</span> <span class="nav-text">理解std::move</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-move%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">std::move如何定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-move%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">std::move如何工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BCstatic-cast%E5%88%B0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%97%B6%E5%85%81%E8%AE%B8%E7%9A%84"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">左值static_cast到右值引用时允许的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91"><span class="nav-number">1.2.7.</span> <span class="nav-text">转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E8%83%BD%E4%BF%9D%E6%8C%81%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">定义能保持类型信息的函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-forward%E4%BF%9D%E6%8C%81%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">std::forward保持类型信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.3.</span> <span class="nav-text">重载与模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E9%87%8D%E8%BD%BD%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">编写重载模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E5%8F%AF%E8%A1%8C%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">多个可行模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">非模板和模板重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">重载模板和类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E5%B0%91%E5%A3%B0%E6%98%8E%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E7%A8%8B%E5%BA%8F%E8%A1%8C%E4%B8%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">1.3.0.5.</span> <span class="nav-text">缺少声明可能导致程序行为异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.</span> <span class="nav-text">可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sizeof%E2%80%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">sizeof…运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.1.</span> <span class="nav-text">编写可变参数函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E6%89%A9%E5%B1%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">包扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%8C%85%E6%89%A9%E5%B1%95"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">理解包扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">1.4.3.</span> <span class="nav-text">转发参数包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">1.5.</span> <span class="nav-text">模板特例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">定义函数模板特例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">函数重载与模板特例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">类模板特例化</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>