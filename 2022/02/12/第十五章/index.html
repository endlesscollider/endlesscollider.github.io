<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mackrui.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面向对象程序设计OOP：概述面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。  使用数据抽象，我们可以将类的接口与实现分离； 使用继承，可以定义相似的类型并对其相似关系建模； 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。  继承通过继承（inheritance）联系在一起的类构成一种层次关系。通常在">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 第十五章">
<meta property="og:url" content="http://mackrui.com/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/index.html">
<meta property="og:site_name" content="祥瑞客栈">
<meta property="og:description" content="面向对象程序设计OOP：概述面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。  使用数据抽象，我们可以将类的接口与实现分离； 使用继承，可以定义相似的类型并对其相似关系建模； 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。  继承通过继承（inheritance）联系在一起的类构成一种层次关系。通常在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/15/wRpdlhZ4XqbNygO.png">
<meta property="article:published_time" content="2022-02-11T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-04T04:58:23.406Z">
<meta property="article:author" content="Collider">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="书籍">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/15/wRpdlhZ4XqbNygO.png">

<link rel="canonical" href="http://mackrui.com/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Primer 第十五章 | 祥瑞客栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">祥瑞客栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点滴的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mackrui.com/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Collider">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祥瑞客栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer 第十五章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-12T00:00:00+08:00">2022-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 12:58:23" itemprop="dateModified" datetime="2022-03-04T12:58:23+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer/" itemprop="url" rel="index"><span itemprop="name">C++ Primer</span></a>
                </span>
            </span>

          
            <span id="/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="C++ Primer 第十五章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p><strong>面向对象程序设计（object-oriented programming）</strong>的核心思想是<strong>数据抽象</strong>、<strong>继承</strong>和<strong>动态绑定</strong>。</p>
<ul>
<li>使用数据抽象，我们可以将类的接口与实现分离；</li>
<li>使用继承，可以定义相似的类型并对其相似关系建模；</li>
<li>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>通过<strong>继承（inheritance）</strong>联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类(base class)<strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为</strong>派生类( derived class)**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（ virtual function)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过使用类派生列表(class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是 : 首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="comment">//Bulk_quote继承了Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为使用public派生，所以可以使用基类成员，可以把Bulk quote的对象当成Quote的对象来使用。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>用它可以分别处理Quote和Bulk_quote的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据传入item形参的对象类型调用Quote::net_price</span></span><br><span class="line">    <span class="comment">//或者Bulk_quote::net_price</span></span><br><span class="line">	<span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;ISBN:&quot;</span> &lt;&lt; item.<span class="built_in">isbn</span> ()<span class="comment">//调用Quote: :isbn</span></span><br><span class="line">		&lt;&lt;<span class="string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>函数形参中的item是基类的引用，我们既可以使用基类的该函数，又可以使用派生类中的该函数，这回根据对象的类型决定执行哪一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic的类型是Quote; bulk的类型是Bulk_quote</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, basic,<span class="number">20</span>);			<span class="comment">//调用Quote的net_price</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, bulk,<span class="number">20</span>);			<span class="comment">//调用Bulk quote的net price</span></span><br></pre></td></tr></table></figure>

<p>函数的运行版本由实参决定，所以动态绑定又被称为运行时绑定。</p>
<p><strong>在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。</strong></p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">//关于=default请参见7.1.4节（第 237页)</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> std::string &amp;book,<span class="keyword">double</span> sales_price) </span><br><span class="line">        : <span class="built_in">bookNo</span> (book), <span class="built_in">price</span>(sales_price)&#123; &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="comment">//返回给定数量的书籍的销售总额</span></span><br><span class="line">	<span class="comment">//派生类负责改写并使用不同的折扣计算算法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">					</span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span> () = <span class="keyword">default</span>;	<span class="comment">//对析构函数进行动态绑定</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string bookNo;				<span class="comment">//书籍的ISBN 编号</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;				<span class="comment">//代表普通状态下不打折的价格</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如此。</strong></p>
<h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>派生类需要提供自己新定义覆盖从基类而来的虚函数。任何希望在派生类中改变的函数定义为virtual，而不希望改变的直接定义为函数。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用<strong>受保护的( protected）</strong>访问运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须使用类派生列表指出从哪继承而来。派生类必须将继承类的虚函数重新声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;		<span class="comment">//Bulk_quote继承自Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span> (<span class="keyword">const</span> std::string&amp;,<span class="keyword">double</span>,std::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">//覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;		<span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span> ;			<span class="comment">//以小数表示的折扣额</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再派生类中使用public继承，所以回隐式包含isbn函数</p>
<h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类可以不覆盖它继承的虚函数，但必须重新声明：如果没有覆写，其行为类似其他的普通成员。</p>
<p>派生类可以再它覆盖的函数前使用virtual，可以在函数const关键字后添加override。</p>
<h4 id="派生类对象及派生类向基类转换"><a href="#派生类对象及派生类向基类转换" class="headerlink" title="派生类对象及派生类向基类转换"></a>派生类对象及派生类向基类转换</h4><p>派生类大致可以认为是这样分布：</p>
<p><img src="https://s2.loli.net/2022/02/15/wRpdlhZ4XqbNygO.png" alt="image.png"></p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;				<span class="comment">//基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">//p指向Quote对象</span></span><br><span class="line">p = &amp;bulk ;				<span class="comment">// p指向bulk 的 Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;		<span class="comment">// r绑定到bulk 的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>这种派生类到基类的转换回隐式的进行，所以可以将派生类的引用或指针用在基类引用或者指针上。</p>
<h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p>派生类构造函数可以调用基类的构造函数帮助建立自己的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std::string&amp; book,<span class="keyword">double</span> p,</span></span></span><br><span class="line"><span class="params"><span class="function">			std::<span class="keyword">size_t</span> qty,<span class="keyword">double</span> disc)</span>:</span></span><br><span class="line"><span class="function">			Quote(book, p), min_qty(qty), discount (disc)&#123;</span> &#125;</span><br><span class="line">		<span class="comment">//与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除非特别指出，否则派生类的所有成员都会执行默认初始化。编译器会首先初始化基类的部分，然后按顺序声明派生类的成员。</p>
<h4 id="派生类使用基类成员"><a href="#派生类使用基类成员" class="headerlink" title="派生类使用基类成员"></a>派生类使用基类成员</h4><p>派生类可以访问基类的公有成员和受保护成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt;= min_qty)</span><br><span class="line">		<span class="keyword">return</span> cnt *(<span class="number">1</span> - discount) * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员（例如min_qty和discount)的方式与使用基类成员（例如price）的方式没什么不同。</p>
<p><strong>关键概念:遵循基类的接口</strong><br>必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口,即使这个对象是派生类的基类部分也是如此。<br>派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了静态成员，则它在整个继承体系中只存在该成员的唯一定义。不论有几个派生，每个静态成员都只存在唯一实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span> <span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">const</span> Derived&amp;)</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmem</span> ();		<span class="comment">//正确:Base定义了statmem</span></span><br><span class="line">	Derived::<span class="built_in">statmem</span> ();	<span class="comment">//正确:Derived继承了statmem</span></span><br><span class="line">	<span class="comment">//正确:派生类的对象能访问基类的静态成员</span></span><br><span class="line">	derived_obj.<span class="built_in">statmem</span> () ;<span class="comment">//通过Derived对象访问</span></span><br><span class="line">	<span class="built_in">statmem</span> ();				<span class="comment">//通过this对象访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类声明方式和一般类一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote;<span class="comment">//错误:派生列表不能出现在这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>				<span class="comment">//正确:声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>

<h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>如果想将派生类作为基类，则必须已经被定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>;</span>				<span class="comment">//声明但未定义</span></span><br><span class="line"><span class="comment">//错误:Quote必须被定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>派生类包含从基类中来的成员，为了使用它们，必须先知道它们。也表明了一个类不能派生它本身。</p>
<p>一个类是基类，同时也可以是派生类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base &#123;<span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1 &#123;<span class="comment">/* ...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个继承关系中，Base是D1的**直接基类( direct base)<strong>，同时是D2的</strong>间接基类( indirectbase)**。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。</p>
<p>每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员;该直接基类的成员又含有其基类的成员;依此类推直至继承链的顶端。</p>
<h4 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h4><p>类名后加上final可防止类被继承：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span> <span class="comment">/** / &#125;;			//NoDerived不能作为基类</span></span><br><span class="line"><span class="comment">class Base &#123;/* */</span> &#125;;	</span><br><span class="line"><span class="comment">// Last是final的;我们不能继承</span></span><br><span class="line">Lastclass Last <span class="keyword">final</span> : Base &#123;<span class="comment">/**/</span> &#125;;		<span class="comment">// Last不能作为基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> NoDerived&#123;<span class="comment">/**/</span>&#125;;				<span class="comment">//错误:NoDerived是final的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> Last &#123;<span class="comment">/* */</span> &#125;;					<span class="comment">//错误: Last是final的</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>在继承关系的类中，基类的指针和引用可以绑定到派生类对象上，所以使用基类指针或者引用时，并不清楚绑定对象的真实类型。</p>
<p><strong>和内置指针一样,智能指针类也支持派生类向基类的类型转换,这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</strong></p>
<h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><p>在继承关系中必须区分两种类型，表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型，动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当print_total调用net_price 时(参见15.1节，第527页):</span></span><br><span class="line"><span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n) ;</span><br></pre></td></tr></table></figure>

<p>item在前面时用Quote&amp;去定义的，那么Quote&amp;就是item的静态类型，动态类型知道在运行时调用该函数才会知道。如果传递一个Bulk_quote对象给print_total，则item的动态类型于静态类型不一致。只有引用和指针动态和静态类型才会不一致。</p>
<h4 id="不存在基类想派生类的隐式类型转换"><a href="#不存在基类想派生类的隐式类型转换" class="headerlink" title="不存在基类想派生类的隐式类型转换"></a>不存在基类想派生类的隐式类型转换</h4><p>派生类可以向基类转换是因为每一个派生类对象都包含一个基类的部分。所以一个基类对象既可以独立存在可以作为派生类的一部分存在。但任何派生类对象都不可以向基类隐式的转换，包括引用和指针。</p>
<p><strong>总结</strong>：要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样,派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节（第544页)详细介绍可访问性的问题。</li>
</ul>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在我们使用基类的引用或指针调用虚函数时会执行动态绑定。因为知道运行时才知道调用了哪个版本，所以所有的虚函数都必须有定义，不论它是否被用到。</p>
<h4 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h4><p>虚函数执行哪个版本完全依赖于运行时绑定到其对象的实际动态类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, base, <span class="number">10</span>);			<span class="comment">//调用Quote::net price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">derived</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">.19</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, derived, <span class="number">10</span>);			<span class="comment">//调用Bulk_quote::net_price</span></span><br></pre></td></tr></table></figure>

<p>依据调用对象的不同，会调用两种不同的函数。此外动态绑定也只有当通过指针或引用调用虚函数才会发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base = derived;			<span class="comment">//把derived的Quote部分拷贝给base</span></span><br><span class="line">base.<span class="built_in">net_price</span> (<span class="number">20</span>);	<span class="comment">//调用Quote::net price</span></span><br></pre></td></tr></table></figure>

<p><strong>关键概念:C++的多态性</strong><br>OOP的核心思想是多态性（polymorphism)。多态性这个词源自希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型,因为我们能使用这些类型的“多种形式”而无须在意它们的差异。<strong>引用或指针的静态类型与动态类型不同</strong>这一事实正是C++语言支持多态性的根本所在。</p>
<p>当我们使用基类的引用或指针调用基类中定义的一个函数时,我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本,判断的依据是引用或指针所绑定的对象的真实类型。</p>
<p>另一方面,对非虚函数的调用在编译时进行绑定。类似的,通过对象进行的函数(虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此,通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。</p>
<p><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</strong></p>
<h4 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>当我们在派生类中可以再一次使用virtual关键字指出函数的性质。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参、返回类型必须与被覆盖的基类函数完全一致。有一个例外是当类的虚函数返回类型是类本身的指针和引用时，规则无效：也就是说，如果D由B派生得到，则基类的虚函数可以返回B<code>*</code>而派生类的对应函数可以返回D<code>*</code>，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
<h4 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h4><p>我们使用override来覆盖继承而来的虚函数，但该函数并没有覆盖已存在的虚函数，此时编译器将会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span> <span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;		<span class="comment">//正确:f1与基类中的f1匹配</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;				<span class="comment">//错误:B没有形如2 (int)的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:f3不是虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">	<span class="comment">//从B继承f2()和f3 ()，覆盖f1 (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;<span class="comment">//不允许后续的其他类覆盖f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 正确:覆盖从间接基类B继承而来的f2</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//错误:D2已经将f2声明成final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>final和 override说明符出现在形参列表(包括任何const或引用修饰符）以及尾置返回类型之后。</strong></p>
<h4 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h4><p>虚函数可以有默认实参，如果某次函数调用使用默认实参，则实参值由静态类型决定：</p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。</p>
<p><strong>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>
<h4 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h4><p>如果希望虚函数调用不要进行动态绑定，而是强迫其执行某个版本，可以使用作用域运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>此代码在编译时就可以完成解析</p>
<p><em>通常情况下,只有成员函数(或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。</em></p>
<p><em>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归</em></p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>我们可以将一个函数定义为纯虚函数，这样做的目的时为了告诉用户，当前此函数没有任何意义，所以它无需定义，通过在函数体位置添加=0就可以声明一个纯虚函数，它只能出现在类内部虚函数声明语句处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Disc_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">		std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Quote</span>(book, price),</span><br><span class="line">		<span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//折扣适用的购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount - <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//表示折扣的小数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<h4 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h4><p>含有纯虚函数的类是<strong>抽象基类</strong>，这种类只负责定义接口，后续的其他类可以覆盖接口，我们不可以直接创建一个抽象基类的对象，因为此时的其中的纯虚函数并没有被定义，我们可以在派生类中覆盖此函数，然后就可以创建派生类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></span><br><span class="line">Disc_quote discounted;		<span class="comment">//错误:不能定义 Disc quote的对象</span></span><br><span class="line">Bulk_quote bulk;			<span class="comment">//正确:Bulk quote中没有纯虚函数</span></span><br></pre></td></tr></table></figure>

<p>如果不给出纯虚函数的定义，它任然是抽象基类。</p>
<h4 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h4><p>重新实现Bulk_quote，让它继承Disc_quote：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当同一书籍的销售量超过某个值时启用折扣</span></span><br><span class="line"><span class="comment">//折扣的值是一个小于1的正的小数值，以此来降低正常销售价格</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">			std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;;<span class="comment">//覆盖基类中的函数版本以实现一种新的折扣策略</span></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的 Bulk_quote 的直接基类是 Disc_quote，间接基类是 Quote。每个Bulk quote对象包含三个子对象:一个(空的)Bulk_quote部分、一个 Disc_quote子对象和一个Quote子对象。</p>
<p>每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，也必须提供构造函数，在构造函数中调用直接基类的构造函数，进而继续调用间接基类 的构造函数。</p>
<p><strong>关键概念:重构</strong><br>在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。</p>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<p>值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。</p>
<h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问</strong>（ accessible)。</p>
<h4 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h4><p>如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是 public和 private 中和后的产物:</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;						<span class="comment">// protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky: :prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">//不能访问Base: :prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//正确:clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误:clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp; b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>例子中派生类成员函数使用基类对象访问受保护的成员是不可行的。</p>
<h4 id="公有、私有、受保护继承"><a href="#公有、私有、受保护继承" class="headerlink" title="公有、私有、受保护继承"></a>公有、私有、受保护继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// public成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">	<span class="comment">// protected成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> priv_mem;</span><br><span class="line">	<span class="comment">// private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="comment">// 正确:派生类能访问protected成员int f() &#123; return prot_mem; &#125;</span></span><br><span class="line">	<span class="comment">//错误:private成员对于派生类来说是不可访问的char g() &#123; return priv_mem;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">// 依旧不能访问</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生访问说明符对派生类的成员（及友元）能否访问直接基类成员没有影响。访问权限只与基类中的访问说明符有关。派生类只能访问直接基类的受保护的与共有的成员。</p>
<p>派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内）对于基类成员的访问权限，概括来说：</p>
<ul>
<li>如果是共有继承，那么继承而来的成员访问等级不变。</li>
<li>受保护继承，继承而来的访问等级上升一级，public变为protect。</li>
<li>私有继承，所有继承成员访问等级上升到最高，及全部为private</li>
</ul>
<h4 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h4><p>派生类向基类的转换（参见15.2.2 节，第530页)是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B:</p>
<ul>
<li>只有当D 公有地继承B时，用户代码才能使用派生类向基类的转换;如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换;派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换;反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<p><strong>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的;反之则不行。</strong></p>
<p><strong>关键概念:类的设计与受保护的成员</strong><br>不考虑继承的话,我们可以认为一个类有两种不同的用户:普通用户和类的实现者。</p>
<p>其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有(实现)部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的。</p>
<h4 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h4><p>就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="comment">//添加friend声明，其他成员与之前的版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span>			<span class="comment">// Pal在访问Base的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; 		<span class="comment">//正确: Pal是 Base的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;			<span class="comment">//错误: Pal不是Sneaky的友元</span></span><br><span class="line">    <span class="comment">//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125;		<span class="comment">//正确: Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在f2中j是Sneaky成员而不是Base成员，由于pal只是Base的友元所以不能访问其派生类成员。而f3访问的是Sneaky中的Base成员所以可以访问。</p>
<p>当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D2对Base 的 protected和private成员不具有特殊的访问能力class D2 : public Pal &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b.prot_mem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//错误:友元关系不能继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h4><p>使用using声明可以改变和继承某个名字的访问级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std : : <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">//注意:private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base : : size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base : : n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>using使得不论如何继承而来的成员在保持using前一个访问说明符的访问等级，如size是public，n是protect。但是派生的类只能为可以访问的名字提供using声明</p>
<h4 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h4><p>默认情况下class定义派生类是私有继承，而struct是共有继承。但更建议显示的声明出来。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p><strong>派生类的作用域嵌套在基类内</strong>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt;bulk.<span class="built_in">isbn</span> () ;</span><br></pre></td></tr></table></figure>

<p>名字isbn的解析将按照下述过程所示:</p>
<ul>
<li>因为我们是通过Bulk_quote的对象调用isbn的，所以首先在Bulk_quote中查找，这一步没有找到名字isbn</li>
<li>因为Bulk quote是 Disc quote 的派生类，所以接下来在 Disc_quote 中查找，仍然找不到。</li>
<li>因为 Disc_quote是 Quote的派生类，所以接着查找Quote;此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中的isbn。</li>
</ul>
<h4 id="编译时进行名字查找"><a href="#编译时进行名字查找" class="headerlink" title="编译时进行名字查找"></a>编译时进行名字查找</h4><p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况)，但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p>这是因为当使用基类指针时，可使用的成员已经确定，如果使用它绑定一个派生类对象，且派生类对象又新增了几个成员，此时对于这个指针来说，它并不知道这些多出来的成员，自然也无法使用它们。</p>
<h4 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h4><p>如果派生类中定义了其基类同名的成员，那么此成员将会隐藏基类中的同名成员，就像局部变量被优先使用。主要还是因为派生类的作用域嵌套在基类内。</p>
<h4 id="通过作用域运算符使用隐藏成员"><a href="#通过作用域运算符使用隐藏成员" class="headerlink" title="通过作用域运算符使用隐藏成员"></a>通过作用域运算符使用隐藏成员</h4><p>通过在同名成员前加上作用域就可以调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base : :mem;&#125; <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>建议还是不要同名。</p>
<p>*<em>关键概念:名字查找与继承</em><br>理解函数调用的解析过程对于理解C++的继承至关重要,假定我们调用p-&gt;mem ()（或者obj .mem())，则依次执行以下4个步骤:</p>
<ul>
<li>首先确定p(或obj)的静态类型。因为我们调用的是一个成员,所以该类型必然是类类型。</li>
<li>在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到,则编译器将报错。</li>
<li>一旦找到了mem,就进行常规的类型检查(参见6.1节,第183页)以确认对于当前找到的 mem，本次调用是否合法。</li>
<li>假设调用合法,则编译器将根据调用的是否是虚函数而产生不同的代码:<ul>
<li>如果 mem是虚函数且我们是通过引用或指针进行的调用,则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用,则编译器将产生一个常规函数调用。</li>
</ul>
</li>
</ul>
<h4 id="一如既往，名字查找先于类型检查"><a href="#一如既往，名字查找先于类型检查" class="headerlink" title="一如既往，名字查找先于类型检查"></a>一如既往，名字查找先于类型检查</h4><p>如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类(即内层作用域）的成员与基类（即外层作用域)的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致。</p>
<h4 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h4><p>现在可以理解为什么基类与派生类的虚函数必须有相同的形参列表了，如果不相同就会隐藏同名成员，而不是覆写。不然就无法通过基类引用或指针访问派生类的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//隐藏基类的fcn，这个fcn不是虚函数</span></span><br><span class="line">    <span class="comment">// D1继承了Base : :fcn ()的定义</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//形参列表与Base 中的fcn不一致</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//是一个新的虚函数，在 Base中不存在</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">//是一个非虚函数，隐藏了D1 : : fcn (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;		<span class="comment">//覆盖了Base的虚函数fcn</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//覆盖了D1的虚函数f2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过基类调用隐藏的虚函数"><a href="#通过基类调用隐藏的虚函数" class="headerlink" title="通过基类调用隐藏的虚函数"></a>通过基类调用隐藏的虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1l = &amp;bobj, * bp2 = &amp;dlobj, * bp3 = &amp;d2obj; </span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用，将在运行时调用 Base : : fcn</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用 Base : : fcn</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用D2 : :fcn</span></span><br><span class="line">D1* dlp = &amp;dlobj; D2* d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;<span class="built_in">f2</span>();			<span class="comment">//错误:Base没有名为f2的成员</span></span><br><span class="line">dlp-&gt;<span class="built_in">f2</span>();			<span class="comment">//虚调用，将在运行时调用D1 : :f2()</span></span><br><span class="line">d2p-&gt;<span class="built_in">f2</span>();			<span class="comment">// 虚调用，将在运行时调用D2: : f2()</span></span><br></pre></td></tr></table></figure>

<p>对于调用非虚函数，并不会发生动态绑定，由指针的类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *pl = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//错误:Base中没有接受一个int的fcn</span></span><br><span class="line">p2-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//静态绑定，调用D1 : :fcn(int)</span></span><br><span class="line">p3-&gt;<span class="built_in">fcn</span> ( <span class="number">42</span>);			<span class="comment">//静态绑定，调用D2 : :fcn (int)</span></span><br></pre></td></tr></table></figure>

<h4 id="覆盖重载函数"><a href="#覆盖重载函数" class="headerlink" title="覆盖重载函数"></a>覆盖重载函数</h4><p>和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。</p>
<p>一种好的解决方案是为重载的成员提供一条using声明语句（参见15.5节，第546页)，这样我们就无须覆盖基类中的每一个重载版本了。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见15.2.1节，第528页)，这样我们就能动态分配继承体系中的对象了。</p>
<p>当delete一个动态分配的对象的指针时执行析构函数，但如果指针指向了其“子孙”，则有可能出现指针静态类型与被删除对象的动态类型不符。所以必须在基类中将析构函数定义为析构函数保证函数的执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如果基类的析构函数不是虚函数,则delete一个指向派生类对象的基类指针将产生未定义的行为。</strong></p>
<p>在之前的准则中：如果一个类需要一个析构函数，那么它同样也需要拷贝和赋值操作。但基类的析构是一个重要的例外。它的虚函数并没有内容所以可以没有其他操作。</p>
<h4 id="虚析构函数阻止合成移动"><a href="#虚析构函数阻止合成移动" class="headerlink" title="虚析构函数阻止合成移动"></a>虚析构函数阻止合成移动</h4><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>这里的合成的拷贝，赋值或析构与普通类似，</p>
<p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构<br>函数类似:它们对类本身的成贝依城优对一个对象的直接基类部分进行初始化、赋值或销成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如，</p>
<ul>
<li>合成的Bulk quote默认构造函数运行Disc_quote 的默认构造函数，后者又运行Quote的默认构造函数。</li>
<li>Quote 的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0。</li>
<li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化 qty和discount。</li>
<li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它什么具体工作也不做。</li>
</ul>
<p>拷贝构造也是类似，此外基类成员是合成或自定义都没有影响，但唯一的要求是成员应该可以访问比关切不是被删除的。</p>
<p>如前所述，Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作。如我们即将看到的那样，Quote没有移动操作意味着它的派生类也没有。</p>
<h4 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h4><ul>
<li>如果基类中基础操作（构造、拷贝。。。）是删除的函数或不可访问，那么派生类对应的成员也是被删除的，因为派生类不能通过这些基类成员来为基类执行这些操作。</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</li>
<li>和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>();</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">//其他成员，不含有移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">	<span class="comment">//没有声明任何构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D d;					<span class="comment">//正确:D的合成默认构造函数使用B的默认构造函数</span></span><br><span class="line"><span class="function">D <span class="title">d2</span><span class="params">(d)</span></span>;				<span class="comment">//错误:D的合成拷贝构造函数是被删除的</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std: : move(d))</span></span>;	<span class="comment">//错误:隐式地使用D的被删除的拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h4><p>如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦 Quote定义了自己的移动操作，那么它必须同时显式地定义铂贝操作（参见13.6.2节，第476页):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次进行默认初始化</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//移动赋值virtual ~Quote() = default;</span></span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数不仅仅要负责自己的成员初始化还有基类成员。而析构函数只负责销毁派生类自己分配的资源</p>
<p><strong>当派生类定义了拷贝或移动操作时,该操作负责铂贝或移动包括基类部分成员在内的整个对象。</strong></p>
<h4 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h4><p>派生类拷贝或移动构造通常是应用对应的基类构造来初始化对象的基类部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中</span></span><br><span class="line">    <span class="comment">//显式地调用该构造函数</span></span><br><span class="line">	<span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d) : <span class="built_in">Base</span>(d)</span><br><span class="line">		<span class="comment">//拷贝基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ...*/</span>	&#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">Base</span>(std : : <span class="built_in">move</span>(d))<span class="comment">//移动基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将D类型的对象d传递给基类的拷贝构造函数。这个构造负责将d的基类部分拷贝给要创建的对象。如果d并没有基类初始值，则默认初始化。</p>
<p><strong>在默认情况下,基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝(或移动)构造函数。</strong></p>
<h4 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h4><p>派生类的赋值运算符也必须显示地为其基类部分赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base: : operator=(const Base&amp;)不会被自动调用</span></span><br><span class="line">D D: :<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base: :<span class="keyword">operator</span>=(rhs); <span class="comment">//为基类部分赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类的成员赋值</span></span><br><span class="line">	<span class="comment">//酌情处理自赋值及释放已有资源等情况return *this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用基类的赋值操作无论基类的构造函数或赋值运算符是合成还是自定义，派生类的对应操作都能够使用它们。</p>
<h4 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h4><p>派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Base : : ~Base被自动调用执行</span></span><br><span class="line">	~<span class="built_in">D</span>() &#123;<span class="comment">/*该处由用户定义清除派生类成员的操作*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象销毁的顺序与创建的顺序相反。从子孙到祖先。</p>
<h4 id="在构造和析构函数中调用虚函数"><a href="#在构造和析构函数中调用虚函数" class="headerlink" title="在构造和析构函数中调用虚函数"></a>在构造和析构函数中调用虚函数</h4><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>一个类只能初始化的直接基类，一个类也只能继承其直接类的构造函数。类不能默认继承默认的拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为派生类合成。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。举个例子，我们可以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote : : Disc_quote;<span class="comment">//继承Disc_quote的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>生成的构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">derived</span> (parms) : <span class="built_in">base</span> (args)&#123; &#125;</span><br><span class="line"><span class="comment">//在我们的 Bulk_quote类中，继承的构造函数等价于:</span></span><br><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span></span></span><br><span class="line"><span class="params"><span class="function">	std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc)</span> :</span></span><br><span class="line"><span class="function">	Disc quote(book, price, qty, disc) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。</p>
<h4 id="继承的构造函数的特点"><a href="#继承的构造函数的特点" class="headerlink" title="继承的构造函数的特点"></a>继承的构造函数的特点</h4><p>和普通using不一样的是，构造函数的using声明不会改变构造函数的访问级别，且using声明也不能指定exlicit或者constexpr。继承的构造函数会具有相同的属性。</p>
<p>当基类的构造函数含有默认的实参时，这些实参并不会被继承，相反的是，派生类会获得多个继承的构造函数，每个构造函数分别省略掉由默认实参的形参。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p><strong>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”,因此容器和存在继承关系的类型无法兼容。</strong></p>
<h4 id="在容器中放置智能指针而非对象"><a href="#在容器中放置智能指针而非对象" class="headerlink" title="在容器中放置智能指针而非对象"></a>在容器中放置智能指针而非对象</h4><p>容器中防止继承关系的对象时，通常存放的是基类的指针（智能指针更好）。</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>我们定义一个表示购物篮的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Basket使用合成的默认构造函数和拷贝控制成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; sale)</span> </span>&#123; items.<span class="built_in">insert</span>(sale); &#125;</span><br><span class="line">	<span class="comment">//打印每本书的总价和购物篮中所有书的总价</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(std : : ostream&amp;)</span><span class="keyword">const</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//该函数用于比较shared_ptr，multiset成员会用到它</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs-&gt;<span class="built_in">isbn</span>() &lt; rhs-&gt;<span class="built_in">isbn</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//multiset保存多个报价，按照compare成员排序</span></span><br><span class="line">	std::multiset&lt;std::shared ptr&lt;Quote&gt;, <span class="keyword">decltype</span> (compare)*&gt; items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的类使用一个multiset（参见11.2.1节，第377页)来存放交易信息，这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在一起（参见11.2.2节，第 378页)。</p>
<p>这个声明看起来不太容易理解，但是从左向右读的话，我们就能明白它其实是定义了一个指向Quote对象的shared ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。multiset成员的名字是 items，我们初始化items并令其使用我们的compare函数。</p>
<h4 id="定义Basket的成员"><a href="#定义Basket的成员" class="headerlink" title="定义Basket的成员"></a>定义Basket的成员</h4><p>这个成员的名字是total_receipt，它负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Basket : : <span class="built_in">total_receipt</span>(ostream&amp; os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0.0</span>;		<span class="comment">//保存实时计算出的总价格</span></span><br><span class="line">	<span class="comment">// iter指向ISBN相同的一批元素中的第一个</span></span><br><span class="line">	<span class="comment">// upper_bound返回一个迭代器，该迭代器指向这批元素的尾后位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = items.<span class="built_in">cbegin</span>();</span><br><span class="line">			iter != items.<span class="built_in">cend</span>();</span><br><span class="line">			iter = items.<span class="built_in">upper_bound</span>(*iter))&#123;</span><br><span class="line">		<span class="comment">//我们知道在当前的Basket中至少有一个该关键字的元素</span></span><br><span class="line">        <span class="comment">//打印该书籍对应的项目</span></span><br><span class="line">		sum += <span class="built_in">print_total</span>(os, **iter, items.<span class="built_in">count</span>(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Total sale: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//打印最终的总价格</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的for循环中upper函数会跳过相同的书直接指到下一种书。此外在print_total函数中，第二个参数第一次解引用得到一个指向该对象的指针指针，再一次解引用才能得到这个Quto对象（或派生对象）。使用multiset统计有多少个相同元素。</p>
<h4 id="隐藏指针"><a href="#隐藏指针" class="headerlink" title="隐藏指针"></a>隐藏指针</h4><p>接下的需要定义add_item成员，先看使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.<span class="built_in">add_item</span> (make_shared&lt;Quote&gt; ( <span class="string">&quot;123&quot;</span>,<span class="number">45</span>));</span><br><span class="line">bsk,<span class="built_in">add_item</span> (make_shared&lt;Bulk_quote&gt; (<span class="string">&quot;345&quot;</span>，<span class="number">45</span>，<span class="number">3</span>，<span class="number">.15</span>));</span><br></pre></td></tr></table></figure>

<p>下一步重新定义add_item使它接受一个Quote对象而非shared_ptr，新版本的add_item将负责内存的分配。定义两个版本，一个拷贝它给定的对象，另一个采取移动操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span> </span>;			<span class="comment">//拷贝给定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(Quote&amp;&amp; sale)</span> </span>;				<span class="comment">//移动给定的对象</span></span><br></pre></td></tr></table></figure>

<p>此时遇到的问题是，函数不知道分配的类型，若<code>new Quote(sale)</code>，则可能不正确，传入其派生类的对象时，会被切掉一部分。</p>
<h4 id="模拟虚拷贝"><a href="#模拟虚拷贝" class="headerlink" title="模拟虚拷贝"></a>模拟虚拷贝</h4><p>我们给Quote添加一个虚函数，函数申请一份当前对象的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">	<span class="comment">//这些成员使用的引用限定符参见13.6.3节（第483页)</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">							</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span>(std : : <span class="built_in">move</span> (*<span class="keyword">this</span>)); &#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line">	<span class="function">Bulk_quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; <span class="params">(<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (*<span class="keyword">this</span>); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    Bulk_quote* clone () &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">						&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (std: : move ( *<span class="keyword">this</span>)) ;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">//其他成员与之前的版本一致</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<p>因为我们拥有add_item的拷贝和移动版本，所以我们分别定义clone的左值和右值版本。</p>
<p>使用clone写出新版的add_item:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span>	<span class="comment">//拷贝给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(std: :shared_ptr&lt;Quote&gt;(sale.<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span>		<span class="comment">//移动给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(</span><br><span class="line">			std: :shared_ptr&lt;Quote&gt;(std: :<span class="built_in">move</span>(sale).<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clone根据作用与左值右值分不同的版本，add_item也有调用不同版本的重载。Sale的动态类型决定了运行Quote还是Bulk_quote函数。然后为这个对象绑定智能指针放在容器内。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
              <a href="/tags/%E4%B9%A6%E7%B1%8D/" rel="tag"># 书籍</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/" rel="prev" title="C++ Primer文本查询程序">
      <i class="fa fa-chevron-left"></i> C++ Primer文本查询程序
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" rel="next" title="C++ Primer 第十六章">
      C++ Primer 第十六章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NDkwMi8zMTM3MQ"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OOP%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">OOP：概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">动态绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">定义基类和派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义基类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">成员函数与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">访问控制与继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">定义派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">派生类中的虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">派生类对象及派生类向基类转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">派生类构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">派生类使用基类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">继承与静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">派生类的声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">被用作基类的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8F%91%E7%94%9F"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">防止继承的发生</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.3.</span> <span class="nav-text">类型转换与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">静态类型与动态类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%9F%BA%E7%B1%BB%E6%83%B3%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">不存在基类想派生类的隐式类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%AF%E8%83%BD%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E8%A2%AB%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">对虚函数的调用可能在运行时才被解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">派生类中的虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E5%92%8Coverride"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">final和override</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">虚函数与默认实参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%81%BF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.0.5.</span> <span class="nav-text">回避虚函数的机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E6%9C%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E6%98%AF%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">含有纯虚函数的类是抽象基类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%83%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">派生类构造函数只初始化它的直接基类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF-1"><span class="nav-number">1.5.</span> <span class="nav-text">访问控制与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">受保护的成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E3%80%81%E7%A7%81%E6%9C%89%E3%80%81%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">公有、私有、受保护继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">派生类向基类转换的可访问性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.0.4.</span> <span class="nav-text">友元与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E4%B8%AA%E5%88%AB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-number">1.5.0.5.</span> <span class="nav-text">改变个别成员的可访问性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BF%9D%E6%8A%A4%E7%BA%A7%E5%88%AB"><span class="nav-number">1.5.0.6.</span> <span class="nav-text">默认的继承保护级别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.6.</span> <span class="nav-text">继承中的类作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">编译时进行名字查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">名字冲突与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E7%94%A8%E9%9A%90%E8%97%8F%E6%88%90%E5%91%98"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">通过作用域运算符使用隐藏成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%A6%82%E6%97%A2%E5%BE%80%EF%BC%8C%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E5%85%88%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-number">1.6.0.4.</span> <span class="nav-text">一如既往，名字查找先于类型检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.6.0.5.</span> <span class="nav-text">虚函数与作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%9F%BA%E7%B1%BB%E8%B0%83%E7%94%A8%E9%9A%90%E8%97%8F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.0.6.</span> <span class="nav-text">通过基类调用隐藏的虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.0.7.</span> <span class="nav-text">覆盖重载函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.</span> <span class="nav-text">构造函数与拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">虚析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%98%BB%E6%AD%A2%E5%90%88%E6%88%90%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">虚析构函数阻止合成移动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.7.2.</span> <span class="nav-text">合成拷贝控制与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E5%88%A0%E9%99%A4%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">派生类中删除的拷贝控制与基类的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">移动操作与继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="nav-number">1.7.3.</span> <span class="nav-text">派生类的拷贝控制成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">定义派生类的拷贝或移动构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">派生类赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">派生类析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">在构造和析构函数中调用虚函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.</span> <span class="nav-text">继承的构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">继承的构造函数的特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.8.</span> <span class="nav-text">容器与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%94%BE%E7%BD%AE%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%80%8C%E9%9D%9E%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">在容器中放置智能指针而非对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99Basket%E7%B1%BB"><span class="nav-number">1.8.1.</span> <span class="nav-text">编写Basket类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Basket%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">定义Basket的成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E6%8C%87%E9%92%88"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">隐藏指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%99%9A%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">模拟虚拷贝</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collider"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Collider</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/endlesscollider" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;endlesscollider" rel="noopener" target="_blank"><i class="GitHub fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1652737065@qq.com" title="E-Mail → mailto:1652737065@qq.com" rel="noopener" target="_blank"><i class="E-Mail fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collider</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"QIIyEcbRNaOewES2MuIhSKXf-gzGzoHsz","app_key":"6k9HROMoqf6vzPadEMksx26r","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


  
  
    <script src="/js/cursor/cherry.js"></script>
  

</body>
</html>