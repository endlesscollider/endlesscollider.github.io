<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二十：前情回顾</title>
    <url>/2022/08/09/%E5%85%89%E8%BF%BD20/</url>
    <content><![CDATA[<p>上一章我们引入包围盒的概念后，大大缩短了我们运行时间，但整体逻辑开始变的复杂起来，没关系，让我们来一起梳理一下之前的内容。</p>
<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>首先我们把man函数当成一个raycast类，他除了需要一些长宽比，分辨率、采样数、反射深度等变量外，还需要一个自由相机、一个bvh_node构成的世界，有了这些，它就可以给我们呈现一张”美丽”的图片了，这其中两个关键就是相机和世界了。</p>
<p>先来看看相机，它由很多参数构造而成，但构造完成后，我们就不必管那么多，我们只需要在main函数传入一个0-1内的u、v值就可以得到我们想到的光线，再由ray_color函数来获得该光线带回的颜色。ray_color函数只需要光线，世界和深度就可以得到颜色，这个过程就是所谓的碰撞。</p>
<p>world是bvh_node类型，由一个hittable_list和两个时间构造而成，在构造函数中，对物体按随机轴进行二分直到只有一个物体或物体列表，为它们套上各自的包围盒后，回溯为每个节点的左右孩子一起套上更大的包围盒。目前的这种方式也代表了虽然我们可以在hitable_list里面包含hittable_list但是该函数并不会打开列表将里面的物体拿出来进行二分，所以当下为了更快的速度不建议这么做。</p>
<p>再回到我们的ray_color函数，光线首先会world这个最大包围盒检测，如果通过，继续检测左右孩子，当所有包围盒检测都通过之后，那么它便会和我们具体物体进行碰撞检测，由于我们的bvh的排序仅仅是通过比较每个节点最小值得到，所以是可能同时通过所有检测来到多个不同的物体进行碰撞，所以hit函数中深度检测也是必不可少的一环，将碰撞带回反射率和新的光线带回的颜色相乘就得到了这一次采样的结果，上述过程是一个递归的过程，反射光线会再一次与世界”碰撞“，直到反射的光线什么都没有碰到或者是碰到了光源。</p>
<p>这里还有一个非常重要的点，就是怎么得到的新的反射（折射）光线呢？这就是材质存在的意义了，每个物体中都包含一个材质，通过hit函数调用材质内scatter方法得到就可以得到一根新的光线！</p>
<p>将这样的采样重复一定次数取平均就得到这了这个像素点的颜色了，填满它们就得到我们的图片了。为了更加方便的理解这里放上他们的类图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%B1%BB%E5%9B%BE1.png" alt="光线追踪类图1"></p>
<p>最后谈谈我们是如何管理这个world，一切还得从hittable说起，它有我们最重要的碰撞函数hit，以及刚刚引入的bounding_box包围盒生成函数，还有四个继承者分别是球、移动球、物体列表以及bvh_node，继承者们自然需要实现基类的各自的碰撞及包围盒函数。</p>
<p>让我们来看看这些继承者们，首先最简单球和移动球，他们是抽象模型中最底层最具体的类，无论上层如何处理，最后的任务都要落到他们的头上，当然以后也会增加更多的物体进行扩充，物体对hittable的继承也让我们可以通过容器统一进行管理实现多态，<strong>这种设计方式也非常符合面向对象的设计思想，及应该尽可能的与抽象类互动而不是底层的派生类，从而提高代码的可复用性。</strong></p>
<p>第三个继承者物体列表可以看成一个大团队，bvh_node那就可以理解为经理，给他一个团队，经理给团队下的人排序编号，当有任务来时，就看看适合哪个部门的哪个编号的人（球），如果底下的人（球）都干不了就直接放弃这单，合适就交给对应的人（球）去处理，这样公司就运作起来了，不对是光线就可以找到对应的物体进行碰撞了。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li>创建空类图，再脑内模拟图片生成过程，补全类图。</li>
</ol>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>武器-连锁激光</title>
    <url>/2022/08/07/%E6%AD%A6%E5%99%A8-%E6%BF%80%E5%85%89/</url>
    <content><![CDATA[<p>看了一些星际大战之后，想做一个激光武器，既然地球online里面做有点危险，那还是在unity里面做一个吧，先来看看效果</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E6%BF%80%E5%85%89.gif" alt="激光"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E6%BF%80%E5%85%895.gif" alt="激光5"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E6%BF%80%E5%85%8911.gif" alt="激光11"></p>
<p>最初呢，链接的激光是瞬间生成的，有一些假，第二个做了一些优化，可以看到链接丝滑了很多，第三个做了顶点动画看起来要更有威力了一些，看看怎么实现的吧，也可以取代码自用。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>有几个基本的需求</p>
<ol>
<li>当激光路径碰到敌人，激光会锁住敌人，并产生连锁。</li>
<li>当敌人走出一定范围，链接会断开，重新生成链接。</li>
<li>当有新的敌人进入范围，而且没达到连锁上限，可以再次重新生成链接。</li>
</ol>
<p>另外有几个自己可有可无的需求</p>
<ol>
<li>用点光源照亮被连锁到的敌人</li>
<li>光线是有动感的，不能仅仅只一条线，那太low了</li>
<li>光线打出去是有速度的。</li>
</ol>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>首先是一些变量，建议跳过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#region 共有变量</span><br><span class="line">//可供调节激光参数相关</span><br><span class="line">public int maxAtkNum = 5;</span><br><span class="line">public int atkLinkRange = 7;</span><br><span class="line">public float maxDistance = 20;</span><br><span class="line">public float pulseSpeed = 0.7f;</span><br><span class="line">public float minWidth = 0.5f;</span><br><span class="line">public float maxWidth = 0.6f;</span><br><span class="line">public float laserSpeed = 8;</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">#region 私有变量</span><br><span class="line">private LineRenderer lineRenderer;</span><br><span class="line"></span><br><span class="line">//控制状态切换</span><br><span class="line">private Ray ray;</span><br><span class="line">private RaycastHit hit;</span><br><span class="line">private bool isAtking = false;</span><br><span class="line"></span><br><span class="line">//转折点相关</span><br><span class="line">private GameObject[] lights;</span><br><span class="line">private Collider[] colliders;</span><br><span class="line">private HashSet&lt;Collider&gt; enemyIsAtking = new HashSet&lt;Collider&gt;();</span><br><span class="line">private int pointSize = 1;</span><br><span class="line">private Vector3[] tempPoints;</span><br><span class="line">private Vector3 lastPos;</span><br><span class="line">private float startTime;</span><br><span class="line">private int curPointSize = 2;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>我们可以想到使用射线来检测我们的激光是否碰到了第一个敌人，这很重要，因为当激光是否连锁敌人对line组件的选点完全不同，所以，我们需要一个保存一个RaycastHit来判断状态，只有打到第一个敌人才开始连锁。击中敌人之后该怎么做呢？我将它分为四个状态，分别是NotAtking、Atking、NotAtk2Atking、Atk2NotAtking，控制四个状态进行转换的变量为前面我们保存的RaycastHit和一个表示是否开启攻击状态的bool值。先来看update代码吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        //让控件依附在父物体身上</span><br><span class="line">        transform.localPosition = Vector3.zero;</span><br><span class="line">        transform.localRotation = Quaternion.identity;</span><br><span class="line"></span><br><span class="line">        //控制射线检测方向</span><br><span class="line">        ray.origin = transform.position;</span><br><span class="line">        ray.direction = transform.forward;</span><br><span class="line">        Physics.Raycast(ray, out hit, maxDistance);</span><br><span class="line"></span><br><span class="line">        //控制四种状态的切换</span><br><span class="line">        if (!isAtking &amp;&amp; hit.transform)</span><br><span class="line">        &#123;</span><br><span class="line">            NotAkt2Atking();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (isAtking &amp;&amp; !hit.transform)</span><br><span class="line">        &#123;</span><br><span class="line">            Atk2NoAkting();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isAtking &amp;&amp; hit.transform)</span><br><span class="line">        &#123;</span><br><span class="line">            Atking();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            NotAtking();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>C++ Primer告诉我们最好先实现宏观调用，再去写细节方法，这里通过射线检测返回的hit和bool值在四种状态进行切换，有人可能会问：你这个怎么怎么不传参数啊，当然可以，但我想在这里尽量不在Atking和NotAtking中使用参数传递来调用函数，因为这个函数在update中调用频率非常之高，倒不如全部使用成员变量，这点空间换取的时间是相当值得的。</p>
<h4 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h4><p>当然我们接下来要去实现这四种状态，从最简单的开始吧，notAtking（）函数，它只需要绘制一条慢慢变长的直线就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void NotAtking()</span><br><span class="line">&#123;</span><br><span class="line">    //用插值取得终点位置。</span><br><span class="line">    Vector3 endPos = Vector3.Lerp(lastPos, transform.position + transform.forward * maxDistance, 							(Time.time - startTime) * laserSpeed);</span><br><span class="line">    lineRenderer.SetPositions(new Vector3[]</span><br><span class="line">    &#123;</span><br><span class="line">        transform.position,</span><br><span class="line">        endPos</span><br><span class="line">    &#125;);</span><br><span class="line">    //之后会提到</span><br><span class="line">    curPointSize = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没什么好说的，非常简单，第二个自然就是NotAtk2Atking（），这里需要弄清楚链接逻辑，这个切换函数所要做的就是把一切数据都准备好，它主要是为Atking（）函数做准备，先看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这里的形参后面会提到</span><br><span class="line">void NotAkt2Atking()</span><br><span class="line">    &#123;</span><br><span class="line">    	//还记得控制状态的切换的两个关键吗？这是其中之一，这里新建局部对象用来作为循环条件</span><br><span class="line">        Collider col = hit.collider;</span><br><span class="line">        </span><br><span class="line">        //用来收集范围检测到的敌人</span><br><span class="line">        Collider[] tempCol;</span><br><span class="line">        </span><br><span class="line">        //循环寻找下一个单位</span><br><span class="line">        while (col &amp;&amp; pointSize &lt;= maxAtkNum)</span><br><span class="line">        &#123;</span><br><span class="line">        	//加入hashset中</span><br><span class="line">            enemyIsAtkingSet.Add(col);</span><br><span class="line">            colliders[pointSize - 1] = col;</span><br><span class="line">            </span><br><span class="line">            //范围检测，这里检测层级可以自己定义</span><br><span class="line">            tempCol = Physics.OverlapSphere(col.transform.position, atkLinkRange,</span><br><span class="line">            			1 &lt;&lt; LayerMask.NameToLayer(&quot;Corpse&quot;));</span><br><span class="line">            </span><br><span class="line">            if (tempCol.Length == 0) col = null;</span><br><span class="line">            //依次遍历数组，若没有在hashSet中，就可以继续循环</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                col = null;</span><br><span class="line">                foreach (Collider collider in tempCol)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!enemyIsAtking.Contains(collider))</span><br><span class="line">                    &#123;</span><br><span class="line">                        col = collider;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //用于记录总共需要多少个点，默认值为1个，每多一个敌人就增加一个</span><br><span class="line">            pointSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    	//设置状态准备进入Atking（）函数</span><br><span class="line">        isAtking = true;</span><br><span class="line">    	//此变量是为了控制激光进行位移</span><br><span class="line">        startTime = Time.time;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数中使用一个Colloder类型的col作为循环条件，依次寻找到所有单位，当然还可以设置一个上限值，其中范围检测因为仍然会找到已经被链接的单位，所以这里选择使用hashSet来将它们排除。剩下一个变量curPointSize，它为当前已链接点数量，在Atking中就可以明白它的作用。Atking太长了，先看第一部分吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Atking()</span><br><span class="line">    &#123;</span><br><span class="line">    	//为Atking2NotAtk做准备，我不希望看到断开之后是重新从自身位置慢慢出来，而是从敌人这个位置继续向前</span><br><span class="line">        lastPos = hit.point;</span><br><span class="line">    	</span><br><span class="line">    	//这里需要判断的是当敌人之间距离过大，我们需要重新进行状态的转换</span><br><span class="line">        for (int i = 1; i &lt; pointSize - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((colliders[i].transform.position - </span><br><span class="line">                 colliders[i - 1].transform.position).magnitude &gt; atkLinkRange * 1.2f)</span><br><span class="line">            &#123;</span><br><span class="line">                //为了让画面更连贯，我们直接跳过NotAtk阶段</span><br><span class="line">                Atk2NoAkting();</span><br><span class="line">                curPointSize = i + 1;</span><br><span class="line">                NotAkt2Atking();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	//防止有敌人挡在了第一个敌人和自身之间</span><br><span class="line">        if(hit.collider != colliders[0])</span><br><span class="line">        &#123;</span><br><span class="line">            Atk2NoAkting();</span><br><span class="line">            curPointSize = 2;</span><br><span class="line">            NotAkt2Atking();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>curPointSize = i + 1;</code>该参数的意义是下一次进入Atking函数时，从哪个点开始渐进光线，总不能状态一变就从头开始吧。后面的逻辑就是激光的渐进逻辑，具体分为两个不同的状态，一个是渐进状态，一个是光线已经全部链接完毕状态，具体看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Atking()</span><br><span class="line">    &#123;</span><br><span class="line">    	...</span><br><span class="line">		</span><br><span class="line">		//渐进状态</span><br><span class="line">        if(curPointSize &lt; pointSize)</span><br><span class="line">        &#123;</span><br><span class="line">        	//创建临时数组，该数组之后直接传到lineRenderer组件中</span><br><span class="line">            tempPoints = new Vector3[curPointSize + 1];</span><br><span class="line">			</span><br><span class="line">			//第一个点是自身，中间点为已经链接到的敌人位置，最后一个点是从倒数第二个敌人向最后敌人渐进</span><br><span class="line">			tempPoints[0] = transform.position;</span><br><span class="line">            for (int j = 1; j &lt; curPointSize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tempPoints[j] = colliders[j - 1].transform.position;</span><br><span class="line">            &#125;</span><br><span class="line">            tempPoints[curPointSize] = Vector3.Lerp(tempPoints[curPointSize - 1], </span><br><span class="line">            colliders[curPointSize - 1].transform.position, (Time.time - startTime) * laserSpeed);</span><br><span class="line">			</span><br><span class="line">			//设置点数量并传入数组</span><br><span class="line">            lineRenderer.positionCount = curPointSize + 1;</span><br><span class="line">            lineRenderer.SetPositions(tempPoints);</span><br><span class="line"></span><br><span class="line">			//当渐进点和渐进位置差的不多就可以认为已经到达</span><br><span class="line">            if (Vector3.Distance(colliders[curPointSize - 1].transform.position, </span><br><span class="line">            	tempPoints[curPointSize]) &lt; 0.2f)</span><br><span class="line">            &#123;</span><br><span class="line">                ++curPointSize;</span><br><span class="line">                startTime = Time.time;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //别忘了使激光看起来更有威力的灯光效果，将它们点亮并移动位置</span><br><span class="line">            for (int i = 0; i &lt; curPointSize - 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lights[i].SetActive(true);</span><br><span class="line">                lights[i].transform.position = tempPoints[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //链接完毕状态</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">        	//老五样了，最后一个点不需要渐进了。</span><br><span class="line">            tempPoints = new Vector3[pointSize];</span><br><span class="line">            tempPoints[0] = transform.position;</span><br><span class="line">            for (int i = 1; i &lt; pointSize; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                tempPoints[i] = colliders[i - 1].transform.position;</span><br><span class="line">            &#125;</span><br><span class="line">			lineRenderer.positionCount = curPointSize;</span><br><span class="line">            lineRenderer.SetPositions(tempPoints);</span><br><span class="line">			</span><br><span class="line">            //开灯，比上面多一盏</span><br><span class="line">            for (int i = 0; i &lt; pointSize - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lights[i].SetActive(true);</span><br><span class="line">                lights[i].transform.position = tempPoints[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //还需要在最后一个位置继续判断有没有新加进来的敌人</span><br><span class="line">            Collider[] tempCol = Physics.OverlapSphere(tempPoints[pointSize - 1], </span><br><span class="line">            					atkLinkRange * 0.8f, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Corpse&quot;));</span><br><span class="line">			//同样的逻辑</span><br><span class="line">            foreach (Collider collider in tempCol)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!enemyIsAtking.Contains(collider))</span><br><span class="line">                &#123;</span><br><span class="line">                    Atk2NoAkting();</span><br><span class="line">                    NotAkt2Atking(); </span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里需要提到之前NotAtking中的<code>CurPointSize = 2</code>了，因为我们中Atking中的转换为了画面流畅都跳过了NotAtking这一步，所以需要补上，不然就会出现下次Atking时很多多余的奇怪激光。</p>
<p>其他看起来没有什么困难吧，但其实这里各种各样的边界条件，数组下标的选取让你各种越界，还好都是小问题，最麻烦的Atking结束，那有请最后的状态切换函数登场：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Atk2NoAkting()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; maxAtkNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lights[i].SetActive(false);</span><br><span class="line">        &#125;</span><br><span class="line">        pointSize = 1;</span><br><span class="line">        enemyIsAtking.Clear();</span><br><span class="line">        isAtking = false;</span><br><span class="line">        lineRenderer.positionCount = 2;</span><br><span class="line">        Array.Clear(colliders, 0, colliders.Length);</span><br><span class="line">        Array.Clear(tempPoints, 0, curPointSize.Length);</span><br><span class="line">        startTime = Time.time;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>非常朴实，这里都是处理我们Atking留下来的烂摊子，把它们收拾好之后，准备下次的Atking或者是NotAtking函数。</p>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><p>还有一些初始化相关，基本搞定！</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">private <span class="type">void</span> Awake()</span><br><span class="line">&#123;</span><br><span class="line">    lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">// <span class="keyword">Start</span> <span class="keyword">is</span> <span class="keyword">called</span> <span class="keyword">before</span> the first frame <span class="keyword">update</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">Start</span>()</span><br><span class="line">&#123;</span><br><span class="line">    //把各种各样的东西先初始化一下</span><br><span class="line">    lastPos = <span class="keyword">transform</span>.position;</span><br><span class="line">    colliders = <span class="built_in">new</span> Collider[maxAtkNum];</span><br><span class="line"></span><br><span class="line">    //点光源池</span><br><span class="line">    lights = <span class="built_in">new</span> GameObject[maxAtkNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxAtkNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lights[i] = GameObject.Instantiate(Resources.<span class="keyword">Load</span>&lt;GameObject&gt;(&quot;redPoint&quot;), <span class="keyword">transform</span>.position, Quaternion.<span class="keyword">identity</span>);</span><br><span class="line">        lights[i].SetActive(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动感光波"><a href="#动感光波" class="headerlink" title="动感光波"></a>动感光波</h4><p>让我们先来看看真实的激光大概是什么样子的</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fa1.att.hudong.com%2F50%2F33%2F50200009239445156259334339321_w.jpg&amp;refer=http%3A%2F%2Fa1.att.hudong.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1662684768&amp;t=ca89fced6e9834f03f7bbc8776f8ced0" alt="img"></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xinhuanet.com%2Fmil%2F2022-07%2F14%2F1211666933_16577623946381n.jpg&amp;refer=http%3A%2F%2Fwww.xinhuanet.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1662623845&amp;t=f30bf4619edc395124a84b728b7ad61e" alt="img"></p>
<p>大部分外围有淡淡的光芒（我还是比较喜欢紫色激光），中间有一条白色线条，但就这对我来说还是有点不够有表现力，我希望有动态效果，于是在此基础上添加了纹理动画以及顶点动画，这样看起来更有威力了不是吗？</p>
<ol>
<li><p>我们很容易想到用一个纯白色来根据片元的v坐标的sin函数实现，将0-1的线性变化映射为0-1-0平滑过度的曲线，再搭配Gloss对其次方控制宽度。</p>
</li>
<li><p>之后是外围我想要实现的纹理动画效果了，用ps做了一张左右都为蓝色，中间为紫色的纹理，为保证平滑过渡，所以左右两边必须是一模一样的颜色，之后在顶点着色器中将顶点的uv坐标进行移动，<code>_Time</code>是unity定义的计时器，为float4类型，t代表自场景加载所经过的时间，4个分量分别为(t/20,t,2t,3t)，不论用哪一个，将它与我们的ColorSpeed相乘取小数，就可以得到0-1之间的一个数与转换的顶点uv相加就可以得到不断移动的纹理了，但由于这样的方向是反的，我们还需要用1减去小数仍然为0-1之间。</p>
</li>
</ol>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E7%B4%AB%E8%93%9D%E7%B4%AB.png" alt="紫蓝紫"></p>
<ol>
<li>别忘了还有抖抖的效果，也就是我们的顶点动画，这里首先我们一定会想到用随机数，那怎么取得随机数呢？这里可不能像C#脚本一个Ramdon.Range（）就得到随机数，所以这里需要想新的方法，在图形学中这种随机也称为噪声，它通常用于实现完全不规则的一些效果，如岩浆、电波等等，具体见参考文献第一篇。这里用三个魔法数字可以得到近乎完全的随机数，第一个问题解决了，还有一个问题是我们不希望整条线都在抖动，那样也会让人感动非常不真实，所以这里我同样让它乘以一个sin函数，映射为0-1，抖动幅度随距离增加，另外通过Magnitude来调节整体抖动幅度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line">Shader &quot;Particles/Additive&quot; &#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_TintColor(&quot;Tint Color&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_MainTex(&quot;Particle Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_InvFade(&quot;Soft Particles Factor&quot;, Range(0.01,3.0)) = 1.0</span><br><span class="line">		_ColorGloss(&quot;Gloss&quot;, Float) = 10</span><br><span class="line">		//颜色渐变</span><br><span class="line">		_ColorSpeed(&quot;Color Speed&quot;, Range(0.01, 10)) = 1</span><br><span class="line">		//顶点动画</span><br><span class="line">		_Magnitude(&quot;Distortion Magnitude&quot;, Float) = 1</span><br><span class="line">		_Frequency(&quot;Distortion Frequency&quot;, Float) = 1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Category&#123;</span><br><span class="line">		//分别为开启透明通道，开启渲染类别，以及禁用批处理</span><br><span class="line">		Tags &#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;RenderType&quot; = &quot;Transparent&quot; &quot;DisableBatching&quot; = &quot;True&quot;&#125;</span><br><span class="line">		//颜色混合，会和组件上的颜色进行混合处理</span><br><span class="line">		Blend SrcAlpha One</span><br><span class="line"></span><br><span class="line">		SubShader &#123;</span><br><span class="line">			Pass &#123;</span><br><span class="line"></span><br><span class="line">				CGPROGRAM</span><br><span class="line">				#pragma vertex vert</span><br><span class="line">				#pragma fragment frag</span><br><span class="line">				#pragma multi_compile_particles</span><br><span class="line">				#pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">				#include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">				sampler2D _MainTex;</span><br><span class="line">				fixed4 _TintColor;</span><br><span class="line">				float _ColorSpeed;</span><br><span class="line">				float4 _MainTex_ST;</span><br><span class="line">				float _ColorGloss;</span><br><span class="line">				//顶点动画</span><br><span class="line">				float _Magnitude;</span><br><span class="line">				float _Frequency;</span><br><span class="line"></span><br><span class="line">				struct appdata_t &#123;</span><br><span class="line">					float4 vertex : POSITION;</span><br><span class="line">					fixed4 color : COLOR;</span><br><span class="line">					float2 texcoord : TEXCOORD0;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				struct v2f &#123;</span><br><span class="line">					float4 vertex : SV_POSITION;</span><br><span class="line">					fixed4 color : COLOR;</span><br><span class="line">					float4 texcoord : TEXCOORD0;</span><br><span class="line">					UNITY_FOG_COORDS(1)</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				//取随机数函数，shader中没有直接可用的函数，返回-1到1（不包含边界）的随机数</span><br><span class="line">				float InterleavedGradientNoise(float2 pos)</span><br><span class="line">				&#123;</span><br><span class="line">					float3 magic = float3(12.9898, 78.233, 43758.5453123);</span><br><span class="line">					return frac(magic.z * frac(dot(pos, magic.xy)));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				v2f vert(appdata_t v)</span><br><span class="line">				&#123;</span><br><span class="line">                    float halfPi = 1.57079632675f;</span><br><span class="line">					v2f o;</span><br><span class="line">                    //随机偏移值</span><br><span class="line">					float4 offset = float4(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">                    //调用该随机函数，传入的参数也很重要，我选择使用顶点位置当作参数</span><br><span class="line">                    //后面用sin调控光线越远抖的越厉害，Magnitude调控整体幅度</span><br><span class="line">					offset.xyz = _Magnitude * InterleavedGradientNoise(float2(v.vertex.x, v.vertex.y)) 									*sin(v.texcoord.x * halfPi);</span><br><span class="line">					o.vertex = UnityObjectToClipPos(v.vertex + offset);</span><br><span class="line">					o.color = v.color;</span><br><span class="line">                    //用zw保存uv，并加上一个时间函数，让uv动起来！</span><br><span class="line">					o.texcoord.zw = TRANSFORM_TEX(v.texcoord,_MainTex) + </span><br><span class="line">                        				(1 - frac(float2(_ColorSpeed, 0.0) * _Time.y));</span><br><span class="line">					o.texcoord.xy = v.texcoord.xy</span><br><span class="line">                    //用UnityCG.cginc头文件中内置定义的宏处理雾效，从顶点着色器中输出雾效数据  </span><br><span class="line">					UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">					return o;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				sampler2D_float _CameraDepthTexture;</span><br><span class="line">				float _InvFade;</span><br><span class="line"></span><br><span class="line">				fixed4 frag(v2f i) : SV_Target</span><br><span class="line">				&#123;</span><br><span class="line">                    float Pi = 3.1415926535f;</span><br><span class="line">					//控制光线内部的白色，Gloass调节大小</span><br><span class="line">					fixed ratio = pow(sin(i.texcoord.y * pi), _ColorGloss);</span><br><span class="line">                    //将纹理与主颜色（我这里就用白色）混合</span><br><span class="line">					fixed4 col = tex2D(_MainTex, i.texcoord.zw) * (1 - ratio) + _TintColor * ratio;</span><br><span class="line">                    //中间向外围慢慢变淡</span><br><span class="line">                    col.a = sin(i.texcoord.y * pi)</span><br><span class="line">                    //用UnityCG.cginc头文件中内置定义的宏启用雾效 </span><br><span class="line">					UNITY_APPLY_FOG_COLOR(i.fogCoord, col, fixed4(0,0,0,0)); </span><br><span class="line">					return col;</span><br><span class="line">				&#125;</span><br><span class="line">				ENDCG</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出初中学的三角函数是多么的好用啊，它让我们实现平滑过渡是如此简单，目前为止大部分的需求都满足了，但还是又一些美中不足，就是强力的激光一定会在周围的地面上产生光影，目前这一点还没能实现，如果大伙们有兴趣，可以自己动手去实现它。</p>
<h4 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h4><p>链接：<a href="https://pan.baidu.com/s/1ew1lCZNnSHyS4A4UC1PAYg?pwd=naqo">https://pan.baidu.com/s/1ew1lCZNnSHyS4A4UC1PAYg?pwd=naqo</a><br>        提取码：naqo </p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/u013412391/article/details/120618727?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-120618727-blog-121413434.pc_relevant_multi_platform_featuressortv2removedup&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">实验通过使命召唤所使用的 Interleaved Gradient Noise 在Shader中生成随机噪声</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shaderer</tag>
      </tags>
  </entry>
  <entry>
    <title>十九：包围盒（下）</title>
    <url>/2022/07/18/%E5%85%89%E8%BF%BD19/</url>
    <content><![CDATA[<h4 id="物体列表的AABB"><a href="#物体列表的AABB" class="headerlink" title="物体列表的AABB"></a>物体列表的AABB</h4><p>上一章中基本讲完了各个类的aabb写法，还剩最后一个，物体列表类的aabb生成，下面给出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;aabb.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//包围盒生成函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果物体列表为空，我们无法为空物体生成包围盒，直接返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="comment">//设定一个flag用来初始化一个包围盒。</span></span><br><span class="line">    <span class="keyword">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//遍历列表内物体。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="comment">//如果遍历刀列表内有物体无法建立包围盒（返回fasle），那对不起，物体列表也无能为力了，直接返回。</span></span><br><span class="line">        <span class="comment">//注意，这个if中的bounding_box函数把这个子物体的包围盒赋给了temp_box。</span></span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(time0, time1, temp_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果是第一次建立包围盒，那直接使用temp_box。</span></span><br><span class="line">        <span class="comment">//否则要求本循环子物体的aabb和之前包围盒的包围盒，使用surrounding_box函数。</span></span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        <span class="comment">//在首次建立包围盒成功之后，把first_box置false。</span></span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    物体列表的aabb的求法就是逐个子物体遍历，求它们这些物体共同的包围盒。其中使用到了上一章中提到的计算两个包围盒的包围盒的函数surrounding_box。</p>
<p>自此，我们已有的物体类：球类、移动的球类和物体列表类都接入了生成包围盒的函数。</p>
<h4 id="BVH类"><a href="#BVH类" class="headerlink" title="BVH类"></a>BVH类</h4><p>是时候把这一切组织起来了，记得上一章中提到的对象划分已经对象划分下的树状结构吗？我们还没有给它起名字呢：我们将创建一个树状结构，树的每一个节点都是一个包围盒或者一个物体，包围盒一层层的嵌套，物体作为叶子节点被一层一层的包裹着，这种结构叫<strong>层次包围盒</strong>（Bounding Volume Hierarchies），或称<strong>BVH</strong>。</p>
<p>BVH既然是一棵树，我们首先得创建它的节点，和其他所有树结构一样，它的节点得储存孩子信息。如果我们把事情再想得简单一点，每个大包围盒内部包着两个子包围盒，那BVH结构就变成了一个二叉树，看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个节点类是物体类的子类，我们还是得依靠多态的便利性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bvh_node</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">bvh_node</span>();</span><br><span class="line">        <span class="comment">//这是传入物体列表的构造，直接调用下面的有vector的构造。</span></span><br><span class="line">        <span class="built_in">bvh_node</span>(<span class="keyword">const</span> hittable_list&amp; list, <span class="keyword">double</span> time0, <span class="keyword">double</span> time1)</span><br><span class="line">            : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//这个构造函数非常复杂，之后再说。</span></span><br><span class="line">        <span class="built_in">bvh_node</span>(</span><br><span class="line">            <span class="keyword">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">            <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end, <span class="keyword">double</span> time0, <span class="keyword">double</span> time1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//override hit函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成包围盒的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//本节点的左右子节点指针，它们都是物体类型的指针。</span></span><br><span class="line">        shared_ptr&lt;hittable&gt; left;</span><br><span class="line">        shared_ptr&lt;hittable&gt; right;</span><br><span class="line">        <span class="comment">//本节点的包围盒，会在构造函数里生成。</span></span><br><span class="line">        aabb box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，bvh节点类的包围盒我们会在构造函数里生成，这里直接赋值即可。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bvh_node::bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​    来看一下hit函数，在这里你会看到包围盒是如何减少计算的——你连我的盒子都碰不到，那我们就没有继续看下去的必要了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bvh_node::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你连我的盒子都碰不到，那我们就没有继续看下去的必要了。</span></span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续遍历左右物体。</span></span><br><span class="line">    <span class="keyword">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//见下方讲解。</span></span><br><span class="line">    <span class="keyword">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, t_min, hit_left ? rec.t : t_max, rec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历过程中只要不是所有的子物体都没碰到，就算产生了碰撞。</span></span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意上面的代码中有一个剪枝操作，在第十行中，遍历右子树节点的时候先检查了左子树返回值是否为true，即光线有无和左子树碰撞，如果有，那么在判断右子树的时候就又有一个参照物了：“右子树上的物体是否是先被光线碰到的？或者它被左子树上的物体遮挡了？改变t的范围，只在右子树物体离光源更近的情况下，才认可这次碰撞，其他的直接剪掉。”</p>
<p>我们现在来理一下思路，我们写这样的hit函数会发生什么，假设一个bvh在场景中构造完毕（虽然我们暂时没有给出用来构造bvh的构造函数），即，现在main函数中那个world物体不再是一个物体列表，换做是一个已经构建好的bvh，现在有一根光线自相机或者某处发射过来：</p>
<p>既然有光线，我们就得调用场景中所有物体的hit，现在只有一个物体那就是bvh，我们只需要调用它的hit即可。如果这根光线没有碰到最外层的盒子，那上述代码中的第四行<code>return false</code>就是整个碰撞检测的最后一句代码，在这之前我们只调用了一个aabb的hit函数，无论场景中有多少物体，也只需要调用这一个函数即可。再想想如果我们没有bvh，而是使用物体列表来管理场景中的物体，那我们会做哪些工作——如果t的范围不考虑进去的话，即便这根光线没有碰到任何一个物体，我们也需要调用每个物体的hit函数，其中就包括一些球，每个球意味着要求一次一元二次方程的求根公式。</p>
<p>要知道，场景是无限大的，物体只占了场景中微不足道的某个角落，我们创建的大部分光线实际上都是没有和物体发生碰撞的光线，光考虑这部分光线，bvh就比传统的物体列表要快上几个数量级了。</p>
<h4 id="构造BVH"><a href="#构造BVH" class="headerlink" title="构造BVH"></a>构造BVH</h4><p>到此为止，核心问题还没有解决，如何构造一棵bvh树呢？</p>
<p>先来讲一讲上一章的遗留问题，对象划分的依据是什么？首先，必须要明确一个概念：我们现在不需要任何规律的把bvh里的所有物体粗暴的分成两堆，代码也能很好的工作，即便包围盒内部的包围盒比外面的盒子还要大，也不影响代码的运行，充其量只是慢了一点。我们要找的对象划分的依据，是能让程序运行更快，更发挥bvh优势的一种划分方式，它可以是这样一个划分：</p>
<p>先随便找一个轴，x、y或者z轴，把物体列表里的物体按照这个轴从小到大的顺序进行排序并划分成两堆，对于左右子树，用这两堆分别再次进行递归。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">    <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end, <span class="keyword">double</span> time0, <span class="keyword">double</span> time1</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">//创建一个指针指向形参中的物体列表，增加代码可读性。</span></span><br><span class="line">    <span class="keyword">auto</span> objects = src_objects; </span><br><span class="line">    <span class="comment">//随机一个int值，0，1，2分别代表x，y，z轴，这个函数之后会给出。</span></span><br><span class="line">    <span class="keyword">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//通过选定的是哪个坐标轴选到特定的比较器，注意，这个comparator是一个函数指针</span></span><br><span class="line">    <span class="comment">//之后会给出box_x_compare等三个函数的签名即具体函数体。</span></span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                                  : box_z_compare;</span><br><span class="line">    <span class="comment">//本列表中有多少物体？</span></span><br><span class="line">    <span class="keyword">size_t</span> object_span = end - start;</span><br><span class="line">    <span class="comment">//如果发现这个列表中只有一个物体了，那令本节点的左右孩子指针都指向这个物体。</span></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) &#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有俩物体，按照给定轴信息，看看谁在左，谁在右。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start+<span class="number">1</span>])) &#123;</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start+<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = objects[start+<span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果本段物体列表有超过两个物体，直接对其进行排序，并且二分之后，开启下一轮递归。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line">        <span class="comment">//二分找中值。</span></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">        left = make_shared&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = make_shared&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，代码运行到这里，说明本节点的左右孩子递归代码都已经执行完毕。是时候给他们套上包围盒了。</span></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line">    <span class="comment">//给左右节点分别套盒子，并且利用返回信息来判断盒子是否成功生成。</span></span><br><span class="line">    <span class="keyword">if</span> (  !left-&gt;<span class="built_in">bounding_box</span> (time0, time1, box_left)</span><br><span class="line">       || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">    )</span><br><span class="line">        <span class="comment">//进入这个if表示左右孩子的某个盒子没有生成成功。</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//注意，这里有一个bug，如果bouding_box返回false,其box一定是没有被赋值的，即为空。</span></span><br><span class="line">    <span class="comment">//空box调用下面的surrounding_box函数是会出错的，因为访问了空物体。</span></span><br><span class="line">    <span class="comment">//我们暂时没有无法生成包围盒的物体，如：无限大的平面。所以这个问题我们先不要管。</span></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机范围内的int值的函数如下所示，工具函数都写到rtweekend.h里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">random_int</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回[min,max]范围内int值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">random_double</span>(min, max+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    最后，我们给出比较器的函数代码，注意把它写在上述构造函数的前面，让编译器可以成功的找到他们：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较两个物体的盒子“大小”的主要函数，第三个参数axis表示比较的是哪个轴。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">box_compare</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b, <span class="keyword">int</span> axis)</span> </span>&#123;</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line">    <span class="comment">//先求两个物体的盒子。</span></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//比较两个盒子的较小的边，谁的给定轴分量越大，谁就越大。</span></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是三个轴比较函数，都是调用上面的比较函数。这三个函数存在的意义是方便构造函数中的函数指针。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">box_x_compare</span> <span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">box_y_compare</span> <span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">box_z_compare</span> <span class="params">(<span class="keyword">const</span> shared_ptr&lt;hittable&gt; a, <span class="keyword">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试包围盒"><a href="#测试包围盒" class="headerlink" title="测试包围盒*"></a>测试包围盒*</h4><p>现在回到动态模糊那一章的最后一个场景，我们分别使用物体列表和BVH来装载场景物体，并运行光追器，来对比一下两者的耗时，首先，给main函数打个时间戳：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !MULTITHREAD</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//需要引用此头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个函数可以获取当前时间，并转换成某种基于毫秒的整数。</span></span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">GetTickCount64</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main中的全部代码都要被包进来。</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//再次获得当前时间，并且减去main函数开头时记录的时间，便得到了毫秒差。</span></span><br><span class="line">    <span class="keyword">int</span> time = <span class="built_in">GetTickCount64</span>() - start;</span><br><span class="line">    time = time / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">auto</span> minute = time / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">auto</span> second = time % <span class="number">60</span>;</span><br><span class="line">    <span class="comment">//简单转换一下，并输出出去。</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;took &quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;m &quot;</span> &lt;&lt; second &lt;&lt;<span class="string">&quot;s  to complete. \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，用bvh提到程序中的物体列表，在main函数中调用random_scene的地方，直接把物体列表传到bvh_node类的构造函数里，创建一个bvh即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用函数生成一个有着许多随机小球的场景！！！</span></span><br><span class="line"><span class="comment">//auto world = random_scene();</span></span><br><span class="line"><span class="keyword">auto</span> world = <span class="built_in">bvh_node</span>(<span class="built_in">random_scene</span>(),<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>传入构造函数的两个时刻值0和1是和相机的快门打开时间和关闭时间保持一致的。这决定了我们程序中所有的移动的球对象的包围盒都是通过这两个时间值来计算的。对于直线运动的球来说，在两个极端情况下的包围盒的包围盒，即是最终的包围盒。</p>
<p>运行程序，可见命令行中的运行时间（release-x86）：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1651405102043-9a34d32d-2fef-4880-9196-5a97a9d00308.png" alt="img"></p>
<p>对比前者——物体列表作为容器下的运行时间，后者bvh容器下的运行时间快了好几倍。</p>
<h4 id="课后实践"><a href="#课后实践" class="headerlink" title="课后实践"></a>课后实践</h4><ol>
<li>在脑海中构建一个少量物体的bvh，按顺序阅读bvh的构造函数，体会物体被二分和生成包围盒的过程。接下来思考hit函数中包围盒是如何和光线求交的，这有助于理解整体架构。</li>
<li>将bvh应用于多线程模式，并生成一个视频，比较使用包围盒前后的序列帧生成时间。</li>
<li>倘若使用八叉树包围盒，我们该如何设计？并了解另外两种包围盒KD-Tree和BSP-Tree。</li>
<li>将之前所有的关键类的关系做出一个类图，并梳理他们之间的调用过程，回想一下我们是怎么得到一张图片的。</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第3.8节到第3.10节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十八：包围盒（上）</title>
    <url>/2022/07/01/%E5%85%89%E8%BF%BD18/</url>
    <content><![CDATA[<p>我们开开心心的讲完了中篇的前两章，渲染出了炫酷的动态模糊效果，它简单而且漂亮。但是，该来的总归还是要来，下面的几章会给大伙儿整些头疼的：包围盒。</p>
<h4 id="光线碰撞中的重复冗余"><a href="#光线碰撞中的重复冗余" class="headerlink" title="光线碰撞中的重复冗余"></a>光线碰撞中的重复冗余</h4><p>回顾一下我们发射光线到回收颜色的全过程，就会发现，我们的代码有哪些不合理的地方：</p>
<p>相机朝虚拟视口中的像素格子发出光线，这跟光线会尝试调用场景中所有物体（本项目中一个名为world的物体列表）的hit函数——会按物体<strong>插入物体列表时候的顺序</strong>对物体进行逐一调用它们自己的hit函数。这些子物体要不还是物体列表，或者是球、移动的球之类的实体物体。</p>
<p>我们再来看看球和移动的球是如何处理光线碰撞的，我们通过解一个二元一次方程来判断球是否和光线碰撞，返回碰撞时刻以及碰撞点信息等等（具体见《球》）。这意味着对于每一次射出光线（无论是相机射出的，还是材质表面反射得来的）都要和场景中所有的球进行一次判断。如果场景中有100个物体，意味着，每一次hit之后反射的光线，就要解100个二元一次方程。假设平均每根光线会在场景中弹射5次，对于每一根光线我们要解500个方程，采样数会把这个数字拉到50000（假设每个像素采样100次），而像素数量会把这个数字拉到亿级别（假设我们的场景是400*300），现在看看我们球类代码中的hit函数，那么一大坨，你能想象每次在命令行中点击回车，电脑运行了几亿次这部分的代码吗？</p>
<p>不合理的地方在哪里呢？假设我们有一个光线朝西边径直而去，在光线射过去的方向的相反方向有99颗球，这九十九颗球也都逃不过碰撞检测函数。这分莫名其妙的开销应该是可以通过某种方式避免的。</p>
<p>总结一下刚刚所说的：<strong>光线-物体交集是光线追踪器中的主要时间瓶颈，时间与物体数量成线性关系。这是对同一模型的重复冗余搜索，有没有什么办法可以使之复杂度降低呢？比如通过某种二分法让其的复杂度降低到对数等级？</strong></p>
<h4 id="空间划分与八叉树"><a href="#空间划分与八叉树" class="headerlink" title="空间划分与八叉树"></a>空间划分与八叉树</h4><p>我提到了二分法，但应该知道，二分法必须针对已排序的数据才有作用，也就是说，我们必须让场景中的物体依照某种规则变得有序，才可以使用二分法的思想降低复杂度。</p>
<p>假设我们的物体都集中在以原点为中心的单位立方体里面，很容易可以想到一种划分方式：先通过三个坐标轴把空间划分为八个小立方体。</p>
<p>如果把任意一个数带入t，光线的公式<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/31ae9c334f3c47daac82d08f80c0a96b.svg" alt="img">，最终得到的坐标点的x,y,z都不会大于0，那我们就没有必要检查位于第Ⅰ象限的物体了。如果x,y,z有全大于0的情况，说明光线与第Ⅰ象限有交点，我们就对第一象限中的小立方体继续划分——划分成八个更小的立方体，再检查光线是否与它们有交点，位于和光线无交点的小立方体内的物体，我们就无需检查了。这种思想叫<strong>空间划分</strong>。</p>
<p>整个搜索链条就如同树一样，先看有没有和大立方体有交集，如果有交集就再看其中的小立方体，然后一直往下看，直到我们人为规定的某个大小的立方体内不再有更小的立方体，就直接查看该立方体内的物体即可。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1646477603061-2d3fc2ee-9316-414c-b911-72b25014180f.png" alt="img"></p>
<p><strong>八叉树</strong>——这种结构有一个浅显易懂的名字。很容易可以写出关于八叉树的伪代码（这个八叉树只有两层，第三层就是物体层）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (光线碰到了某个立方体)</span><br><span class="line">    <span class="keyword">if</span>(光线碰到了子立方体<span class="number">1</span>号)&#123;</span><br><span class="line">        <span class="keyword">if</span>(光线碰到了子立方体<span class="number">1</span>号内的某个物体)&#123;</span><br><span class="line">            处理碰撞信息。</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(光线碰到了子立方体<span class="number">2</span>号)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(光线碰到了子立方体<span class="number">7</span>号)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>我们没有讨论如何判断光线和立方体求交，也没有讨论物体在两个立方体的边界上我们要如何处理，篇幅有限。我们不会在项目中使用八叉树，但是它确实是一个可行的方案，并且很容易被图形工程师们提起。</p>
<p>我们并不准备使用空间划分的八叉树来管理我们场景中的物体，因为还有另一个备选方案可以使用——<strong>对象划分</strong>。这种空间划分比空间划分使用更为广泛。</p>
<h4 id="对象划分简述"><a href="#对象划分简述" class="headerlink" title="对象划分简述"></a>对象划分简述</h4><p>现在假设空间中有15个对象，我们按照某种规律把它们分成俩个部分，如下图所示：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1646539589363-daec5150-6cc0-45db-8aad-8222c6717e88.png" alt="img"></p>
<p>至于划分对象的算法我们之后再说。</p>
<p>这是三维空间的某种对象划分在二维上的投影示意图。可见对象划分之后的各个区域是很可能会重叠的，但是也就不再存在一个物体处于区域边界的情况。</p>
<p>当然这里也依然存在一个树状结构。光线先和最外层和紫色部分算交点，如果存在交点才会查看红蓝两个区域的交点情况。</p>
<h4 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h4><p>我们已经决定使用对象划分来加速光线碰撞，这里有很多问题待解决：具体如何划分物体？树状结构如何搭建？新的场景物体又该如何管理（物体列表显然已经不满足要求了）？</p>
<p>这些问题先靠一边，我们先来把目光瞄准到所谓“区域”，也就是包围盒。</p>
<p>包围盒应该是什么样的？我们又如何计算光线与盒子求交呢？</p>
<p>如果不考虑性能，包围盒可以是任何形状，它可以是一个大球，包裹住内部的小球，这样我们只需要算一次一元二次方程就可以得到光线和大球碰撞的结果，如果有碰撞再计算光线和内部小球的碰撞情况。而且我们计算光线和大球求交的时候不需要计算具体反射光线，完全不需要调用材质代码，只需要返回是否碰撞到信息，以便我们去判断需不需要和内部小球进一步计算碰撞即可。</p>
<p>但是光线和球的碰撞计算复杂度还是高了一点，有一种结构最擅长处理和光线求交，这就是轴向立方体。使用轴向立方体作为包围盒的形状，这就是<strong>轴向包围盒（**</strong>Axis-Aligned Bounding Boxes<strong> </strong>）<strong>，又叫</strong>AABB**。</p>
<p>轴向立方体就是所有的边都和坐标轴平行的立方体，它和光线求交的计算复杂度低，且易于理解。</p>
<p>先不看Z轴，在平面上的轴向包围盒如下图所示，空间中的包围盒和其原理相同，可以通过推广得到：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1647064464317-099412bb-3163-4426-a4e4-bb19920e8b88.png" alt="img"></p>
<p>平面上的AABB（2D-AABB）即是四条直线<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/4974822c92d19605bcd18bf7fdf478b0.svg" alt="img">围成的区域。对于这对平行线<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/c36f7ad9930be00ac943fdf62adee947.svg" alt="img">，光线会和它们产生两个交点，当然，另外一对平行线同理：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1647064714114-9991e2f8-794b-473b-bd89-ad8480fc8c0e.png" alt="img"></p>
<p>看看光线传播到$x$分量为和$x_0$时$x_1$，时间$t_1$和$t0$是多少，只要把光线原点位置坐标向量A的x分量和方向向量b的x分量带入公式$P(t) = A + tb$即可：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/626aeee8e7ac4fa7933d7400f02ead03.svg" alt="img">和<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/8b5d8216af9ea05bfc8c35fb3e54f441.svg" alt="img"></p>
<p>同理，在y轴上你同样可以得到两个时间：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/bce9659878ed8e8581ba4708410d8fec.svg" alt="img">和<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/02d0d3620f1610730048fed887bc6b18.svg" alt="img"></p>
<p>好，有了这四个时间值，我们如何判断这根光线有没有和2D-AABB相交呢？看下图： </p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1647270555009-073512e0-d9cc-4f73-b5d1-bc1f2b43372b.png" alt="img"></p>
<p>对于上图中上方的光线，其(t0,t1)和(t2,t3)两个时间区域并无交集，在图中的表现即是蓝色和绿色的线段并无重合处，那就可以断言，这根光线和盒子并无交集。而下面的光线可见明显蓝绿重合，它一定是一根穿过盒子的光线。</p>
<p>很容易就能把这个原理推广到三维的情形下：</p>
<p><strong>3D-AABB由三对面组成，假设光线传播到与XoY面平行的那一对面上的时间是t0,t1，传播到YoZ面上的时间t2,t3，ZoX则是t4,t5。则一定有：光线和盒子相交 &lt;==&gt; (t0,t1)、(t2,t3)和(t4,t5)两两有交集。</strong></p>
<p>伪码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compute</span> (tx0, tx1)</span><br><span class="line"><span class="built_in">compute</span> (ty0, ty1)</span><br><span class="line"><span class="built_in">compute</span> (tz0, tz1)</span><br><span class="line"><span class="comment">//返回这三个时间段有无重叠</span></span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1))</span><br></pre></td></tr></table></figure>
<p>对于坐标轴上的两个区间(a,b)和(c,d)，判断区间有无重叠，只需要取a和c较大的那一个和b与d中较小的那一个比较，如果前者小于后者，说明有重叠，这部分的伪码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">overlap</span><span class="params">(a, b, c, d)</span></span></span><br><span class="line"><span class="function">    f </span>= <span class="built_in">max</span>(a, c)</span><br><span class="line">    F = <span class="built_in">min</span>(b, d)</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (f &lt; F)</span><br></pre></td></tr></table></figure>
<p>铺垫完成，接下来我们来从代码层面构造AABB。</p>
<h4 id="编写AABB类"><a href="#编写AABB类" class="headerlink" title="编写AABB类"></a>编写AABB类</h4><p>创建aabb.h文件，敲入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aabb</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">aabb</span>() &#123;&#125;</span><br><span class="line">        <span class="comment">// 如何唯一确定一个3D-AABB？只需要两个点即可！</span></span><br><span class="line">        <span class="built_in">aabb</span>(<span class="keyword">const</span> point3&amp; a, <span class="keyword">const</span> point3&amp; b) &#123; minimum = a; maximum = b;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回三个分量都较小的那一个点。</span></span><br><span class="line">        <span class="function">point3 <span class="title">min</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> minimum; &#125;</span><br><span class="line">        <span class="comment">//返回minimum点在盒子上的对角点，即三个分量都较大的那个点。</span></span><br><span class="line">        <span class="function">point3 <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> maximum; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//光线和AABB求交代码，注意这个hit和物体类的hit没有一毛钱关系。</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">//for循环判断三个轴向的三对面和光线碰撞的时间。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++) &#123;</span><br><span class="line">                <span class="comment">//见解析。</span></span><br><span class="line">                <span class="keyword">auto</span> t0 = <span class="built_in">fmin</span>((minimum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                               (maximum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                <span class="keyword">auto</span> t1 = <span class="built_in">fmax</span>((minimum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                               (maximum[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                t_min = <span class="built_in">fmax</span>(t0, t_min);</span><br><span class="line">                t_max = <span class="built_in">fmin</span>(t1, t_max);</span><br><span class="line">                <span class="keyword">if</span> (t_max &lt;= t_min)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        point3 minimum;</span><br><span class="line">        point3 maximum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​    我们使用两个point3来唯一确定一个3D-AABB，就如同我们可以在平面直角坐标系上用左下角和右上角两个点确定一个2D-AABB一样。</p>
<p>我们来看看hit函数里的for循环中做了什么？</p>
<p>首先，我们把minmum和maximum点的$x$分量都带入了公式$P(t) = A+tb$来计算光线穿过这一对面的时间值$t_0$和$t_1$，注意，这里的fmin和fmax函数是为了确保$t_0$小于$t_1$。因为minmum[0]一定是小于maximum[0]的，但是无法确定$\frac{minimum[0]-A_x}{b_x}$就一定比$\frac{maxmum[0]-A_x}{b_x}$小，想想光线从x轴无穷大处朝x变小的方向射过来，这时候$\frac{minimum[0]-A_x}{b_x}&gt;\frac{maxmum[0]-A_x}{b_x}$，我们就需要调换存储和$t_0$和$t_1$。</p>
<p>紧接着，我们开始对区间求交集。hit函数传进来的t_min和t_max代表我们认可的t的范围，这个与物体类的hit函数的参数中的t_min和t_max是一个道理，用来给我们切去不必要的碰撞（如负值t）的。现在把($t_0$,$t_1$)和(t_min,t_max)求交，得到的值如果是一个不存在的区间，则表示“在您认可的t的区间内，不存在一个t让光线传播到AABB的x轴同向对面中”。</p>
<p>紧接着对y和z轴上的对面做同样的操作，期间一旦发现求交后区间不存在，便可断定“光线在给定的时间区间内不曾跨过指定对面”，对三个对面进行这样的操作之后，求交的结果存在与否则代表了“光线是否在某一时刻同时在三个对面之间，即是否曾射入AABB之中”。</p>
<h4 id="优化hit函数"><a href="#优化hit函数" class="headerlink" title="优化hit函数"></a>优化hit函数</h4><p>我们换一种方式描述hit代码中的逻辑，下面的代码比起原先的hit函数冗长的逻辑显得更为清晰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">aabb::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[a];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[a] - r.<span class="built_in">origin</span>()[a]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[a] - r.<span class="built_in">origin</span>()[a]) * invD;</span><br><span class="line">        <span class="comment">//如果光线的方向向量某个分量为负，则光线一定会逆向穿过本轴上的对面。</span></span><br><span class="line">        <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        t_min = t0 &gt; t_min ? t0 : t_min;</span><br><span class="line">        t_max = t1 &lt; t_max ? t1 : t_max;</span><br><span class="line">        <span class="keyword">if</span> (t_max &lt;= t_min)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给物体绑定包围盒"><a href="#给物体绑定包围盒" class="headerlink" title="给物体绑定包围盒"></a>给物体绑定包围盒</h4><p>AABB类已经被构造出来了，我们现在得把它和物体类联系起来了，因为包围盒子终归是要包裹住物体的。</p>
<p>先来修改底层，给物体类添加一个纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;aabb.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//制造包围盒子的函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>来看看这个新的函数，首先，它的返回值是bool类型，这是因为我们得给无法被包围盒包裹的物体一个解释，比如一个无限大的平面（以后可能会有），如果返回true，则表示包围盒生成失败。</p>
<p>生成的包围盒通过参数中的引用传递出去 ：<code>aabb&amp; output_box</code>。</p>
<p>至于另外两个参数time0和time1，它对于移动的球类以及后续所有动态的物体都是必要的，因为如果不给定一个时间区间，物体运动的轨迹将会无限长，无法被包围盒包裹。</p>
<p>很容易可以写出球类的包围盒生成函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//override包围盒生成函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="keyword">double</span> time0, <span class="keyword">double</span> time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是一个球的外切立方体。它是能包裹住球且体积最小的AABB。</span></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        center - <span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + <span class="built_in">vec3</span>(radius, radius, radius));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    下面是移动的球类的包围盒生成函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;aabb.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moving_sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//override包围盒生成函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">bounding_box</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> _time0, <span class="keyword">double</span> _time1, aabb&amp; output_box)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">moving_sphere::bounding_box</span><span class="params">(<span class="keyword">double</span> _time0, <span class="keyword">double</span> _time1, aabb&amp; output_box)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们先生成移动的球在两个极端时间下的包围盒。</span></span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="comment">//然后再求这两个包围盒的包围盒。这个surrounding_box函数会在之后给出。</span></span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    下面添加两个包围盒的包围盒函数<code>surrounding_box(box0, box1)</code>到aabb.h中，它的本质是通过比较去筛选包围盒中的两个point3的分量，使得minimum的各个分量取两个盒子的minimum分量的较小值，maximum的所有分量都取两个盒子的maximum分量的较大值，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>&#123;</span><br><span class="line">    <span class="function">point3 <span class="title">small</span><span class="params">(fmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">                 fmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">                 fmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">big</span><span class="params">(fmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">               fmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">               fmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small,big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aabb对于本章开头提到的树状结构来说相当于叶子节点，本章基本完成了叶子节点的构造，但对于整个树状结构的搭建来说，才是刚刚开始。</p>
<h4 id="课后实践"><a href="#课后实践" class="headerlink" title="课后实践"></a>课后实践</h4><p>尝试编写物体列表类的包围盒生成函数（这个函数会在下一章给出）。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第3.1节到第3.7节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十七：动态模糊</title>
    <url>/2022/06/13/%E5%85%89%E8%BF%BD17/</url>
    <content><![CDATA[<h4 id="动态模糊"><a href="#动态模糊" class="headerlink" title="动态模糊"></a>动态模糊</h4><p>“带时间的光线”划开了新旧篇章的界限，新的维度下，新的可能性在孕育。</p>
<p>这一章中就来看看，“时间”会给这个世界带来什么变化。本章我们会创建继“球”之后，第二个实体物体类：“移动的球”。呃，抱歉，它还是球。</p>
<h4 id="匀速运动的球"><a href="#匀速运动的球" class="headerlink" title="匀速运动的球"></a>匀速运动的球</h4><p>创建新文件moving_sphere.h，并敲入如下代码，其实其中大部分代码是从球类中复制过来的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MOVING_SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOVING_SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moving_sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">moving_sphere</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//带参构造，比sphere类要多吃四个参数，分别是两个时间值，以及这两个时间下对应的球心位置。</span></span><br><span class="line">        <span class="built_in">moving_sphere</span>(</span><br><span class="line">            point3 cen0, point3 cen1, <span class="keyword">double</span> _time0, <span class="keyword">double</span> _time1, <span class="keyword">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">            : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(_time0), <span class="built_in">time1</span>(_time1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m)</span><br><span class="line">        &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//多出来的函数，这个函数用来返回当前时间下球心位置。</span></span><br><span class="line">        <span class="function">point3 <span class="title">center</span><span class="params">(<span class="keyword">double</span> time)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//两个时间下的球心位置。</span></span><br><span class="line">        point3 center0, center1;</span><br><span class="line">    	<span class="comment">//两个时间值</span></span><br><span class="line">        <span class="keyword">double</span> time0, time1;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过插值得到球心位置</span></span><br><span class="line"><span class="function">point3 <span class="title">moving_sphere::center</span><span class="params">(<span class="keyword">double</span> time)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0))*(center1 - center0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>center函数的参数time不一定非要处于time0和time1之间，它也可以小于time0或者大于time1。从另一个角度来说，time0,time1和其对应的球心位置center0,center1并不是球运动的边界，而是用于确定球运动方向和速度的参数。</p>
<p>总结来说，<strong>这颗球沿着空间中的某条直线做匀速运动，它在time0时刻处于直线上的center0位置，time1时间下处于center1位置</strong>。</p>
<p>接下来补完moving_sphere类，它还差一个hit函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">moving_sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入光线r的发射时间r.time()到center函数里，移动的球会根据这个值调整球心坐标。</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">//同理，法线的计算中的center也得更换成插值计算版本。</span></span><br><span class="line">    <span class="keyword">auto</span> outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="材质类对应修改"><a href="#材质类对应修改" class="headerlink" title="材质类对应修改"></a>材质类对应修改</h4><p>每次递归都会产生新的光线，得确保时间信息可以传递到新光线上，修改材质类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">//把time信息传递给出射光线。</span></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           ...</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">			...</span><br><span class="line">            <span class="comment">//把time信息传递给出射光线。</span></span><br><span class="line">        	scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz*<span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ...</span></span></span><br><span class="line"><span class="params"><span class="function">        	<span class="comment">//把time信息传递给出射光线。</span></span></span></span><br><span class="line"><span class="params"><span class="function">            scattered = ray(rec.p, direction, r_in.time());</span></span></span><br><span class="line"><span class="params"><span class="function">			...</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="修改初篇最终场景"><a href="#修改初篇最终场景" class="headerlink" title="修改初篇最终场景"></a>修改初篇最终场景</h4><p>我们尝试把初篇最终场景中的所有漫反射小球都替换成移动的球，并且让他们移动的方向都为y轴正方向，为了做出差异性，让所有的小球移动的速度都不同，我们要利用随机数给定不同的参数。</p>
<p>假设相机镜头在 time0=0 时刻打开镜头，time1=1 时刻关闭镜头，且time0时刻这些移动的球正好都在y = 0.2 平面上（这也是我们以前最终场景中的设计），也就是说center0.y() 是 0.2 ，那么center1就可以根据center0加上一个随机长度的y轴正方向向量得到，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;moving_sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">        	...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>() * color::<span class="built_in">random</span>();</span><br><span class="line">                    sphere_material = make_shared&lt;lambertian&gt;(albedo);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// center2表示1.0时刻球心位置。</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>,<span class="number">.5</span>), <span class="number">0</span>);</span><br><span class="line">                    </span><br><span class="line">                 	<span class="comment">// 创建moving_sphere时，比sphere多传入四个参数。</span></span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;moving_sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                 	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再修改相机和图片参数，为了不等待太久，适当降低了分辨率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// change</span></span><br><span class="line">    <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="comment">// ↓↓↓</span></span><br><span class="line">    <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// ↓↓↓</span></span><br><span class="line">    <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//相机传入的两个时间值和刚刚移动的球中的值保持一致，方便同步修改。</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>会得到：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645624221803-0845eb43-30f2-4979-af3f-9a2fbcc47c79.png" alt="img"></p>
<p>虽然这些移动的球的运动轨迹是“直破云霄”往天上去的，但是看起来就好像是球在平台上弹跳一样。这是因为无论是向下运动还是向上运动，动态模糊看上去都是一个样子的。</p>
<p><em>以下内容为个人探索（需要先完成初篇第十六章）。</em></p>
<h4 id="配置ffmpeg"><a href="#配置ffmpeg" class="headerlink" title="配置ffmpeg*"></a>配置ffmpeg*</h4><p>现在来休息一下，暂停对技术的探索，一起来做一些工程方向的趣事。让我们来生成一系列的图片，并且把它串成视频。你不想看到自己的小球真的动起来吗？如果答案为肯定，那就来继续探索时空光线追踪的极限吧。</p>
<p>图片按序列帧转视频这件差事如果要靠代码完成可得费一番功夫，幸好伟大的前辈们早就写好了统一解决方案——ffmpeg！一个伟大的开源程序！它可以用来记录、转换数字音频、视频，并能将其转化为流，总之，它在音视频方面几乎无所不精无所不能。</p>
<p>但本篇并不是ffmpeg的教程贴，而且为了整体项目的精简，把ffmpeg接入光追项目暂时来看是没有必要。我们仅仅只利用ffmpeg作为外部工具生成视频，或者更准确来说，仅仅只用到一个命令。</p>
<p>一：先需要下载ffmpeg，直接点击该链接进行下载：<a href="https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z。">https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z。</a></p>
<p>如果上方链接失效，可以通过以下方法：</p>
<ol>
<li>先上官网：<a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></li>
<li>因为我是windows系统，就按下图所示进入链接（其他系统下的ffmpeg安装远比windows下安装简单，具体请自行搜索）：</li>
</ol>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645675175268-5f43f54c-c63d-485c-a244-f818a3609980.png" alt="img"></p>
<p>进入之后，第一行就是最新的git分支的压缩包，俩个分别是只包含基础功能的以及全部功能的压缩包，随便选一个，因为我还使用ffmpeg做其他项目，所以安装的是full版本，但是应对本项目，essential应该就足够了。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645675230186-6e1197a5-b134-4811-b51f-55b241bcf4cf.png" alt="img"></p>
<p>你会下载到和刚刚我给你的链接里一样的安装包。</p>
<p>二：把下载的压缩包解压到某个目录，我将其解压到了D:\ffmpeg文件夹下。</p>
<p>三：配置环境变量。我的电脑右键属性-高级系统设置-环境变量-再编辑path-新建一个path为ffmpeg目录下的bin文件夹。（本部分我简单描述，环境变量配置为程序员必修课，如果不会的话去看教程，这里贴一个百度经验教程<a href="https://jingyan.baidu.com/article/a17d5285c9b0c48099c8f26a.html），配置完成你的path应该会大概如下多出一行：">https://jingyan.baidu.com/article/a17d5285c9b0c48099c8f26a.html），配置完成你的path应该会大概如下多出一行：</a></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645675931404-73c58218-d114-4986-ae81-d68544470348.png" alt="img"></p>
<p>四：配置完毕之后就可以通过命令行测试是否配置成功，在任意目录下输入ffmpeg -version，如果出现版本信息，即表示配置成功：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645676037568-b712f67a-c7ee-4e67-89f6-fef762f22dae.png" alt="img"></p>
<h4 id="多线程输出序列帧"><a href="#多线程输出序列帧" class="headerlink" title="多线程输出序列帧*"></a>多线程输出序列帧*</h4><p>切换代码为多线程模式，修改多线程的main所在文件如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MULTITHREAD</span></span><br><span class="line"><span class="comment">//我们需要用到c语言中的部分内存操作函数，比如sprintf，在C++标准中它们被认为是危险和禁忌的。</span></span><br><span class="line"><span class="comment">//使用这个宏即可解禁这些函数，你亦可将其写入预处理器命令中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;moving_sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整为16/9，和本章中动态模糊示例代码保持一致。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line"><span class="comment">// ↓↓↓，因为要输出多张图片，我们让其尽可能的快。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 让center2尽可能的高，我打算让球高高的飞起！</span></span><br><span class="line">         <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">50</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 时间依然不变，卡在1个单位时间内运行完毕。</span></span><br><span class="line">         world.<span class="built_in">add</span>(make_shared&lt;moving_sphere&gt;(</span><br><span class="line">            center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">        ...       </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 视频一共有多少帧。</span></span><br><span class="line">    <span class="keyword">int</span> video_frame_num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 把这些序列帧存放在指定目录下，方便查看和编辑。</span></span><br><span class="line">    std::string video_folder_path = <span class="string">&quot;video&quot;</span>;</span><br><span class="line"></span><br><span class="line">    world = <span class="built_in">random_scene</span>();</span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C的新建文件夹的多种方式之一，这种通过system命令新建文件夹的方式不需要多余的头文件包含，很方便。</span></span><br><span class="line">    std::string command;</span><br><span class="line">    <span class="comment">// mkdir命令就是命令行中新建文件夹的命令，后跟新文件夹目录</span></span><br><span class="line">    command = <span class="string">&quot;mkdir &quot;</span> + video_folder_path;</span><br><span class="line">    <span class="comment">// 会在当前目录上创建video文件夹。</span></span><br><span class="line">    <span class="comment">// system只接受c风格字符串，所以要用c_str转换一下。</span></span><br><span class="line">    <span class="built_in">system</span>(command.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 具体文件名。</span></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">50</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环创建多帧。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; video_frame_num; i++) &#123;</span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;LineIndex:&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sprintf和c语言中人尽皆知的printf几乎没有什么不同。</span></span><br><span class="line">        <span class="comment">// 唯一的区别是它要把字符串输出给一个char数组而不是标准输出流。</span></span><br><span class="line">        <span class="comment">// 图片名需要规律排列，ffmpeg会从编号为0的图片开始串帧成视频。</span></span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;./%s/videoframe%04d.ppm&quot;</span>, video_folder_path.<span class="built_in">c_str</span>(), i);</span><br><span class="line"></span><br><span class="line">        buf = <span class="keyword">new</span> <span class="built_in">imageoutput</span>(image_width, image_height, filename);</span><br><span class="line">        std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本帧图片的时间区间，随后讲解。</span></span><br><span class="line">        cam = <span class="keyword">new</span> <span class="built_in">camera</span>(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="built_in">pow</span>(i / (<span class="keyword">float</span>)video_frame_num, <span class="number">5</span>), <span class="built_in">pow</span>((i + <span class="number">1</span>) / (<span class="keyword">float</span>)video_frame_num, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numThread; k++) &#123;</span><br><span class="line">            threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(ray_tracing_by_thread, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">            thread.<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (thread_remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining : &quot;</span> &lt;&lt; line_remain - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意初始化这些进程监视相关变量。</span></span><br><span class="line">        line_remain = image_height;</span><br><span class="line">        thread_remain = numThread;</span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">        buf-&gt;<span class="built_in">buffer_2_file</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> cam;</span><br><span class="line">        <span class="keyword">delete</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>移动的球类是一些匀速运动的小球，但这个匀速运动也是有条件的，那就是时间流速是匀速不变的。</p>
<p>我们将均匀增加的自变量i（每次循环加一），套进<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/97e5bb87482db93b9ec3dd2fbc98644f.svg" alt="img">函数，并将其映射到(0,1)区间内（和移动的球在创建之初指定的时间区间保持同步），即可实现球速逐渐加快效果，因为<img src="https://cdn.nlark.com/yuque/__latex/97e5bb87482db93b9ec3dd2fbc98644f.svg" alt="img">在此区间为凹函数。可以简单理解为，套用该函数之后，时间流速不再均匀，而是会逐渐加快。</p>
<p>运行代码，如果你是在命令行中运行exe文件，就可以在exe所在目录下找到video文件夹。如果是vs内运行生成，这个文件夹会在代码所在目录下。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645681526261-f9be0d88-488b-4080-b899-dd6b3989ea12.png" alt="img"></p>
<h4 id="ffmpeg命令生成视频"><a href="#ffmpeg命令生成视频" class="headerlink" title="ffmpeg命令生成视频*"></a>ffmpeg命令生成视频*</h4><p>打开命令行，走到video目录，然后输入以下命令：</p>
<p>ffmpeg -r 10 -i videoframe%04d.ppm -q:v 1 output.avi</p>
<p>如图所示：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645686428622-3622a2f2-f39d-412d-8d7c-8ab3a2f72b15.png" alt="img"></p>
<p>我们分开看看这个命令讲了什么：</p>
<p>ffmpeg 表示运行的exe的名字，系统会在环境变量里面的那些目录去找叫这个名字的exe，显然，它要找的就是ffmpeg/bin文件夹下的那个exe。</p>
<p>-r 10 表示我们要以一秒10帧的速度安排这些图片，最后生成的图片每秒钟会有十张图片播放。</p>
<p>-i videoframe%04d.ppm 表示图片输入，ffmpeg会找指定格式化输入的%d从0开始，这样它就可以找到目录下全部的10张图片。</p>
<p>-q:v 1 表示我们希望最后生成的图像质量高一些，但可惜的是，即使是这样它还是会失去一些清晰度。</p>
<p>output.avi 输出文件目录，没有前缀的话它就会存放在和图片同样的目录里。</p>
<p>在一阵提示输出之后，你会得到视频：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645683030692-8da75e3d-8468-494d-9b54-409a80570f58.gif" alt="img"></p>
<p>它的时长是1秒。我们做到了三个时间统一：移动的球类指定时间，相机区间和最终生成图片时间区间。</p>
<p>时间统一有很多好处，它可以让时间轴一目了然。</p>
<p>当然它们三个也可以不完全统一，而是某种映射关系，这取决于你的设计。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>可以尝试通过修改代码，达到以下效果：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645684273328-b44becb3-6771-4ea0-9a8a-cbec55a731ad.gif" alt="nxr3w-nkpff.gif"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1645851897575-a9747188-c28b-4fd7-82a4-b08f457451b5.gif" alt="i1khw-t25yk.gif"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第2.2节到第2.5节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十六：时空光追</title>
    <url>/2022/06/05/%E5%85%89%E8%BF%BD16/</url>
    <content><![CDATA[<h4 id="曝光时间"><a href="#曝光时间" class="headerlink" title="曝光时间"></a>曝光时间</h4><p>初篇的最后我们一直在和相机较劲，一个拥有景深（散焦模糊）的相机也并不是我们相机进化的终点，在本篇的开始，我们将让相机进化为完全形态。这将是本系列最后一次改动相机类，在本篇之后，相机类将不会再有任何改动——当然，你自己可以对其进行一些个性化改动或者添加你认为需要的功能，但是对于我们介绍的所有功能中，相机将进化为完全体。</p>
<p>真实的相机，有一个概念叫做曝光时间：它表示镜头打开的时间，在这段时间内射到相机的光线都会被相机捕捉。</p>
<p>但是我们当前的相机，曝光时间是趋于无穷小的，也就意味着，<strong>任何高速移动的物体，在相机镜头打开的这一瞬间里，移动的距离都为0</strong>。</p>
<p>依照我们在散焦模糊那一章的处理思路，我们得自断一臂，通过某些方式让我们的相机产生缺陷去迎合真实的相机。</p>
<p>要怎么模拟曝光时间这一概念呢？按照逆光路模型，我们得让光线在一段时间内先后从相机射出，而不是一瞬间。按照曝光时间的长短，让某一个像素中射出的若干采样光线在此曝光时间内的随机时刻射出，并带回信息即可。</p>
<p>要想实现这一点，需要先改动光线类，让光线和时间挂钩。</p>
<p>请不要把这个时间和我们光线公式中 P( t ) = A + tb 的 t 弄混，这个 t 表示这一根光线在发射之后过了多少时间，并不涉及到光源发射的时间。</p>
<p>看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">// 更改构造函数，tm的缺省默认值为0。</span></span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction, <span class="keyword">double</span> time = <span class="number">0.0</span>)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">        <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//tm的getter函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">time</span><span class="params">()</span> <span class="keyword">const</span>    </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t*dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 光线发射时刻。</span></span><br><span class="line">        <span class="keyword">double</span> tm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>光线现在有发射时间的概念了，接下来修改发射光线的相机类，让相机能发射有不同tm值的光线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">            point3 lookfrom,</span><br><span class="line">            point3 lookat,</span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="keyword">double</span> vfov, </span><br><span class="line">            <span class="keyword">double</span> aspect_ratio,</span><br><span class="line">            <span class="keyword">double</span> aperture,</span><br><span class="line">            <span class="keyword">double</span> focus_dist,</span><br><span class="line">            <span class="comment">//相机快门打开时间。</span></span><br><span class="line">            <span class="keyword">double</span> _time0 = <span class="number">0</span>,</span><br><span class="line">			<span class="comment">//相机快门关闭时间，开关差值既是曝光时间。</span></span><br><span class="line">            <span class="keyword">double</span> _time1 = <span class="number">0</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">            u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">            v = <span class="built_in">cross</span>(w, u);</span><br><span class="line"></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">            horizontal = focus_dist * viewport_width * u;</span><br><span class="line">            vertical = focus_dist * viewport_height * v;</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - focus_dist*w;</span><br><span class="line"></span><br><span class="line">            lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//开关时间初始化</span></span><br><span class="line">            time0 = _time0;</span><br><span class="line">            time1 = _time1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">            vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">                origin + offset,</span><br><span class="line">                lower_left_corner + s*horizontal + t*vertical - origin - offset,</span><br><span class="line">                <span class="comment">//光线的tm值给一个time0和time1中的随机值。</span></span><br><span class="line">                <span class="built_in">random_double</span>(time0, time1)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">        vec3 u, v, w;</span><br><span class="line">        <span class="keyword">double</span> lens_radius;</span><br><span class="line">    	<span class="comment">//快门开关时间。</span></span><br><span class="line">        <span class="keyword">double</span> time0, time1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们拥有了一个能在曝光时间内随机发射光线的相机！你可能会觉得这根本不算什么，就是给光线类多加了一个成员变量罢了，但这对我们的渲染器来说是跨时代的一步。我们的光追器不再仅仅只是描绘光线在空间上的碰撞，而且开始描绘时间上的交错变化。这叫做<strong>时空光线追踪</strong>（SpaceTime Ray Tracing）。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>参考自《Ray Tracing: The Next Week》第1节和第2.1节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十五：多线程加速</title>
    <url>/2022/04/02/%E5%85%89%E8%BF%BD1.15/</url>
    <content><![CDATA[<p><em>本章内容为个人探索。</em></p>
<p>在《抗锯齿》那一章中，增加了多次采样的逻辑后，程序的运行速度开始变得非常缓慢。多次采样是渲染真实感图像的基石，想要保持多次采样的同时加快程序的运行速度，就得另辟蹊径。</p>
<h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>在计算机中我们常听到进程与线程，<strong>进程</strong>是资源（CPU、内存等）分配的基本单位，通俗来说就是我们桌面上的每一个应用当点击QQ时，就创建了一个进程，我们所用的VS本地调式也是一个进程。<strong>线程</strong>是一条执行路径，是程序执行时的最小单位，他们之间的关系就好比一个部门和其中的每一个人，当然人越多干活越快，需要的总工资（内存和cpu资源）也越多。一个线程的使用示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="built_in">func</span>(par1, par2)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接构造thread对象t，第一个参数为函数，后面依次传入对应函数所需参数</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func, par1, par2...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//detach表示彻底放养t线程，这是一个危险的行为，如果不能保证主线程在t线程之后走完</span></span><br><span class="line"><span class="comment">//就会导致t线程的资源无法回收。</span></span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//join t线程到本线程，在join完后表示接下来的代码必须等待t执行完成之后才开始执行。</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="建立输出管理类"><a href="#建立输出管理类" class="headerlink" title="建立输出管理类"></a>建立输出管理类</h4><p>单线程代码中，渲染循环是由主线程独自运行完成的。建立多个线程平摊渲染循环中繁杂重复的任务是很容易想到的多线程加速方案。</p>
<p><strong>可以建立N个线程，让它们同时从不同行开始绘制。</strong>因为最终的ppm文件是有严格的顺序要求，每个线程绘制的像素都不可能都把画好的像素立即的输出到文件里，这里可以在内存上开一个缓冲区用来暂时存放结果，每个线程绘制好的像素先填入其中，等所有线程都绘制完成的时候，再将数组中的内容输出。</p>
<p>对于这部分缓冲区的管理，和最终输出到ppm文件的操作，我们可以封装到一个类里，创建imageoutput.h文件，敲入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IMAGEOUTPUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGEOUTPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色的值最高只到255，只需要8bit存储，使用int类型太过浪费。</span></span><br><span class="line"><span class="comment">// 我们给unsigned char这个8bit类型重命名，用它来当缓冲区类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> D_BYTE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">imageoutput</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，通过文件名直接输出。</span></span><br><span class="line">    <span class="built_in">imageoutput</span>(<span class="keyword">int</span> wth, <span class="keyword">int</span> hgt, <span class="keyword">const</span> <span class="keyword">char</span>* file_nm) :<span class="built_in">width</span>(wth), <span class="built_in">height</span>(hgt) &#123;</span><br><span class="line">        <span class="comment">// 分配一块大小为width * height * 3的区域用于存取像素的rgb。</span></span><br><span class="line">        buffer = <span class="keyword">new</span> D_BYTE[width * height * <span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 建立输出文件流。</span></span><br><span class="line">        outFile = std::<span class="built_in">ofstream</span>(file_nm);</span><br><span class="line">        <span class="comment">// ppm文件的开头要加上这句话。</span></span><br><span class="line">        outFile &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数，释放缓冲区。为保证安全性，需要确认它不为空。</span></span><br><span class="line">    ~<span class="built_in">imageoutput</span>() &#123;</span><br><span class="line">         <span class="keyword">if</span> (buffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填写颜色到数组中，需要传入像素的位置，以及rgb值。这里做了之前color类做的一些事情。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_buffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y, <span class="keyword">const</span> <span class="keyword">double</span> red, <span class="keyword">const</span> <span class="keyword">double</span> green, <span class="keyword">const</span> <span class="keyword">double</span> blue)</span> </span>&#123;</span><br><span class="line">        D_BYTE ir = <span class="built_in">D_BYTE</span>(<span class="number">255.999</span> * <span class="built_in">clamp</span>(red, <span class="number">0</span>, <span class="number">0.999</span>));</span><br><span class="line">        D_BYTE ig = <span class="built_in">D_BYTE</span>(<span class="number">255.999</span> * <span class="built_in">clamp</span>(green, <span class="number">0</span>, <span class="number">0.999</span>));</span><br><span class="line">        D_BYTE ib = <span class="built_in">D_BYTE</span>(<span class="number">255.999</span> * <span class="built_in">clamp</span>(blue, <span class="number">0</span>, <span class="number">0.999</span>));</span><br><span class="line">        <span class="comment">// 二维坐标转一维数组坐标，然后依次填入rgb。</span></span><br><span class="line">        <span class="keyword">int</span> n = (y * width + x) * <span class="number">3</span>;</span><br><span class="line">        buffer[n] = ir;</span><br><span class="line">        buffer[n + <span class="number">1</span>] = ig;</span><br><span class="line">        buffer[n + <span class="number">2</span>] = ib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数把整个缓冲区内的数据写入文件。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buffer_to_file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (height - <span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = (j * width + i) * <span class="number">3</span>;</span><br><span class="line">                outFile &lt;&lt; (<span class="keyword">int</span>)buffer[n] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="keyword">int</span>)buffer[n + <span class="number">1</span>] </span><br><span class="line">                    &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="keyword">int</span>)buffer[n + <span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    D_BYTE* buffer;</span><br><span class="line">    std::ofstream outFile;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="平摊渲染循环任务"><a href="#平摊渲染循环任务" class="headerlink" title="平摊渲染循环任务"></a>平摊渲染循环任务</h4><p>输出管理类提供了写缓冲区和最终生成图片的函数，接下来的任务就很明确了：创建线程们调用write_buffer函数写缓冲区，再在main函数的最后，把缓冲区写成文件。</p>
<p>为了拆分渲染循环，我们把它从main中抽离，并且把与之相关的一些变量都改为全局变量，方便多线程共享调用。</p>
<p>以下代码会重构main函数所在文件，为保留之前的代码，建议新建RayTracingByMultithread.cpp文件作为新的main文件，老代码记得保存，新代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imageoutput.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread相关，我们可以先设置为50个线程</span></span><br><span class="line"><span class="keyword">int</span> numThread = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//定义一个输出设置</span></span><br><span class="line">imageoutput* buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相机与场景</span></span><br><span class="line">hittable_list world;</span><br><span class="line">camera* cam;</span><br><span class="line"></span><br><span class="line"><span class="comment">//着色函数，直接复制。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//最终场景，直接复制。</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把渲染循环切分成numThread份，分配给每个线程执行。</span></span><br><span class="line"><span class="comment">//这是分配第k个线程的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ray_tracing_by_thread</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height - k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= numThread) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; i++) &#123;</span><br><span class="line">            <span class="function">color <span class="title">tmp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; s++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam-&gt;<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                tmp += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp /= <span class="built_in"><span class="keyword">float</span></span>(samples_per_pixel);</span><br><span class="line">            <span class="comment">//将颜色gamma矫正，存入缓冲区</span></span><br><span class="line">   			buf-&gt;<span class="built_in">write_buffer</span>(i, j, <span class="built_in">sqrt</span>(tmp[<span class="number">0</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">1</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 摆放场景</span></span><br><span class="line">    world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化缓冲区和输出文件流，并给图片命名。</span></span><br><span class="line">    buf = <span class="keyword">new</span> <span class="built_in">imageoutput</span>(image_width, image_height,<span class="string">&quot;image.ppm&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 线程列表</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 放置相机</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line">    cam = <span class="keyword">new</span> <span class="built_in">camera</span>(lookfrom, lookat, <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程下的renderloop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numThread; k++) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(ray_tracing_by_thread, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="comment">//阻塞主线程，必须等待所有线程执行完毕，再会执行后续的代码。</span></span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲区已经填充完毕，输出成文件。</span></span><br><span class="line">    buf-&gt;<span class="built_in">buffer_2_file</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放堆上内存。</span></span><br><span class="line">    <span class="keyword">delete</span> cam;</span><br><span class="line">    <span class="keyword">delete</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然选择使用文件流的方式创建文件，那么也不需要使用命令窗口了，可以直接点击vs中的本地调试以生成文件，紧接着就可以在代码所在目录下找到image.ppm文件了。</p>
<p>如果还是采用命令行的方式生成（不使用重定向符号，命令行中直接运行exe），image.ppm文件会生成在exe文件同目录下。</p>
<p>如果本次生成感到卡顿，可以降低线程数量，但总体来说，生成文件的速度肯定比单线程要快上好几倍。</p>
<h4 id="进度提示"><a href="#进度提示" class="headerlink" title="进度提示"></a>进度提示</h4><p>最后一步，加上进度提示。</p>
<p>先在每个线程里对共享的记录变量进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//剩余行数</span></span><br><span class="line"><span class="keyword">int</span> line_remain = image_height;</span><br><span class="line"><span class="comment">//剩余多少线程没完成任务</span></span><br><span class="line"><span class="keyword">int</span> thread_remain = numThread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ray_tracing_by_thread</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height - k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= numThread) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; i++) &#123;</span><br><span class="line">           ...</span><br><span class="line">            buf-&gt;<span class="built_in">write_buffer</span>(i, j, <span class="built_in">sqrt</span>(tmp[<span class="number">0</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">1</span>]), <span class="built_in">sqrt</span>(tmp[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行到这说明有一行像素存缓冲区完毕。</span></span><br><span class="line">        --line_remain;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到这说明有一个线程执行完毕。</span></span><br><span class="line">    --thread_remain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在main函数里进行记录，这次把线程改成detach于主线程。因为主线程可以通过thread_remain来判断线程们的运行情况，就不必担心主线程会先结束了，并且还可以利用主线程的等待时间进行进度的显示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    cam = <span class="keyword">new</span> <span class="built_in">camera</span>(lookfrom, lookat, <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程下的renderloop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numThread; k++) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(ray_tracing_by_thread, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="comment">//detach单独使用是非常危险的，但后续的while循环会卡住主线程，让线程结束顺序变得可控。</span></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (thread_remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// line_remain-1是为了最后能让显示数字归零，工整好看。</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; line_remain<span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">    buf-&gt;<span class="built_in">buffer_2_file</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cam;</span><br><span class="line">    <span class="keyword">delete</span> buf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样控制台就会有进度提示了。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644760612951-6f06140b-95a2-44f0-bd93-ae060937d22d.png" alt="img"></p>
<p>数字刷新速度开始很慢，这说明在程序运行的一开始，main函数中的while循环争取到cpu的频率不高，cpu大多被副线程们占据，最后会随着副线程们一个个全都完成，主线程能争取到的cpu时间会变多，刷新速度变得顺畅。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>注意到line_remain和thread_remain变量在同时被多个线程访问中所产生的问题吗？如果有那么一个时刻，有两个线程同时拿取了line_remain的值——假设是53，他们同时对其进行—操作，然后相继写回了它们各自认为的正确的值——52，实际上这个值是错误的，有两个线程在同一时刻完成了图片中的某行的渲染，这个值理应减到51。</p>
<p>对变量加同步锁，可以完美的解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行到这的线程都会尝试给some_mutex加上属于它们自己的锁。</span></span><br><span class="line"><span class="comment">//但是如果这时候锁已经有主人了，这个请求就会失败，申请的线程会被阻塞，直到锁被持有者释放。</span></span><br><span class="line">some_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥代码</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//锁的持有者释放了这个锁！现在其他线程们可以来抢夺这枚锁了！</span></span><br><span class="line">some_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<p>锁的本质是创造一个只有一个线程可以独享的区域，上述代码中，some_mutex是个同步信号量，对其实行lock()操作意味有某个线程想要占有这枚锁，之后所有想要拥有这枚锁的线程，都必须要等待本线程释放掉它。</p>
<p>在lock和unlock之间的代码，在同一时间里，至多只有一个线程执行。这样就避免了同时写变量，导致变量值出错的问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">//信号量</span></span><br><span class="line">std::mutex line_remain_mutex;</span><br><span class="line">std::mutex thread_remain_mutex;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = image_height - k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= numThread) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; i++) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        line_remain_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        --line_remain;</span><br><span class="line">        line_remain_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    thread_remain_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    --thread_remain;</span><br><span class="line">    thread_remain_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<h4 id="用宏控制要执行的代码块"><a href="#用宏控制要执行的代码块" class="headerlink" title="用宏控制要执行的代码块"></a>用宏控制要执行的代码块</h4><p>因为之后依然是在单线程模式的基础上进行编写的，有时候需要切回单线程模式，来回黏贴代码很麻烦，可以使用如下方式自由的在两种模式之间切换，首先，确保项目目录下有第十五章结束时候的main函数所在文件和本章新创建的文件。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644765772450-258fabf2-16b2-4f31-833b-4cade26bc58a.png" alt="img"></p>
<p>在老文件RayTracing.cpp（当然你的可能不叫这个名字）中加入如下宏，<strong>包裹所有的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !MULTITHREAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在新文件中使用同样的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MULTITHREAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来尝试添加一下预编译命令，此处展示vs中更改预编译命令的方法：</p>
<p>注意，一定要保证修改的配置页是当前的代码环境，比如下图中修改的是“活动(Release)”-“活动(Win32)”平台，如果你的代码是Debug平台或者是x64，此更改并不会生效。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766071978-e908b653-500a-4b87-82e3-a9ab94cf4a54.png" alt="img"></p>
<p>添加MULTITHREAD命令，本程序便会进入多线程模式：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766120244-c255d9d5-445b-40b9-a73d-24345c04dee8.png" alt="img"></p>
<p>添加完成后，显示如下：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766148415-4d46e8c8-b22d-45fb-a2df-c6010d4a258d.png" alt="img"></p>
<p>在MULTITHREAD的宏定义成功后，老文件中的代码应该全显示为灰色。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644766227253-9d89c9bf-50c5-4a67-b84b-2454a519801f.png" alt="img"></p>
<p>如果想使用单线程，就再次编辑上述预处理器文本，删除MULTITHREAD命令即可。</p>
<p>其他编辑器有各自的预处理命令的添加方式，或者你可以通过新建一个.h文件作为配置文件，再把<code>#define MULTITHREAD 1or0</code>输入到配置文件中，来定义并使用宏。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>丧尸围城-框架</title>
    <url>/2022/04/02/%E5%83%B5%E5%B0%B8%E5%9B%B4%E5%9F%8E-%E7%AE%A1%E7%90%86%E8%80%85/</url>
    <content><![CDATA[<p>以前做的项目，复习一下以前写的框架，<em>注：</em>只针对代码讲解。</p>
<h4 id="数据管理者"><a href="#数据管理者" class="headerlink" title="数据管理者"></a>数据管理者</h4><p>因为在游戏中我希望能将游戏的数据储存，或者在外部配置一些数据应用到游戏中，所以用到了json的数据存贮，这里我们直接基于Litjson开源项目来完成这个管理者类。其功能主要便是把数据序列化后储存到本地和将本地数据反序列化应用于游戏中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using LitJson;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.IO;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">// 序列化和反序列化Json时  使用的是哪种方案</span><br><span class="line">public enum JsonType</span><br><span class="line">&#123;</span><br><span class="line">    JsonUtlity,</span><br><span class="line">    LitJson,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Json数据管理类 主要用于进行Json的序列化存储到硬盘和反序列化从硬盘中读取到内存中</span><br><span class="line">public class JsonMgr</span><br><span class="line">&#123;</span><br><span class="line">    //单例模式，简单说就是将此脚本的代码暴露出去，供其他所有脚本使用，通常用在管理者脚本上</span><br><span class="line">    private static JsonMgr instance = new JsonMgr();</span><br><span class="line">    public static JsonMgr Instance =&gt; instance;</span><br><span class="line"></span><br><span class="line">    private JsonMgr() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    //存储Json数据 序列化</span><br><span class="line">    public void SaveData(object data, string fileName, JsonType type = JsonType.LitJson)</span><br><span class="line">    &#123;</span><br><span class="line">        //确定存储路径</span><br><span class="line">        string path = Application.persistentDataPath + &quot;/&quot; + fileName + &quot;.json&quot;;</span><br><span class="line">        //序列化 得到Json字符串</span><br><span class="line">        string jsonStr = &quot;&quot;;</span><br><span class="line">        switch (type)</span><br><span class="line">        &#123;</span><br><span class="line">            case JsonType.JsonUtlity:</span><br><span class="line">                jsonStr = JsonUtility.ToJson(data);</span><br><span class="line">                break;</span><br><span class="line">            case JsonType.LitJson:</span><br><span class="line">                jsonStr = JsonMapper.ToJson(data);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        //把序列化的Json字符串 存储到指定路径的文件中</span><br><span class="line">        File.WriteAllText(path, jsonStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取指定文件中的 Json数据 反序列化</span><br><span class="line">    public T LoadData&lt;T&gt;(string fileName, JsonType type = JsonType.LitJson) where T : new()</span><br><span class="line">    &#123;</span><br><span class="line">        //确定从哪个路径读取</span><br><span class="line">        //首先先判断 默认数据文件夹中是否有我们想要的数据 如果有 就从中获取</span><br><span class="line">        string path = Application.streamingAssetsPath + &quot;/&quot; + fileName + &quot;.json&quot;;</span><br><span class="line">        //先判断 是否存在这个文件</span><br><span class="line">        //如果不存在默认文件 就从 读写文件夹中去寻找</span><br><span class="line">        if(!File.Exists(path))</span><br><span class="line">            path = Application.persistentDataPath + &quot;/&quot; + fileName + &quot;.json&quot;;</span><br><span class="line">        //如果读写文件夹中都还没有 那就返回一个默认对象</span><br><span class="line">        if (!File.Exists(path))</span><br><span class="line">            return new T();</span><br><span class="line"></span><br><span class="line">        //进行反序列化</span><br><span class="line">        string jsonStr = File.ReadAllText(path);</span><br><span class="line">        //数据对象</span><br><span class="line">        T data = default(T);</span><br><span class="line">        switch (type)</span><br><span class="line">        &#123;</span><br><span class="line">            case JsonType.JsonUtlity:</span><br><span class="line">                data = JsonUtility.FromJson&lt;T&gt;(jsonStr);</span><br><span class="line">                break;</span><br><span class="line">            case JsonType.LitJson:</span><br><span class="line">                data = JsonMapper.ToObject&lt;T&gt;(jsonStr);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把对象返回出去</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UI管理者类"><a href="#UI管理者类" class="headerlink" title="UI管理者类"></a>UI管理者类</h4><p>我们需要一个管理者类来控制和管理我们所有面板的显示以及隐藏，因为我们需要管理不同的面板，所以需要使用模板，此时我们制作面板基类的好处就是，可以通过它来统一管理所有面板，也符合面向对象设计原则。来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class UIManager </span><br><span class="line">&#123;</span><br><span class="line">    //单例模式</span><br><span class="line">    private static UIManager instance = new UIManager();</span><br><span class="line"></span><br><span class="line">    public static UIManager Instance &#123; get =&gt; instance; set =&gt; instance = value; &#125;</span><br><span class="line"></span><br><span class="line">    //用与显示的面板，每显示一个面板就将其加入字典中，以便于调用</span><br><span class="line">    private Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;();</span><br><span class="line"></span><br><span class="line">    //得到自身的Transform，</span><br><span class="line">    private Transform canvasTrans;</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    private UIManager()</span><br><span class="line">    &#123;</span><br><span class="line">        //创建canvas空白画布</span><br><span class="line">        GameObject canvas = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;UI/Canvas&quot;));</span><br><span class="line">        //把画布位置保存下来</span><br><span class="line">        canvasTrans = canvas.transform;</span><br><span class="line">		</span><br><span class="line">        //防止场景加载的时候被销毁</span><br><span class="line">        GameObject.DontDestroyOnLoad(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //传入想调用的面板，来将它显示</span><br><span class="line">    public T showPanel&lt;T&gt;(bool isFade = true) where T:BasePanel</span><br><span class="line">    &#123;</span><br><span class="line">        //type(T)获取该对象，并取得其名字</span><br><span class="line">        string panelName = typeof(T).Name;</span><br><span class="line"></span><br><span class="line">        //查看字典中有无该面板，如果有表明已经显示，直接return该面板，注意此处要将BasePanel重新转换为子类类型</span><br><span class="line">        if (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            return panelDic[panelName] as T;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //显示面板 根据面板名字 动态创建预制体 设置父对象</span><br><span class="line">        GameObject panelObj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(&quot;UI/&quot; + panelName));</span><br><span class="line">        panelObj.transform.SetParent(canvasTrans, false);</span><br><span class="line"></span><br><span class="line">        //指向面板上 显示逻辑  并且把它保存起来</span><br><span class="line">        T panel = panelObj.GetComponent&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">        //把这个面板脚本 存储在字典中方便之后的获取和隐藏；</span><br><span class="line">        panelDic.Add(panelName, panel);</span><br><span class="line"></span><br><span class="line">        panel.ShowMe(isFade);</span><br><span class="line"></span><br><span class="line">        return panel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	//隐藏面板</span><br><span class="line">    public void HidePanel&lt;T&gt;(bool isFade = true) where T:BasePanel</span><br><span class="line">    &#123;</span><br><span class="line">        //根据泛型取得名字</span><br><span class="line">        string panelName = typeof(T).Name;</span><br><span class="line"></span><br><span class="line">        //如果存在，调用其基类的HideMe函数，并传入lambda让其释放内存并在字典中删除</span><br><span class="line">        if (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            if (isFade)</span><br><span class="line">            &#123;</span><br><span class="line">                panelDic[panelName].HideMe(() =&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                    //删除对象</span><br><span class="line">                    GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line">                    //删除字典里面储存 面板脚本</span><br><span class="line">                    panelDic.Remove(panelName);</span><br><span class="line">               &#125;); </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //删除对象</span><br><span class="line">                GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line">                //删除字典里面储存 面板脚本</span><br><span class="line">                panelDic.Remove(panelName); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //得到面板</span><br><span class="line">    public T GetPanel&lt;T&gt;() where T:BasePanel</span><br><span class="line">    &#123;</span><br><span class="line">        string panelName = typeof(T).Name;</span><br><span class="line">        if (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            return panelDic[panelName] as T;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个脚本，我们就可以非常方便的调出和删除面板，所有的UI控制我们都可以使用此脚本来实现。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>十四：散焦模糊</title>
    <url>/2022/03/28/%E5%85%89%E8%BF%BD1.14/</url>
    <content><![CDATA[<h4 id="传统相机的局限"><a href="#传统相机的局限" class="headerlink" title="传统相机的局限"></a>传统相机的局限</h4><p>现实中的相机可无法把它获取的所有光线都汇聚到一点，通过逆光路模型来解释，就是它无法精准的控制发射光线的起点都重合在一起。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643969907150-aefe4446-4da2-4de0-9bd2-fe176e670885.png" alt="img"></p>
<p>如上图所示，inside表示相机内部，outside是相机的外部。</p>
<p>相机通过镜头采集光线，镜头采集到的光线会被汇总，在镜头后的胶片上成像。在镜头之外，根据镜头凹透镜的焦距，在某个距离处采集到的光线都来自于一点，这个平面上的所有物体都处于完美对焦状态，而其他距离下的物体，都会因为光线无法精准落于一点而出现模糊。离完美对焦距离越远，就越模糊。</p>
<h2 id="模拟散焦模糊"><a href="#模拟散焦模糊" class="headerlink" title="模拟散焦模糊"></a>模拟散焦模糊</h2><p>在《抗锯齿》那一章我们编写的多采样求平均的算法就可以完美模拟从镜头采集到成像的过程，现在，只需要改变我们光线的发射位置，假装光线是从镜头上任意一点发射的即可。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643970443347-3db9b25c-c319-4f16-92fe-841fa915af9c.png" alt="img"></p>
<p>具体要怎么做呢？</p>
<p><strong>1.要如何模拟镜头呢？</strong></p>
<p>我们可以以原来的固定光线发射点为圆心，找一个圆片，这个圆片和虚拟视口所在平面平行，和相机正对方向垂直。然后在这个圆片上随机找一个点，以这个点为起点发射光线（这个圆片就是虚拟相机的镜头）。这个圆片的大小对应着真实相机中的镜头光圈大小，圆片越大，散焦模糊效果就越大。</p>
<p><strong>2.要如何模拟光线聚焦效果呢？</strong></p>
<p>光线是射向虚拟视口上的虚拟像素内的。在我们原来的设计里，虚拟视口和相机位置的距离始终为1，这意味着，我们的光线都会在镜头前方距离为1的平面上聚焦，如果我们需要让他能在任意位置聚焦，我们只需要改变虚拟视口距离相机的距离即可。</p>
<p>还记得是如何在代码中规定虚拟视口的位置的吗？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - w;</span><br></pre></td></tr></table></figure>
<p>如果我想把它推到和相机位置距离为2的平面上，仅仅是修改w的系数就可以了吗？比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="number">2</span>*w;</span><br></pre></td></tr></table></figure>
<p>这样就足够了吗？不行，看下图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643973076508-497c8957-39b9-46c8-8202-5b3052917235.png" alt="img"></p>
<p>图上描绘的是相机空间下VoW面上的截面，假设中间的绿色竖线就是原先的虚拟视口，它离相机的距离为1，现在要把它移动到右边的蓝色平面上，根据相似三角形，如果它离相机的距离改成2，那它的高度会同步扩大为2，且因为像素数量没变，每个虚拟像素的大小也会增加为2。<strong>这意味着horizontal和vertical也得同步进行放大。</strong></p>
<p>图中射向虚拟视口的光线假设命中了第x行，如果像素的大小扩大两倍，这根光线的延长线也会命中蓝色视口的第x行。如果像素没有放大，它将命中第2x行，这就不对了。</p>
<p>更改相机代码，现在我们可以传入焦距和光圈大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">            point3 lookfrom,</span><br><span class="line">            point3 lookat,</span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="keyword">double</span> vfov,</span><br><span class="line">            <span class="keyword">double</span> aspect_ratio,</span><br><span class="line">            <span class="comment">//光圈直径</span></span><br><span class="line">            <span class="keyword">double</span> aperture,</span><br><span class="line">            <span class="comment">//焦距</span></span><br><span class="line">            <span class="keyword">double</span> focus_dist</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">            u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">            v = <span class="built_in">cross</span>(w, u);</span><br><span class="line"></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//我们要把虚拟视口推到离相机位置有focus_dist的距离的平面上。</span></span><br><span class="line">            <span class="comment">//原本的距离是1，距离变成原来的focus_dist倍。</span></span><br><span class="line">            <span class="comment">//所以，horizontal和vertical得同步乘以focus_dist倍。</span></span><br><span class="line">            horizontal = focus_dist * viewport_width * u;</span><br><span class="line">            vertical = focus_dist * viewport_height * v;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//距离不再是w，而是focus_dist*w。</span></span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - focus_dist*w;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//处理一下，拿到半径。</span></span><br><span class="line">            lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 生成一个偏移值。</span></span><br><span class="line">            <span class="comment">// 这个random_in_unit_disk()函数会产生一个XoY平面上的以原点为圆心的单位圆片内随机一点。</span></span><br><span class="line">            <span class="comment">// 该函数之后给出。</span></span><br><span class="line">            vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">            <span class="comment">// 把圆片从XoY平面，调整到uv平面上。</span></span><br><span class="line">            vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">                <span class="comment">// 顶点加上偏移。</span></span><br><span class="line">                origin + offset,</span><br><span class="line">                <span class="comment">// -offset使得光线还是朝虚拟视口上的当前像素上发射的。</span></span><br><span class="line">                lower_left_corner + s*horizontal + t*vertical - origin - offset</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">        vec3 u, v, w;</span><br><span class="line">        <span class="keyword">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把random_in_unit_disk函数写在vec3.h类的类外，这个函数负责生成一个XoY面上以原点为圆心的圆片内的随机一点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XoY面上以原点为圆心的圆片内的随机一点。</span></span><br><span class="line"><span class="function">vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>,<span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>,<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是使用上一章的场景，但要调整相机，给一个很大的光圈直径，并且把对焦平面（虚拟视口）放在画面正中心的小球上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom-lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    会得到这张图，这里的光圈很大，只要物体离虚拟视口有一点距离，就看不清了。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643976783038-8526d1b9-95c6-4cef-b5fc-413bf73fd84b.png" alt="img"></p>
<h4 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h4><p>现在来汇总在第一章中学到的所有知识，绘制一张图片，这将会是集大成之作，写入代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数帮助生成一个丰富多彩的场景！！！</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    <span class="comment">//先来一个“地板”，它比我们之前创建过最大的球还要大十倍！！！</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这个循环里我们将生成数个小球！！！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//先进行一次随机采样，这次采样用来决定本轮循环生成的小球的材质！！！</span></span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="comment">//在一个y=0.2这个平面上的一块方形区域里随机找一个点，作为这颗小球的球心！！！</span></span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*random_double())</span></span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//我们腾出一个位置，让生成的这些小球离(4, 0.2, 0)这个点远一点！！！</span></span><br><span class="line">            <span class="comment">//因为这里我们要放置一个非常明显的大球，如果出现球与球重合就会影响美观了！！！</span></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//定义一个智能指针，但先别急着决定指向什么类型的材质对象！！！</span></span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line">				</span><br><span class="line">          </span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;<span class="comment">//我们的材质有百分之八十的概率会是磨砂材质。</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>() * color::<span class="built_in">random</span>();</span><br><span class="line">                    sphere_material = make_shared&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;<span class="comment">//我们的材质有百分之十五的概率会是金属材质。</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = make_shared&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//我们的材质有百分之五的概率会是玻璃材质。</span></span><br><span class="line">                    sphere_material = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三颗站在C位的大球！！！</span></span><br><span class="line">    <span class="keyword">auto</span> material1 = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = make_shared&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整图片参数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//分辨率调高点，玩票大的！！！</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="comment">//拉高采样率会增加最终艺术品的成色！！！</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用函数生成一个有着许多随机小球的场景！！！</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置相机</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="comment">//这次是小光圈。</span></span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// renderloop</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1644241403158-330630b4-149f-456e-9abd-a749828948f6.png" alt="image.png"></p>
<p>可以给你的随机数生成器其他的种子，来改变小球的随机位置，直到你得到满意的结果。</p>
<p>到此为止，这本书的内容就结束喽！但这个渲染器并没有完成，接下来的内容在《Ray Tracing: The Next Week》中。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li><p>非常明显，高分辨率多个物体的图片是非常耗费时间的，想想如何充分利用CPU来给我们的程序提提速。</p>
<p>答案见下章。</p>
</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第12节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十三：自由相机</title>
    <url>/2022/03/25/%E5%85%89%E8%BF%BD1.13/</url>
    <content><![CDATA[<h2 id="球为什么会被拉长"><a href="#球为什么会被拉长" class="headerlink" title="球为什么会被拉长"></a>球为什么会被拉长</h2><p>在以前的图片中可以发现越靠近边缘位置越会被拉伸的厉害，现在我来尝试解释一下这个问题：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313131416140.png" alt="image-20220313131416140"></p>
<p>上图是y = 0的情况下，场景的 XoZ面截面。O为相机位置，也是发射光线的原点，横线为Z = -1 位置上的虚拟视口，在空间中有三个大小一样的球，三个球的球心都在y = 0平面上，中间的那颗球处在虚拟视口的正中心，即它的位置是(0,0,-1)。现在开始往虚拟视口上发射光线，来看看每颗球x轴上的宽度是多大。</p>
<p>可以清楚的看到，A点虽然在虚拟视口上来看，和球还是有点距离，但是往A点发射光线来确定这一点的颜色的时候，发现它正好处于球的边界上，即在最终渲染的2D图片上，AB才是这颗球与x轴平行的直径，它显然比2D图片上处于中间的球的直径BD要长的多。</p>
<p>那如何对抗图片边缘变形问题呢？有两个解决方法：让虚拟视口变得非常小，或者让虚拟视口离相机位置足够远。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313131438632.png" alt="image-20220313131438632">如图所示，把虚拟视口缩小，这样图中的三个球在最终显示的图片上来看就不会有非常明显的长度不一的问题了。因为视口变小，视口中的像素数量不变，所以每个像素在三维空间中的大小也变小了，所以图片的最终质量并不会有任何改变。</p>
<h2 id="可调节视野"><a href="#可调节视野" class="headerlink" title="可调节视野"></a>可调节视野</h2><p>虚拟视口的长宽比不应该被限制，同时虚拟视口的高度也不应该恒定为2，假设有一个物体在我们的面前但是高度很高，比如它在(0,10,-1)的位置，它不会被相机捕捉到，我们得赋予它自由度，让它想看多高看多高。</p>
<p>对于方形的照片，在真实的摄影技术中，有一个数据叫视场(field of view)，简写为fov，一般使用的是竖直fov，它表示相机处到视野最高处和视野最低处连线的夹角，如果是水平fov的话就是相机处和视野中最左最右处连线的夹角。如果知道长宽比的话，竖直和水平的fov就可以进行简单换算。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313132406568.png" alt="image-20220313132406568"></p>
<p>如图所示，θ就是fov，我们就使用指定fov的方式来让视口高度变得可自定义。</p>
<p>还有一点纯属个人设计风格：传入角度值，再由类内转为弧度制进行后续计算。修改camera.h中的camera类代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(<span class="keyword">double</span> vfov <span class="comment">/*竖直fov（vertical field of view）*/</span> </span><br><span class="line">               ,<span class="keyword">double</span> aspect_ratio <span class="comment">/*长宽比，把它暴露出去使之可自定义*/</span> ) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">//角度转弧度制，我们好久之前写的工具函数。</span></span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//虚拟视口还是放在z = -1的地方。</span></span><br><span class="line">            <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过换算得到上图中的h。</span></span><br><span class="line">            <span class="keyword">auto</span> h = focal_length * <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这样虚拟视口就一步一步由fov换算得来了。</span></span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">            origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在来测试一下，在main函数中更换场景，并用新的构造函数创建相机：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定视场大小</span></span><br><span class="line">    <span class="keyword">double</span> vfov = <span class="number">10.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改物体信息。</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> material_up = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_bottom = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们想创造两个球心在边界上的球。</span></span><br><span class="line">    <span class="keyword">auto</span> R = <span class="built_in">tan</span>(<span class="built_in">degrees_to_radians</span>(vfov) / <span class="number">2</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, R, <span class="number">-1</span>), R, material_up));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, -R, <span class="number">-1</span>), R, material_bottom));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个vfov是10度的相机，并且传入我们之前定义在main中长宽比。</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(vfov, aspect_ratio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>会得到两个图片边缘的球，它们没有再被明显的拉长了，因为fov = 10° 的情况下，虚拟视口的大小比原来小得多（之前我们的高度h恒定为2的情况，fov按照反向换算应该为90°）。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313132539787.png" alt="image-20220313132539787"></p>
<h2 id="完全自由的相机"><a href="#完全自由的相机" class="headerlink" title="完全自由的相机"></a>完全自由的相机</h2><p>在视野大小和长宽比可以调整之后，相机身上的五个枷锁中的后两个已经解开，现在还有三个固定死的桎梏。接下来只要让相机的位置和朝向可以自由选定，就可以让相机彻底解放。</p>
<p>另外，虚拟视口大小可以通过fov自由控制之后，我们就没有必要再改变虚拟视口离相机的远近了，这不会给场景带来更多新的变化。可以缩小虚拟视口，实际上和把虚拟视口拉远得到的效果是完全一样的，所以固定死这个距离，假设这个距离恒定为1。</p>
<p>我们需要自由指定相机的位置，也就是说我们要暴露出一个point3(vec3的别名)变量来表示位置，这很容易想到。</p>
<p>那要如何指定相机看向的方向呢？有两个策略，给一个方向向量或者给定一个点表示看向的目标点，这样就可以通过和相机位置的连线得到同样方向向量，这里选择后者。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313132829324.png" alt="image-20220313132829324"></p>
<p>相机放在lookfrom点上，看的目标点是lookat。</p>
<p>fov也已经有了，现在能开始构建相机了吗？不能，还有一个东西我们没法确定。想想看，你站在某个地方，望着桌子上的苹果，苹果一定会处在你视角的正中心，但是，我无法确定你有没有以你的鼻子为中心左右旋转你的头——在lookfrom所在的面和lookat-lookfrom向量垂直的向量有无数多条，我们不知道，相机的“头顶”是哪个方向。</p>
<p>这个问题，业界比较青睐的解决方案是确定一个vup（view up）方向，一般来说，只要不歪头，这个vup的值都是(0,1,0)，即y轴正方向。但是搞不好就有一些特殊的要求，比如说，从墙角伸出一杆狙击枪，我们需要歪头去看瞄准镜，这时候，瞄准镜内的世界就是歪斜的，vup就会指向斜上方。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313133058687.png" alt="image-20220313133058687"></p>
<p>看上左图，lookfrom、lookat和vup向量唯一确定了一个相机。</p>
<p>左图中的uv两个坐标轴，也就是我们的老相机里面的horizontal和vertical向量。</p>
<p>老相机是朝-z方向看的，而新的相机是朝-w（上右图中的向量）方向看的。右图中w,v和vup三个向量在同一个面上。最终相机代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">            <span class="comment">// 相机位置。</span></span><br><span class="line">            point3 lookfrom,</span><br><span class="line">			<span class="comment">// 相机看向的目标点。</span></span><br><span class="line">            point3 lookat,</span><br><span class="line">            <span class="comment">// 相机正上方方向向量（通常为(0,1,0)）。</span></span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="comment">// 视场大小。</span></span><br><span class="line">            <span class="keyword">double</span> vfov,</span><br><span class="line">            <span class="comment">// 长宽比。</span></span><br><span class="line">            <span class="keyword">double</span> aspect_ratio</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// w向量是从lookat指向lookfrom的向量。</span></span><br><span class="line">            <span class="keyword">auto</span> w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// u向量与vup和w都垂直，我们可以直接叉乘得到它。</span></span><br><span class="line">            <span class="comment">// 叉乘注意两个变量的前后顺序，注意叉乘结果向量的方向满足右手定则。</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">            <span class="comment">// v向量与w及u向量都垂直，叉乘得到。</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">cross</span>(w, u);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 赋值原点。</span></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">			<span class="comment">// horizontal方向不再是(1,0,0)，而是u。</span></span><br><span class="line">            horizontal = viewport_width * u;</span><br><span class="line">            <span class="comment">// vertical方向不再是(0,1,0)，而是v。</span></span><br><span class="line">            vertical = viewport_height * v;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 虚拟视口左下角的坐标位置，原本减去vec3(0, 0, focal_length)的位置改成了w。</span></span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + s*horizontal + t*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚拟视口离相机的距离由w决定，它是个单位向量，永远是1。我们不需要动他，改变fov能达到相同的效果。</p>
<p>在main函数中改变场景物体和相机参数，来测试一下这个自由的相机。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left   = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right  = make_shared&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>( <span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>( <span class="number">0.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_center));</span><br><span class="line"><span class="comment">//空心玻璃球不要紧贴其他物体，否则会产生黑点。</span></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.001</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.001</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.45</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>( <span class="number">1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">1</span>), point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="number">90</span>, aspect_ratio)</span></span>;</span><br></pre></td></tr></table></figure>
<p>相机原点放在(-2,2,1)上，这离场景中的这些球很远，所以我们会得到：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643953627319-650ae52a-effb-42d8-a5ea-d407c56fdbe9.png" alt="image.png"></p>
<p>fov为90的情况下，虚拟视口的高度为2，球处在我们图片的正中心，但很小.</p>
<p>如果想得到近景，只需要把fov改小，比如改成20，就可以得到清晰的细节，就好像使用了望远镜一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">1</span>), point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="number">20</span>, aspect_ratio)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1643953583323-2fbaf10f-719c-4d89-a1b7-2c746b02719c.png" alt="image.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第11节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十二：玻璃</title>
    <url>/2022/03/21/%E5%85%89%E8%BF%BD1.12/</url>
    <content><![CDATA[<h4 id="斯涅尔定律"><a href="#斯涅尔定律" class="headerlink" title="斯涅尔定律"></a>斯涅尔定律</h4><p>折射光线会遵循以下的法则进行折射，这个定律叫折射定律，或者是斯涅尔定律（Snell’s law）：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311084827719.png" alt="image-20220311084827719"></p>
<p>公式中，<em>θ</em> 和 <em>θ′</em> 是入射光线和折射光线和法线的夹角，η 和 η′ 则是折射率，它表示入射光线所在的介质和折射光线所在的介质的一种性质，是光在真空中的传播速度与光在该介质中的传播速度之比（空气的折射率为1.00029，近似为1，玻璃是1.3-1.7，钻石则是2.4），如下图所示：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311084845727.png" alt="image-20220311084845727"></p>
<h4 id="折射方向向量"><a href="#折射方向向量" class="headerlink" title="折射方向向量"></a>折射方向向量</h4><p>已知入射向量为R，如何求折射后向量R’呢？直接求是非常困难的，我们对它做一个分解，把目标向量分解到法线和与法线垂直方向这两个互相垂直的方向上，有</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/cf310eaeaee8d5ab0d8eccce3dd0ae79.svg" alt="img"></p>
<p>先求R’，它是R’中与法线方向垂直的分量。我们清楚的知道它的模是sinθ′​ ，但我们得找到一个和法线方向垂直的向量x(上图中指向正右方)作为它的向量表示，即最终的结果就是sinθ′ * unit_vector(x)。</p>
<p>我们可以从入射角那里找到一个这样的向量 x=R+cosθn，它是一个和同$R’⊥​向，并且模为sinθ的向量，我们要的向量的模是sinθ′ ，不过没关系，再利用斯涅尔定律转换一下就可以了，解析式如下：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/460fe563abab2e132078781a81476ded.svg" alt="img"></p>
<p>到这一步还不够，我们已知的东西是入射向量和法线向量，θ不应该出现在最终的解析式里。因为R和法线向量n都是单位向量，我们可以用一个点乘去消灭这个碍事的cosθ，即：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/a6424b57028276075f706a39b052c960.svg" alt="img"></p>
<p>知道R’⊥之后，R’∥可以通过一个简单的公式推算得到。首先，是和R’∥和n同向的，它的长度是cosθ′ ，通过三角函数中最基础的公式：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/59a26492b77262b3fc8a47499b49dbbf.svg" alt="img"></p>
<p>我们就可以得到如下最终解析式：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/f2d9195a8023333c2e868c9720e098c9.svg" alt="img"></p>
<p>一切都准备妥当了，在vec3.h中创建一个类外函数，来描述折射这一过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//折射函数，吃单位化的入射和法线向量以及两种介质折射率的比值，吐折射方向向量。</span></span><br><span class="line"><span class="function">vec3 <span class="title">refract</span><span class="params">(<span class="keyword">const</span> vec3&amp; uv<span class="comment">/*入射向量*/</span>, <span class="keyword">const</span> vec3&amp; n<span class="comment">/*法线*/</span>, <span class="keyword">double</span> etai_over_etat<span class="comment">/*η和η′的比值*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = <span class="built_in">dot</span>(-uv, n);</span><br><span class="line">    <span class="comment">//垂直于法线的分量</span></span><br><span class="line">    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);</span><br><span class="line">    <span class="comment">//平行于法线的分量</span></span><br><span class="line">    vec3 r_out_parallel = -<span class="built_in">sqrt</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span> - r_out_perp.<span class="built_in">length_squared</span>())) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_perp + r_out_parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总是折射的玻璃"><a href="#总是折射的玻璃" class="headerlink" title="总是折射的玻璃"></a>总是折射的玻璃</h4><p>有了折射函数，就先写一个总是折射的透明材质，看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">dielectric</span>(<span class="keyword">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//理论上的透明玻璃不会引起能量的损耗。</span></span><br><span class="line">            attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//曾经记录过的看碰撞面是否是物体外面的bool变量&gt;</span></span><br><span class="line">            <span class="comment">//我们使用这个变量来控制物体射入和射出此材质时候η和η′分子分母调换。</span></span><br><span class="line">            <span class="keyword">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span>/ir) : ir;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//单位化入射方向。</span></span><br><span class="line">            vec3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">            <span class="comment">//调用折射函数。</span></span><br><span class="line">            vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line">			<span class="comment">//制造光线。</span></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ir; <span class="comment">// 这种透明材质的折射率。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数中看一下什么样吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = make_shared &lt;metal&gt; (<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>),<span class="number">0.3</span>);</span><br><span class="line"><span class="comment">//玻璃的折射率在1.3-1.7之间。</span></span><br><span class="line"><span class="keyword">auto</span> material_right = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311092348533.png" alt="image-20220311092348533"></p>
<h4 id="全内反射"><a href="#全内反射" class="headerlink" title="全内反射"></a>全内反射</h4><p>上面的结果是不正确的，如果认真观察斯涅尔定律你会发现，这个公式是有失效的时候的。</p>
<p>光线从较高折射率的介质进入到较低折射率的介质时，如果入射角大于某一临界角θc（光线远离法线）时，折射光线将会消失，所有的入射光线将被反射而不进入低折射率的介质，这种现象叫做全内反射，或称全反射。</p>
<p>拿玻璃举例子，对于光线从玻璃中射入空气的情况，带入</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/83e6114c771f29b4d7c5113b0e859a61.svg" alt="img"></p>
<p>得到：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/06a7e04a12b30a33dcc3fe5433877f05.svg" alt="img"></p>
<p>对于如上的公式，当sinθ大于某特定角度时，sinθ′会大于1，但是sin函数是永远不会大于1的，也就是说，对于这样的角度来说，上述公式会失效。</p>
<p>也就是说，代码得甄别这样的情况，在这种情况下，我们得让光线反射而不是折射。也就是说会有如下的结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> cos_theta = <span class="built_in">dot</span>(-unit_direction, rec.normal);</span><br><span class="line"><span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 折射</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 反射</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么只能能折射就折射的代码时是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">dielectric</span>(<span class="keyword">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span>/ir) : ir;</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">            <span class="keyword">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//是否达到全反射的临界值。</span></span><br><span class="line">            <span class="keyword">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">            vec3 direction;</span><br><span class="line">            <span class="keyword">if</span> (cannot_refract)</span><br><span class="line">                <span class="comment">//全反射</span></span><br><span class="line">                direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//折射</span></span><br><span class="line">                direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ir;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="施利克近似"><a href="#施利克近似" class="headerlink" title="施利克近似"></a>施利克近似</h4><p>一个正确的透明材质会反射部分光线的，入射光线和面的夹角越大，它就越倾向于反射光线。这也就是为什么我们越从掠射角去观察窗户，我们越难看清窗外的景色，而越容易从其上看到自己的脸的原因。</p>
<p>入射光线和法线的夹角和反射率之间的关系是有一个巨大且丑陋的等式所决定的，几乎所有的人都会使用克里斯托弗·施利克（Christophe Schlick）的简单且令人惊讶的精确多项式去近似这个等式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">dielectric</span>(<span class="keyword">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span>/ir) : ir;</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//为了防止因为失误传入了非单位向量导致cosθ大于1，进而导致下面根号内有负值使程序崩溃，我们加一层保险。</span></span><br><span class="line">            <span class="keyword">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">            vec3 direction;</span><br><span class="line">            <span class="comment">//如果全反射了，或者反射概率通过了随机数测试。</span></span><br><span class="line">            <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">                <span class="comment">//反射</span></span><br><span class="line">                direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//折射</span></span><br><span class="line">                direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ir; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">reflectance</span><span class="params">(<span class="keyword">double</span> cosine, <span class="keyword">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用施利克近似来计算反射概率。</span></span><br><span class="line">            <span class="keyword">auto</span> r0 = (<span class="number">1</span>-ref_idx) / (<span class="number">1</span>+ref_idx);</span><br><span class="line">            r0 = r0*r0;</span><br><span class="line">            <span class="keyword">return</span> r0 + (<span class="number">1</span>-r0)*<span class="built_in">pow</span>((<span class="number">1</span> - cosine),<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>施利克近似到底为何物，它到底是如何影响光线选择反射或折射的，先写下它的具体公式：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/a58bf13043ff567c9946ddb9318caba2.svg" alt="img"></p>
<p>最终概率落于0到1之间。</p>
<p>公式中只有两个变量：1.两种物质的折射率之比，即<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/008eda5e41e717ed92a93922f5ea2285.svg" alt="img">     2.夹角的余弦值cosθ。</p>
<p>它们是怎么影响结果的呢？首先，显而易见的是，θ越小，cosθ越大，反射的概率就越小。也就是说，<strong>反射率随着入射光线和法线的夹角增大而增大</strong>，这是符合规律的。</p>
<p>其次， 一个容易发现的规律——我们用<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/a107ef0beaad8f76a0ec774dfcfd7391.svg" alt="img">去代替公式中的<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/008eda5e41e717ed92a93922f5ea2285.svg" alt="img">，最终结果不会有变化，也就是说，<strong>对于特定的两种介质，无论哪个是入射光线所在的介质，反射率都遵循一样的规律</strong>。</p>
<p>还有一个规律，那就是如果<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/008eda5e41e717ed92a93922f5ea2285.svg" alt="img">越靠近1，最终解析式中的第二项就越大。即，<strong>对于折射率越接近的两种介质，反射概率受θ的影响就越剧烈，反之，θ对于最终反射概率的影响就越小</strong>。</p>
<p>最后一个规律，<strong>对于折射率差距巨大的两种介质</strong>，<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/2b05cd73b712830589e5a333cf66684b.svg" alt="img">接近1，第二项接近0，<strong>光线极度倾向于反射，罕有折射</strong>。</p>
<p>在我们的代码中，reflectance(cos_theta, refraction_ratio) 越大，则它越容易大于random_double()，即越容易反射，这是一个经典的利用已知概率和随机数配合进行随机采样的例子。你会得到：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311092852355.png" alt="image-20220311092852355"></p>
<p>看起来不太像我们见到的玻璃，这是有多种原因决定的：</p>
<ol>
<li><p>场景过于简单，在现实世界中，不可能处于这样的场景中，也就不存在对于这种环境下的玻璃材质的视觉直觉。</p>
</li>
<li><p>广角相机，与我们看到的不同，它把远离视角中心的一切物体都拉变形了。</p>
</li>
</ol>
<h4 id="空心玻璃"><a href="#空心玻璃" class="headerlink" title="空心玻璃"></a>空心玻璃</h4><p>我们还实现一个空心的玻璃，不需要新的材质，空心玻璃的实现远比你想象的要简单。只需在玻璃球的同样位置放一个稍微小一点的，半径为负值的球即可。半径为负值代表着球的外表面的法线指向球心。通过已经实现的功能，做一个简单的改变就实现了一个玻璃球内“空气泡泡”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"><span class="comment">// 负半径的玻璃球，作为空心球的内胆。</span></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.4</span>, material_right));</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311093223889.png" alt="image-20220311093223889"></p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1.空心玻璃球得到的太过简单梦幻，请推导实现原理。</p>
<p>推导后发现，负半径使得这句代码<code>vec3 outward_normal = (rec.p - center) / radius;</code>得到的法线是向内的，之后经过<code>rec.set_face_normal(r, outward_normal);</code>函数后因为入射光与法线相反，rec结构体认为光线撞到了物体内部，于是把front_face设置为false，虽然依然得到了向外的法线，但是却为之后的材质判断埋下伏笔。</p>
<p>在材质判断中，是由<code>double refraction_ratio = rec.front_face ? (1.0 / ir) : ir;</code>这句代码判断内外的材质，而front_face为负也导致折射率之比为原来的倒数，则恰好构成由空气进入玻璃的情况。到这里不禁想问作者一句：”这也在你的掌握之中吗？“。</p>
<p>2.注意到空心玻璃球左侧有一个小黑点，是如何来的呢？</p>
<p>我认为这主要是由于光线打到这个点上由于入射角很大而容易发生镜面反射，所以金属球上，而金属也会反射光线并吸收一部分能量，最后在多次弹射中耗尽了能量而呈现为黑色。可以看到在拉远它们之间的距离后就没有黑点了</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220313131152062.png" alt="image-20220313131152062"></p>
<ol>
<li>事实上，玻璃也不可能完全透明，也就是说，光线碰撞到玻璃材质物体时，会即反射又折射，想想如何实现该材质。</li>
<li>了解光栅化中如何实现玻璃材质</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第10节。</p>
<p><a href="https://en.wikipedia.org/wiki/Refraction">https://en.wikipedia.org/wiki/Refraction</a></p>
<p>维基百科中对于折射相关的光学知识。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十一：金属</title>
    <url>/2022/03/16/%E5%85%89%E8%BF%BD1.11/</url>
    <content><![CDATA[<h4 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h4><p>一个顺滑的金属的表面并不会随机反射射来的光线，而是会镜面反射光线。在现实中很难看到完美的金属，但金属的物质有一个基本的视觉直觉，那就是镜面反射可以制造物体的金属感。</p>
<p>要如何生成镜面反射的光线呢，在已知入射光线方向和法线方向之后，一个简单的向量运算即可得到反射光线方向。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311082447549.png" alt="image-20220311082447549">如图是一个平面，光线从上方射到平面上，法线方向朝上，红色的向量即是我们要求的向量。我们可以把入射向量的起点放到碰撞点，这样不难看出向量之间的关系：<strong>V</strong>+ 2<strong>B</strong> 即是反射光线方向。B可以看作是V在N上的投影的逆向量，又N在我们的设计中是单位向量，我们可以在vec3.h中加入如下类外函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">reflect</span><span class="params">(<span class="keyword">const</span> vec3&amp; v, <span class="keyword">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 即 V - 2 *|B|* N</span></span><br><span class="line">    <span class="keyword">return</span> v - <span class="number">2</span>*<span class="built_in">dot</span>(v,n)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="金属类"><a href="#金属类" class="headerlink" title="金属类"></a>金属类</h4><p>在material.h中添加金属类，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">metal</span>(<span class="keyword">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;。</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">//通过reflect函数生成反射方向，对v的单位化保证了最终生成的方向向量也是单位向量。</span></span><br><span class="line">            vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">            <span class="comment">//从碰撞点射出反射光线。</span></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="comment">//或许会有用处的保险。但是对于我们的球来说，反射光线和N的夹角不会大于90°。</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在世界中，我们就可以放一个金属球了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line"><span class="keyword">auto</span> material_right = make_shared&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>));</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311082857687.png" alt="image-20220311082857687"></p>
<h4 id="亚光金属"><a href="#亚光金属" class="headerlink" title="亚光金属"></a>亚光金属</h4><p>在现实世界中很多情况下无法从金属平面上看到自己清晰的脸的原因是金属会哑光，现代社会中为了防止光污染，很多金属表面都会做哑光处理。</p>
<p>哑光实际上就是把金属表面做成凹凸不平，一定程度上削弱镜面反射把所有光线都反射到同一个方向的讨厌特性，有效避免光污染。</p>
<p>在技术实现的角度上，我们可以通过对镜面反射的最终结果加上一个随机的向量来使光线变得更加混乱，从而模拟哑光的效果。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311082950838.png" alt="image-20220311082950838"></p>
<p>这里使用之前的球面随机向量生成函数，来对最后的结果进行扰动。反映到最终的代码里，有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 增加一个变量f表示扰动的幅度，对成员变量fuzz进行参数列表赋值的时候，限制扰动程度的上限。</span></span><br><span class="line">        <span class="built_in">metal</span>(<span class="keyword">const</span> color&amp; a, <span class="keyword">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">            <span class="comment">// 对最终的反射光线加上一个球面随机向量，至于这个球的大小，由fuzz决定，它最大可以是1。</span></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz*<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">    	<span class="comment">// 扰动幅度</span></span><br><span class="line">        <span class="keyword">double</span> fuzz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样在世界中加入它，看看效果吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> material_left = make_shared&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>), <span class="number">0.3</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = make_shared&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.2</span>), <span class="number">0.4</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311083217092.png" alt="image-20220311083217092"></p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li><p>某些金属艺术品的表面是凹凸不平的鳞片状，这种形状的金属表面光线弹射的法则同样遵循镜面反射原则，但表面的法线会依据某种周期性进行变换，这样的金属材质，构造的时候除了颜色，哑光程度之外，还能改变鳞片的大小。<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220311125157869.png" alt="image-20220311125157869"></p>
<p>代码为</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmetal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tmetal</span>(<span class="keyword">const</span> color&amp; a, <span class="keyword">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(r_in.<span class="built_in">direction</span>(), rec.normal);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="comment">//取法线的第一位小数后的部分，通过控制乘10还是乘更大的数可以控制鳞片大小</span></span><br><span class="line">        vec3 x = rec.normal * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x.<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">int</span> b = x.<span class="built_in">y</span>();</span><br><span class="line">        <span class="keyword">int</span> c = x.<span class="built_in">z</span>();</span><br><span class="line">        vec3 re = <span class="built_in">vec3</span>(x.<span class="built_in">x</span>() - a, x.<span class="built_in">y</span>() - b, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//将反射光线加上使用偏移量乘以上面得到的向量，周期为0.1（取决于前面法向量乘以的数）。</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">vec3</span>(re.<span class="built_in">x</span>(), re.<span class="built_in">y</span>(), re.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">    <span class="comment">//光线偏向法线的程度，越大越偏离镜面反射。</span></span><br><span class="line">    <span class="keyword">double</span> fuzz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>光栅化中有金属材质吗？它能够映射出其他物体吗？如果不能，游戏中的是如何实现的呢？</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第9.4节到9.6节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>十：材质类</title>
    <url>/2022/03/13/%E5%85%89%E8%BF%BD1.10/</url>
    <content><![CDATA[<p>在上一章由于急于实现功能而污染了表层文件，我们需要将它抽象出来，才能继续制作其他材质。</p>
<h4 id="抽象材质类"><a href="#抽象材质类" class="headerlink" title="抽象材质类"></a>抽象材质类</h4><p>材质类应该干什么？应该能产生反射光线，并且记录诸如光线衰减信息（上一章中的对半衰减）等，总结一句话，它得通过入射光线，得知反射光线的方向和能量大小。</p>
<p>创建material.h文件，写入”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">material</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//这个唯一的纯虚函数吃入射光线以及碰撞点信息（我们需要法线以及其他数据），吐物体颜色和反射光线。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in<span class="comment">/*in*/</span>, <span class="keyword">const</span> hit_record&amp; rec<span class="comment">/*in*/</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">            color&amp; attenuation<span class="comment">/*out*/</span>, ray&amp; scattered<span class="comment">/*out*/</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>物体颜色信息指的是物体对于各个红绿蓝三种光线的吸收率，在上一章中，一直使用的是各种光都对半吸收的参数0.5，这一章中，我们要把各个颜色分量给区分开，以创造出更绚烂的色彩变化。</p>
<p>函数的返回值是bool，留下一个标记，为了在函数出问题的时候让我们有能力进行追踪。</p>
<p>在hit_record里加入材质信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//依然使用智能指针去管理，这样如果你有多个物体像应用同一种材质，就不需要创建多个一样的材质了。</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候我们会发现，程序开始报一些莫名其妙的错误了。</p>
<p>这是因为material.h和hittable.h文件互相包含了。main函数开始链接各个文件的时候，采取的策略是见一个就包含一个，并且包含所包含文件的头文件。互相包含问题会导致我们的main函数怎么努力包含都无法包含完这些文件，所以直接摆烂了。</p>
<p>遇到这种情况怎么办呢？我们观察到，hittable.h中虽然定义了一个material的智能指针，但是，它从来没有试图访问过这个指针所指向的对象。所以完全不需要让它包含material.h文件，只需要在使用它之前声明即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &quot;material.h&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">material</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span> ... &#125;</span><br></pre></td></tr></table></figure>
<p>sphere.h文件也产生了一些变化，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">sphere</span>(point3 cen, <span class="keyword">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">            : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">    	<span class="comment">//材质是球的属性，所以它理应是球的成员变量</span></span><br><span class="line">        shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//碰撞到的话，记得把球的材质也返回出去。</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="磨砂材质"><a href="#磨砂材质" class="headerlink" title="磨砂材质"></a>磨砂材质</h4><p>我们只需要模仿main函数中已经写过一遍的代码就可以得到代码。可以把这个类直接写在material.h文件中，这种设计的方式是“<strong>一档多类</strong>”。它对于多个短小的类来说很有用，它可以防止文件数量过多带来的不便。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//只允许单参数构造，在创建磨砂材质的时候，请直接传入它的颜色。</span></span><br><span class="line">        <span class="built_in">lambertian</span>(<span class="keyword">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//覆写scatter函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 用真实兰伯特模型生随机点。</span></span><br><span class="line">            <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">            <span class="comment">// 直接对传进来的引用赋值，传出反射光线方向。</span></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">            <span class="comment">// 直接对传进来的引用赋值，把本材质的albedo传出去。</span></span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和main函数中唯一的不同就是我们可以指定材质的颜色了。</p>
<p>但作为底层代码，我们应该想到更多，比如在随机选点的时候，我们有可能会选到离碰撞点很近的点，然后进而导致生成的反射方向极度接近于<strong>0</strong>向量。</p>
<p>从代码鲁棒性的角度来看，这会导致我们在后续的某些计算中——比如球类中光线和球求焦点的代码中，除以一个和0很接近的数，这可能会导致我们最终的值变成infinities或者NaNs等等奇怪的结果（即便现在没有不代表未来不会有）。</p>
<p>所以我们要剔除零反射向量。先在vec3.h中写一个判断一个向量是否是<strong>0</strong>向量的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 判断本向量是否是0向量。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">near_zero</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果三个分量都极接近于0，则返回true，否则返回false。</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> s = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fabs</span>(e[<span class="number">0</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">1</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">2</span>]) &lt; s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改磨砂材质类，消灭零反射向量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">lambertian</span>(<span class="keyword">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果抓到零向量，直接生成一个指向法线方向的反射向量，由于概率不高，所以从简处理</span></span><br><span class="line">            <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">                scatter_direction = rec.normal;</span><br><span class="line"></span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><p>在main函数所在文件中使用磨砂材质类，除了要包含material头文件之外，还需要在main中定义数个智能指针指向新创建的材质对象，再把原本两个参数的球构造函数改成三个参数的。当然最重要的部分还是我们的光线取色函数中和材质类的交互，.cpp文件中代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个用于接收结果的容器。</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="comment">// 调用物体材质的scatter函数，传入入射光线和碰撞信息，用容器接收结果。</span></span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="comment">// 使用颜色衰减和新光线进行递归。原来这里是0.5。</span></span><br><span class="line">            <span class="comment">// 现在我们使用vec3的乘法，可以对三个通道分别指定衰减比率。</span></span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world, depth<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果scatter函数返回了false（目前看不可能），直接返回黑色。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">//定义两个智能指针指向原地构造的匿名对象。</span></span><br><span class="line">    <span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = make_shared&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="comment">//替换成三参数构造。</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>, material_ground))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以得到有颜色的磨砂材质了：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220310085318545.png" alt=""></p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li><p>材质属性可以放在hittable中吗？</p>
<p>我认为是可以的，但是这样做目前看来并没有什么好处。在没有出现其他形状的物体之前，把它放在球类中，我们可以清晰的看到该类的所有成员，是目前的最优解。</p>
</li>
<li><p>材质类与hitable可解耦吗？</p>
<p>我认为是不可以的，材质类本就不是一个很独立的模块，碰撞点信息里包含物体材质信息，而材质类依托碰撞点信息（如法线）才能计算反射方向。我们从学习代码最初就被叮嘱要进行代码解耦，但是解耦并不代表着类与类之间一定不能有半点交际。材质和物体本就是关系极为紧密的两个事物。只有有了物体，我们才会讨论物体的材质，而且没了材质，我们也就无法知晓物体的外观。把它们分成两个类，是为了能更好的实现代码复用，是为了以后有了多种物体和多种材质之后，能由我们自己随心所欲的进行“连连看”配对。 </p>
</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第9.1节到9.3节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>九：磨砂（下）</title>
    <url>/2022/03/09/%E5%85%89%E8%BF%BD1.9/</url>
    <content><![CDATA[<h4 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h4><p>看到标题，我们就知道上一章画面太暗的罪魁祸首是谁了吧，生成反射光线的起点是碰撞点，但是因为浮点数并不能精确的等于某个数，比如<code>double d = 0;</code>，实际的项目运行过程中，d不会精确等于0，而是会等于诸如-0.00000083之类的逼近0的小数。</p>
<p>浮点数精度问题会导致一部分光线的起点在球的内部，这样发射光线，光线会和球的内壁碰撞，然后在球内反复弹射，耗尽自己的一生。</p>
<p>虽然可以通过微移光线起点的方式来解决，但是这样会把问题复杂化。别忘了我们在写hit函数的时候，留有限制t的参数t_min和t_max。我们完全可以使用t_min的限制，让光线自动忽略那些和发射点很近的物体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>图片变得正常了！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309090857497.png" alt="image-20220309090857497"></p>
<h4 id="伽马矫正"><a href="#伽马矫正" class="headerlink" title="伽马矫正"></a>伽马矫正</h4><p><strong>人的眼睛并不是精准的机器，它对亮度的感知和实际能量的功率是不成线性函数关系的，而是幂函数关系，这个函数的指数通常为2.2，称为Gamma值。</strong></p>
<p>也就是说，如果光线真的是每次碰撞到物体都衰减一半的能量，那对于百分之50功率的灰色，人眼实际感受到的亮度为$\sqrt[2.2]{0.5}=0.77297$，是一种偏向于白色的淡灰色。</p>
<p>而人眼中的中灰色，实际上是功率只有<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/13a269c1c59350ec073ea90c7f4516bd.svg" alt="img">。</p>
<p>为了适应人眼去纠正光线的能量，让它符合人眼生物学中的颜色，这叫做<strong>伽马矫正</strong>。为了方便，我们并不需要那么精准，我们使用”Gamma 2”矫正，即直接对最后的颜色值开方，在write_color函数中，有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gamma矫正（Gamma = 2.0）。</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的图像看起来会更亮了，也更接近真实世界我们看到的漫反射材质</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309091636573.png" alt="image-20220309091636573"></p>
<h4 id="更真实的漫反射"><a href="#更真实的漫反射" class="headerlink" title="更真实的漫反射"></a>更真实的漫反射</h4><p>之前的随机的向量更倾向于接近法线，并不能做到完全随机，接下来介绍一种单位球表面随机选点模型——又称真实兰伯特模型（true Lambertian），它是最贴合现实世界物理规律的漫反射材质的反射方向的模型。</p>
<p>很简单，我们只需要把体积的随机改成面积的随机即可，我们在单位球的表面随机选点。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309132029289.png" alt="image-20220309132029289"></p>
<p>所以在vec3.h文件中加入全局函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unit_vector</span>(<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改ray_color函数中的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 这次改为在球面上取点。</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以得到这张图片：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309132224913.png" alt="image-20220309132224913"></p>
<h4 id="半球选点模型"><a href="#半球选点模型" class="headerlink" title="半球选点模型"></a>半球选点模型</h4><p>这一种最容易想到的模型（我脑海里也是第一时间想到这个），很多早期的光线追踪论文使用的是这样一种模型。</p>
<p>在以碰撞点P为球心的单位半球内找点，取点半球和表面法线在面的同侧。继续添加一个vec3.h的全局函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="keyword">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该向量和法线夹角为锐角，即在面的同侧，接受它，否则取反。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>) </span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时更改ray_color中的调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">point3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309092409576.png" alt="image-20220309092409576"></p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li>利用这一节的代码加工一下我们就可以制作各种各样的有趣的图片了：<ol>
<li>太极<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309204931529.png" alt="image-20220309204931529"></li>
<li>炽日<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309204955574.png" alt="image-20220309204955574"></li>
<li>蛋灯<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220309205203309.png" alt="image-20220309205203309"></li>
</ol>
</li>
<li>了解光栅化光照模型是如何实现漫反射的。</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第8.3节到8.6节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>八：磨砂（上）</title>
    <url>/2022/03/03/%E5%85%89%E8%BF%BD1.8/</url>
    <content><![CDATA[<p>之前我们一直在画一些看起来完全不真实的东西，但从现在开始我们可以来实现更加真实的物体了。</p>
<h4 id="漫反射原理"><a href="#漫反射原理" class="headerlink" title="漫反射原理"></a>漫反射原理</h4><p>例如土墙、手机壳、木制桌面等等这些表面有很多微小凹凸的材质叫做漫反射材质，它们会吸收一部分光线，并且把剩余的光线朝随机方向反射出去，因为光线被反射到了不同的方向，自然不会出现某一个方向能接收到很亮的光线，也就不会有高光点存在。它们一般会吸收特定颜色的光，比如红色的砖块，它会吸收不是红色的光线，而把红色的光线按照随机方向反弹回去。</p>
<h4 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h4><p>现在暂时还没有光源，我们不妨假设<strong>“蓝天”就是光源</strong>，光的能量都是从蓝天上来的。</p>
<p>我们再假设任何物体对各种颜色光线的吸收率都是一样的，是<strong>1：1</strong>。光线碰撞到物体后，都会吸收掉每种光的一半的能量，然后反射一半。</p>
<p>又因为我们是逆光路取色，有以下n种情况：</p>
<ol>
<li>从相机射出一根光线，这根光线没有碰到任何物体，即它射中了“蓝天”，那逆光路顺过来看看这意味着<strong>相机直接望到了蓝天，蓝天发出的光没有经过任何弹射直接进入了相机。</strong></li>
<li>从相机射出一根光线，这根光线碰到了一颗球，然后经过随机弹射之后，再也没有射中任何物体，朝无穷远处射出，即，它经过一次弹射之后射中了蓝天。逆光路顺过来看看这意味着<strong>光线从蓝天射出打到了物体上并且弹到我们的眼睛里。</strong>因为这个物体的能量吸收和反射的比率是1：1，所以这根光线只有一半的能量了。</li>
<li>我们从相机射出一根光线，这根光线碰到了一颗球，然后经过随机弹射之后，它又碰到了一颗球，逆光路顺过来看<strong>光线从蓝天射出打到了一颗球上，反射到了另外一颗球上，再反射到我们的眼睛里，没错，这根光线只剩四分之一的能量了。</strong></li>
<li>…… </li>
</ol>
<p>那么光线在空间中弹射了n-1次，它的能量只剩$\frac{1}{2^{n-1}}$。</p>
<p>从相机中射出一根光线之后，只要碰撞到物体，就从这个碰撞点朝随机方向发射一根光线，然后把这根光线取到的颜色乘以0.5并返回。</p>
<p>我们的取色函数叫<code>ray_color(const ray&amp; r, const hittable&amp; world)</code>，我们这个函数的返回值应该写什么呢？应该是<code>return 0.5 * ray_color(newRay,world)</code>，没错，这是一个递归，函数会疯狂的调用自己，直到某根随机反射光线射中了“蓝天”，再一层一层地返回。</p>
<h4 id="随机光线"><a href="#随机光线" class="headerlink" title="随机光线"></a>随机光线</h4><p>之前遗留的最后一个问题是如何随机发射一根光线呢？</p>
<p>这个问题并不像表面看上去那么简单，使用什么模型可以更加真实的模拟漫反射呢？最简单的模型是单位球体积内随机选点模型，如图：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307211216029.png" alt="image-20220307211216029"></p>
<p>碰撞点是<strong>P</strong>，法线为<strong>N</strong>（单位化），在以（<strong>P+N</strong>）这个点为球心的单位球内随机寻找一点<strong>S</strong>，然后以<strong>S</strong>减去<strong>P</strong>为光线的反射方向向量就是最终我们需要的向量。这个<strong>S</strong>点是<strong>P</strong>点坐标+<strong>N</strong>向量+一个由球心指向球内随机点的向量三部分组成。</p>
<p><strong>r</strong>向量是相机观察方向，因为我们的漫反射和视角方向无关，不用去管它。</p>
<p>在vec3文件中写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里函数都是static的，就表示它属于整个类而不属于某个特定的对象，我们可以使用上面的函数直接调用vec3类构造生成一个三个分量都在[0,1)或者[min,max)内随机的随机vec3。</p>
<p>random() 函数生成的vec3可不是在单位球内的，它的XYZ轴都是在[0,1)之间的，它是一个在<strong>单位立方体</strong>内的点或者向量，我们得做一个简单的处理，让它的随机值最终落于单位球内。</p>
<p>再在vec3.h文件中vec3的类外写一个<strong>全局</strong>函数，它只有四句代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 先来个中心在原点，边长为2的立方体内的点。</span></span><br><span class="line">        <span class="keyword">auto</span> p = vec3::<span class="built_in">random</span>(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果发现这个vec3的长度（它离原点的距离）大于1，即表示它是落于立方体内且落于球外的。</span></span><br><span class="line">        <span class="comment">// 直接让他暴力再随机一次。</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个位于单位球内的点。</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用了一个很暴力的方法：<strong>拒绝算法（rejection method）</strong>，直接让他疯狂的循环，只要点不落于单位球内，我们就让他一直随机到单位球内为止。</p>
<p>接着更新着色代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由三部分组成的S点坐标。</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创造新的光线并开启下一轮递归。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于为什么将它写在这里，有一个原则就是<strong>对于不自信的内容，先写到表层实现需求，再抽象到底层维护框架</strong>。所以这里不要在意它污染了main函数（对所有的物体都采用了漫反射）。</p>
<h4 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h4><p>到这里运行程序法线根本无法运行：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307213818888.png" alt="image-20220307213818888"></p>
<p>之前设置的递归终止条件是光线射入蓝天，但是如果光线没有射到蓝天而是一直在夹缝里不停的弹跳，就会导致系统栈溢出。为此因为引入一个光线弹射次数的上限值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果次数消耗殆尽，直接终止递归，我们的系统栈可耗不起了！</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="comment">//每一轮新的递归，我们把光线可弹射次数减一。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给定光线最大弹射次数。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line"></span><br><span class="line">        ...            </span><br><span class="line">        <span class="comment">//更改ray_color调用代码。</span></span><br><span class="line">        pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们应该可以得到一张带有漫反射材质的图了：<br><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307214423049.png" alt="image-20220307214423049"></p>
<p>非常的暗的图片，但确实可以看到漫反射的细节，如果我们只看上方小球的球顶，常识告诉我们，光线打到这里，很大概率能反弹到蓝天上，也就是说，它的颜色应该趋向于蓝天的颜色衰减了一半之后的某种蓝色。而图像并非如此。</p>
<p>另一种方法也可以佐证，用文本模式打开ppm文件，可以看到上边右图中的RGB值，它们都是很靠近黑色的值，我们的程序似乎就没生成过只弹射一次就碰到蓝天的光线，这个问题在下一章得到一个非常巧妙且完美的解决办法。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li><p>可以证明单位球体积随机选点模型的代码取到的点一定是随机的吗？</p>
<p>首先如果没有单位球的限制，在单位立方体内部的点，它们必然是均匀的，因为随机的三个标量都足够均匀。</p>
<p>现在加上单位球的限制，进行n次独立实验（n足够大），我们把这n次实验的结果按照随机几次才得出结果再分成m堆。</p>
<p>首先是最大的那一堆，这一堆中的点都是只随机一次就落在了单位球内的，有$\frac{\frac{4}{3}\prod}{8}*n$个点在这个堆里（球的体积比上立方体体积）。这些点必然均匀。因为咱们的随机点肯定均匀分布于立方体，也必然均匀分布于立方体中的球内。</p>
<p>接下来看看第二大的那个堆，这个堆里的点都是第一次随机到了球外，第二次随机到了球内的，这部分的点有$(\frac{\frac{4}{3}\prod}{8})(\frac{8-\frac{4}{3}\prod}{8})*n$个。如果只针对这一批点来说，肯定也是均匀分布于球内（因为我们采用的算法并没有改变）。</p>
<p>以此类推我们就能得出整体必然均匀的结论。</p>
</li>
<li><p>如果光线是从球内打到球的内壁上，我们代码能正确的运转吗？</p>
<p>答案见下章。</p>
</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第8.1节到8.3节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>七：抗锯齿</title>
    <url>/2022/03/01/%E5%85%89%E8%BF%BD1.7/</url>
    <content><![CDATA[<p>仔细观察前面生成的图片，在物体的交界处呈现的是锯齿状，哪怕分辨率非常大，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">1600</span>;</span><br></pre></td></tr></table></figure>
<p>得到这样的图像</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307193903032.png" alt="image-20220307193903032"></p>
<p>放大边缘，可以看到依然如此，为了解决这个问题，先看抗锯齿的本质。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307193945194.png" alt="image-20220307193945194"></p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>其实这个问题之前讨论过，相机只对着每个像素的左上角发射光线，那左上的带回的颜色可以代表整个像素吗？当然不行，所以最好的解决办法就是在这个像素内多发射几次光线，然后取颜色的平均值，即提高<strong>采样率</strong>。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307194536541.png" alt="image-20220307194536541"></p>
<p>比如上图中我们可以在一个像素内采样四次，得到的图像就会准确的多。</p>
<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>在这里我们就需要用到随机数，其实光线追踪的很多地方都会用到它，首先回忆一下C语言中的随机数，在rtweekend.h中加入内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rand()会返回一个0~RAND_MAX之间的随机数，所以下面这个式子返回的随机数值范围是[0,1)。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围在[min,max)的随机数。</span></span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中，我们有更强大的随机数算法，那就是mt19937，它的随机性好，在计算机上容易实现，占用内存较少，所以这里选用mt19937随机数，可以把上面代码中random_double函数改掉：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置随机范围0到1</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//创建随机数对象</span></span><br><span class="line">    <span class="keyword">static</span> std::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装相机"><a href="#封装相机" class="headerlink" title="封装相机"></a>封装相机</h4><p>这是一个封装我们的相机的好机会。在开始多次采样之前，我们先把相机处理完，让main函数中少一点乱七八糟的代码。</p>
<p>我们可以把在main函数中渲染循环外对相机的所有操作都移动到相机类的构造函数里，然后创建一个类内函数专门用来发射光线，这样设计下来，在main函数中所剩的代码最为清爽。</p>
<p>创建camera.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>() &#123;</span><br><span class="line">            <span class="comment">//暂时全部写死，代码保持和之前在main函数中的一致。</span></span><br><span class="line">            <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">            <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">			</span><br><span class="line">            origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//发射光线的函数，吃xy轴的偏移，吐出一根从原点射往指定方向的光线。</span></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">//这些参数我们没有暴露的必要。之后我们制作高级相机的时候，再考虑要不要把它们的权限放开。</span></span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="修改颜色类"><a href="#修改颜色类" class="headerlink" title="修改颜色类"></a>修改颜色类</h4><p>因为现在需要多次采样，原color类中的write_color函数也需要修改，为了用户更方便的使用main函数中，颜色只管叠加，其余交给write_color处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除以采样次数</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保最终的值是在[0,255]之间，换句话说，我们需要确保r,g,b都在[0,1]之间。</span></span><br><span class="line">    <span class="comment">//这个clamp函数在之后给出。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先需要把处理传进来的颜色除以采样数，还需要将每个通道的颜色映射到0到255的范围内。其中clamp函数是为了确保传入的值在特定区间内，比如这里如果传入的值大于1，就会导致颜色无法显示。所以还是在这个文件中写入函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">clamp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成果验收"><a href="#成果验收" class="headerlink" title="成果验收"></a>成果验收</h4><p>接下来只要替换相机，渲染循环中再加一层for即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们必须要一些参数来告诉程序需要生成什么样的图片，这部分代码逻辑上和摄像机没有关系，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="comment">// 采样次数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要一个构造函数，我们就可以把相机安排妥当。</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//多了一层循环哦。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 随机数出场了，u和v每次都会随机加上一个[0,1)的数，然后除以image的长宽之后，</span></span><br><span class="line">                <span class="comment">// 就会落到一个像素内的随机位置。</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height<span class="number">-1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调用摄像机中封好的函数创造射线。</span></span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                <span class="comment">// 无脑颜色累加即可。</span></span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//最终的绘制颜色代码中，再做最终除法。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>漫长等待后我们得到了一个更加“圆润”的球</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1641055023853-5ad8e5c5-7671-4f8e-935c-e3cb0cb46544.png" alt="image.png"></p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/1641054959394-b2494392-8f05-402d-8d58-fa3482970136.png" alt=""></p>
<p>强大的力量都需要代价，代价就是比原来要多花100倍的时间。但是多次采样是我们渲染效果真实感的保障，并且多次采样在后面还有着更为广泛的应用。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li><p>该场景下的抗锯齿算法是否可以优化？</p>
<p>我认为是可以优化的，比如我们是没有必要在非物体的边缘做100次的采样，这些地方发射一次又或是多次带回来的结果也没有什么不同，所以这里可以在一个像素内先少量采样，如果它们返回的t值不同，则说明这个像素处于物体交界处，需要多次采样来抗锯齿。也类似光栅化中的FXAA。</p>
</li>
<li><p>了解光栅化有哪些抗锯齿方法。</p>
<ol>
<li>增加屏幕分辨率。</li>
<li>在采样之前进行模糊处理（滤波）处理，边界弱化以后，对应像素值起缓冲作用。</li>
<li>MSAA，跟本文一样检测图形覆盖面积，也是随机多次采样的方法。</li>
<li>FXAA，获得由锯齿的图，再后处理后去除锯齿，速度快。</li>
<li>TAA，在时间和空间上都采用不同的采样点取颜色混合，静态场景下，每一次采样使用像素中心添加一个随机的抖动取得，该帧结果与上一帧进行混合，动态场景下需要使用 <strong>Motion Vector</strong> 贴图来记录物体在屏幕空间中的变化距离，并使用它得到该物体片元上一帧的像素值进行混合。</li>
</ol>
</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第7节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>六：物体列表</title>
    <url>/2022/02/28/%E5%85%89%E8%BF%BD1.6/</url>
    <content><![CDATA[<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>有了物体类，我们可以创建单个物体了，但是如果场景物体非常的多，我们则需要一个数组储存它们，不仅如此我们在进行光线的碰撞检测的时候还需要依次调用它们碰撞函数，并且在创景变化或者程序结束的时候去释放内存等等。所以这些操作放在main函数中是不合适的，所以最好的办法是定义一个类去实现这些操作。创建hittable_list.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针！用它来帮我们管理物体列表，就不用担心内存泄漏问题了！</span></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//当创建物体列表的时候传入了某一个物体，我们直接调用add函数把这个物体加入列表。</span></span><br><span class="line">    	<span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//clear函数调用列表的clear函数清空列表。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    	<span class="comment">//add函数调用push_back把新物体的智能指针加入列表</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//声明我们需要override父类的hit函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//物体列表，使用vector去存每个物体的智能指针。</span></span><br><span class="line">        std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写之后的hit函数。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最开始，把能接受的最远位置设置成外部传进来的t_max。</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个物体做碰撞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line"> 		<span class="comment">//光线射到了这一堆物体里的某一个。</span></span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            <span class="comment">//光线有射中东西，把最终函数的返回值设定为true。</span></span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//光线虽然已经射中了一个东西了，但不确定射中的这个物体是不是离相机最近的。</span></span><br><span class="line">            <span class="comment">//范围缩小，然后继续遍历物体列表。</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每次有新的碰撞，就设定它的record为最终record。</span></span><br><span class="line">            <span class="comment">//遍历完成后，就可以找到最近的碰撞点并返回它的rec。</span></span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回这根光线是否有碰到物体列表中的任何物体。</span></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这里面有两个C++非常中要的概念：智能指针和多态</p>
<p>1）智能指针。</p>
<p>C++11给我们提供的瑰宝，它的本质是维护一个指针和一个计数，当创建智能指针并让他指向一个对象的时候，引用计数为1，之后每有一个新的指向它的指针被创建，引用计数加1，一个指针被销毁或者不再指向它，引用计数会下降。引用计数为0则释放对象所占内存。</p>
<p>之前的类我们一直都在“造轮子”，这个物品列表类的作用是管理我们之前做好的“轮子”。通常<strong>C++中用于管理一些对象的类，一般都是通过指针去管理。</strong>对象之间的传输不仅会占据系统栈的内存，还需要付出因拷贝构造而消耗的时间。</p>
<p>况且通过指针管理对象还有另一层作用，那就是“多态”。</p>
<p>2）多态。</p>
<p>继承结构内的多态的一大实现条件就是<strong>基类指针指向子类对象</strong>。这是一个极其经典的场景，我们通过虚函数的重写，再通过基类指针定义某一个接口，在实际程序运行过程中无论来的是哪个子类对象，都可以精确的调到对应的虚函数。</p>
<p>在这个程序中，hit函数是如何完成多态的呢？我们的物品列表类只说明了这个列表里面的东西会是一个物体，即它存的是基类指针，hit函数中我们分别调用了列表中每一个指针指向对象的hit函数的，虽然此时并不知道它到底是个球，或者是其他的什么东西，我们只管调用它，多态会帮我们找到具体到底是那个函数并且调用到它。</p>
<p>把物品列表类设计成了物品类的子类还有更多的好处，举一个只有这样设计才能达成的疯狂的玩法！我们可以在这里进行无限层的嵌套！比如下面的某个物品列表：</p>
<p><em>-物品列表</em></p>
<p><em>-子物品列表1</em></p>
<p><em>-球1</em></p>
<p><em>-球2</em></p>
<p><em>-子物品列表2</em></p>
<p><em>-球3</em></p>
<p><em>-球4</em></p>
<p>现在给最外层的物品列表调用hit函数，我们问这个列表：“这根光线有没有和这一大堆东西碰撞呀，碰撞结果如何啊？”</p>
<p>最外层的列表说：“我给你看看把，我这里有俩玩意，但我不知道这俩玩意是啥，我帮你找他们问问（最外层列表只知道列表中有俩物体，它不知道这些物体到底是啥）”</p>
<p>紧接着程序开始按照名单给这俩小物品列表发消息：“嘿，你们是什么玩意啊？是球吗？我不管你们是不是球，上面发话了，要看看这根光线有没有和你们碰撞，碰撞情况如何啊？我把光线信息和上面要求的t的范围发给你了啊，再给你一个地址，你们俩把record填好啊！我不管了啊！”</p>
<p>好了，俩小物品列表收到消息也急了，它赶忙找它们下面的东西：“嘿！听的到么！我不管你们是谁，老板要求你们把这根光线…….(省略)”</p>
<p>最外层的物品列表只需要维护自己的closest_so_far，比较两个子物品列表给出的t的大小并选择最小的那个，而再下层的东西它完全不用去管。</p>
<p>这叫什么？递归！我们用“物品列表类是物品类的子类”这一设计，实现了一个精美的递归代码帮我们完成一个光线和一堆物品的碰撞。这也多亏了多态的支持。我无法想象如果我们没有多态，实现一个嵌套列表到底要多出几百倍的代码。</p>
<p>我画了一张类图在来帮助理解这部分代码：</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/%E5%85%89%E8%BF%BD%E7%B1%BB%E5%9B%BE2.png" alt="光追类图2"></p>
<h4 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h4><p>现在还需要一些常量数字，比如无穷大。不然我们要怎么传最初始的t_max值呢？我们不能在一开始就限定它为10000，1000之类的。显得很不专业，况且，一些常量和一些换算之后还会有更多作用。我们先把我们能想到的写上，之后需要其他的再添加。</p>
<p>文件取名为rtweekend.h，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTWEEKEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTWEEKEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用C++帮我们定义好的double类型的无限值作为无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> infinity = std::numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="comment">// Π。 我们先把这个东西放在这，虽然暂时还没有什么用。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个角度值转弧度制的函数，嗯。。或许暂时也没有什么用。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="keyword">double</span> degrees)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这俩头文件可是我们的常客，之后用他们就直接包这个rtweekend文件就行了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><p>在main函数中写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新的光线取色函数中，我们加入了一个名为世界的物体对象，别看它是一个物体对象，我们一般会传入一个物体列表。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">//我们使用到了我们定义的无限大，并且剔除了负t</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">//没错，依然是元气弹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//蓝天...</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创造世界</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入俩个球</span></span><br><span class="line">    <span class="comment">//和以前一样</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    <span class="comment">//一个非常吓人的巨型球！</span></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机相关</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染循环（render loop）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line">            <span class="comment">//和原来没什么不同，也说明了作者的封装非常完美</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307133434367.png" alt="image-20220307133434367"></p>
<p>于是我们得到了在一片草原之上的元气弹，实际上只是球体所在位置及其表面法线的可视化。这通常是查看模型缺陷和特征的好方法。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第6.5节到第6.7节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>五：物体类</title>
    <url>/2022/02/26/%E5%85%89%E8%BF%BD1.5/</url>
    <content><![CDATA[<h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>首先可以简化一些不必要的常数项，聊胜于无的优化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="comment">//默认直接把2除掉</span></span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">    <span class="comment">//这个discriminant是之前的四分之一。</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//分子分母都是简化前的一半。</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (-half_b - <span class="built_in">sqrt</span>(discriminant) ) / a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>现在有了球，或许需要一个球类去描述它，但是未来可能还会有更多的其他种类的物体，最容易想到的方法是首先编写一个物体基类。</p>
<p>这个抽象基类需要抽象出所有物体的共性：</p>
<p>一个物体一定可以被光线感知到，它可以被光线照到，并且光线可以通过这次碰撞获取一些关于物体的信息。即，它需要一个抽象的<strong>碰撞函数</strong>，就和我们之前在main所在文件中写的球简易碰撞函数那样。这个函数的返回值设计成bool，即返回是否碰撞到。至于其他的碰撞信息，我们可以通过一个结构体返回，其中包括：</p>
<ol>
<li><strong>t值</strong>。除了判断t值可以确定是否碰撞到物体，t值在之后会有更大的作用，可以说，<strong>t值是光线和物体碰撞中最重要的信息之一，</strong>应当让外界知道这个值以方便其他的运算。</li>
<li><strong>法线</strong>。前面的元气弹就是使用了法线实现的效果，但是这还不是全部，法线的作用还有很多，比如镜面反射，比如通过法线去计算反射方向。总之，我们需要返回法线信息。</li>
<li><strong>碰撞点坐标</strong>。很多情况下都需要用到p点坐标，我们不希望每次用到的时候都去计算一遍，而且我们理应把这些计算放在更底层的地方，而且我们也不应该把这种底层计算放在用户看得到的地方。</li>
</ol>
<p>创建hittable.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把需要返回的数据封装成结构体，按照上面分析的，暂时我们需要这三个东西。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可碰撞物体类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//需要这样一个纯虚函数，所有继承自这个类的子类（如球），都需要实现这个函数。</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在类中多了两个参数，分别为允许t的最小、最大值，有了它我们就可以剔除t小于0的情况（即物体在相机后后面的情况），同时它还有更多的用处。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>基于这个物体类来实现球类的代码，创建sphere.h文件，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//构造</span></span><br><span class="line">        <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">sphere</span>(point3 cen, <span class="keyword">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//声明要override纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//老代码</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发现方程没有根，直接退出。</span></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为我们引入了tmax和tmin，所以这里还需要格外的运算。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查较小的根</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        <span class="comment">//检查较大的根</span></span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封入结构体</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">//不用麻烦使用unit_vector函数，直接利用已经存好的半径进行单位化，实现加速。</span></span><br><span class="line">    rec.normal = (rec.p - center) / radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>第40行开始的if语句非常的巧妙，因为只有在较小的根不满足<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/d87a46ba28d0db64bb2642603c553fba.svg" alt="img">的时候，才会检查较大的根，换句话说，如果较小的根在我们的许可范围内，我们会直接采纳他。一般来说，较小的根是光线和物体的首次交汇点，所以优先返回较小根是非常合理的。</p>
<p>那么什么场景才能用到较大的根呢？非常明显，是相机在物体的里面的时候，但这种情况也会导致之前计算的法线方向相反，接下来就来解决它。</p>
<h4 id="法线修正"><a href="#法线修正" class="headerlink" title="法线修正"></a>法线修正</h4><p>通过什么方式判断法线是否反了呢？可以注意到的是，法线与入射光线的夹角一定小于90度的，所以可以使用向量的点乘来进行判断，并且这部分判断可以直接放在hit_record内，同时在碰撞函数中调用它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//光线打到的是不是物体的外面？</span></span><br><span class="line">    <span class="keyword">bool</span> front_face;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个结构体内的函数，他判断法线的里外，并且在光线打到物体内面时取反法线。</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sphere.h中修改hit函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用这一个函数设置hit_record中的法线和front_face</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第6.2节到第6.4节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>四：球</title>
    <url>/2022/02/25/%E5%85%89%E8%BF%BD1.4/</url>
    <content><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>接下来总要让一个对象让光线碰撞，这里选择使用最简单的物体：球</p>
<script type="math/tex; mode=display">
X^2+Y^2+Z^2=R^2</script><p>一个非常标准的球的数学表达式，这个公式表示以原点为球心，半径是R的球。所有坐标是（x,y,z）的点满足上面的表达式<strong>都在球上</strong>。接下来是点在球内和求外的公式：</p>
<script type="math/tex; mode=display">
X^2+Y^2+Z^2<R^2</script><script type="math/tex; mode=display">
X^2+Y^2+Z^2>R^2</script><p>假定球心为$(C_x,C_y,C_z)$</p>
<script type="math/tex; mode=display">
(x-C_x)^2+(y-C_y)^2+(z-C_z)^2=r^2</script><p>但是这个公式没有办法在我们的项目中使用，我们的底层使用的vec3类，更希望看到向量而不是标量表示，我们需要简单的改变一下这个公式。现在假设球形所在的坐标用<strong>C</strong>这个vec3类常量表示，即$C=(C_x,C_y,C_z)$。同样的令$P=(x,y,z)$有：</p>
<script type="math/tex; mode=display">
(P-C)\cdot(P-C)=(x-C_x)^2+(y-C_y)^2+(z-C_z)^2</script><p>上述式子的左侧是一个向量模的平方，右侧是一个距离公式。它们都表示P点和C点之间的距离的平方。所以有：</p>
<script type="math/tex; mode=display">
(P-C)(P-C)=r^2</script><p>所有满足这样要求的<strong>P</strong>——它到<strong>C</strong>点的距离为r，这样的点一定在以<strong>C</strong>为球心，r为半径的球上。</p>
<p>现在引入光线，如果光线曾在某一个时刻打在球上，则表示有一个t，使得$P(t)=A+tb$正好传播到了球的位置。带入它之后：</p>
<script type="math/tex; mode=display">
(P(t)-C)\cdot(P(t)-C)=r^2</script><p>展开：</p>
<script type="math/tex; mode=display">
(A+tb-C)\cdot(A+tb-C)=r^2</script><p>把左侧括号乘开，这里我们把$(A-C)$看作一个整体，再把右侧的移$r^2$到左侧。</p>
<script type="math/tex; mode=display">
t^2b\cdot b+2tb\cdot(A-C)+(A-C)\cdot(A-C)-r^2 =0</script><p>变成了一个t的一元二次方程。（b表示光线方向，A是光源位置，C是球心，全是常量）。</p>
<p><img src="https://s2.loli.net/2022/03/06/VImPT4rJxWjOvKF.png" alt=""></p>
<h4 id="碰撞函数"><a href="#碰撞函数" class="headerlink" title="碰撞函数"></a>碰撞函数</h4><p>在.cpp文件中main函数外写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简易的球的碰撞检测函数，吃球心，半径和一根光线，吐出光线是否击中球的bool值。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个oc就是上面函数里的(A-C).</span></span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="comment">// 对应上面公式里的b的平方。即平方项的系数。</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 对应上面公式里的2*(A-C)点乘b，即一次项的系数</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// (A-C)点乘(A-C)减去r的平方，即常数项。</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="comment">//高中最爱的Δ，b的平方减4ac。</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="comment">//返回方程有没有根，即光线有没有碰撞到球体。</span></span><br><span class="line">    <span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果我们击中了这个球心在(0,0,1)且半径是0.5的球，就直接返回颜色为红色。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果没有击中的话你就继续画蓝天吧。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终得到了一个不那么美丽的太阳！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223618931.png" alt="image-20220306223618931"></p>
<h4 id="可视化法线"><a href="#可视化法线" class="headerlink" title="可视化法线"></a>可视化法线</h4><p>如果我们得知光线和球的碰撞点为P，我们需要得到这一点的法线，它应该是从球心发射，穿过这一点指向球的外侧，所以是<img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/3c59ca980a313e3ab91bf87f5db239c0.svg" alt="img">。</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223737173.png" alt="image-20220306223737173"></p>
<p>这里需要考虑两个问题：</p>
<ul>
<li>它应该是单位向量吗？是的，它应该是，单位化法线可能会在某些方面为我们的渲染提供便利，但是不强制，并不要求法线一定是单位向量，如果必须是单位化的地方我们进行单位化即可。为了省去这一步骤这里选择永远单位化它。</li>
<li>之前我们给的hit_sphere函数的框架已经不足以满足我们获取法线的需要了，因为这里不仅仅需要了解球和光线是否碰撞，我们还得知道光线和球的第一个焦点的位置，因为只要不是极端的相切的情况，我们总能找到两个焦点，所以我们需要t较小的那个焦点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//它不再返回bool，而是返回一个浮点数，表示光线第一次打在球上的时候的时间t。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Δ小于0，别看了，光线没打到球，直接返回一个负值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 求根公式，我们返回了较小的那个根。</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过得到的法线返回颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//如果光线击中了球。</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    	<span class="comment">//拿到法线，嘿嘿，我们之前写过很久的at函数终于派上用场了。我们这次单位化它。</span></span><br><span class="line">        vec3 N = <span class="built_in">unit_vector</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//返回法线可视化之后的颜色值，注意我们做了一个[-1,1]到[0,1]的映射。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*<span class="built_in">color</span>(N.<span class="built_in">x</span>()+<span class="number">1</span>, N.<span class="built_in">y</span>()+<span class="number">1</span>, N.<span class="built_in">z</span>()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没打中？继续画蓝天吧。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将hit_shpere函数的返回值由bool改为第一次碰撞的时间t，并在取色函数中通过时间t获取碰撞点，并计算出法线，最后将法线映射为颜色，最终我们可以看到一个元气弹！</p>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307085406164.png" alt="image-20220307085406164"></p>
<h4 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h4><ol>
<li>在红太阳阶段的代码中如果将太阳放在相机后面会发生什么呢？</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220306223618931.png" alt="image-20220306223618931"></p>
<p>可以看到与放在相机前没有任何变化，我认为是主要是因为这段代码虽然判断了碰撞函数是否有解，但是忽略了t小于0 的情况，以至于放在相机前后没有区别，用第二段代码就没有任何问题。</p>
<ol>
<li>元气弹的颜色遵循什么规律呢？</li>
</ol>
<p>按照代码逻辑应该是碰撞法线x,y,z分量分别对应r,g,b的值。那么应该是向右越来越红，向上越来越绿，由中心向外越来越蓝。</p>
<ol>
<li>使用元气弹版本的代码，更改hit_sphere函数，这次返回较大的那个根，生成图片另外保存。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求根公式，这次返回较大的那个根。</span></span><br><span class="line"><span class="keyword">return</span> (-b + <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br></pre></td></tr></table></figure>
<p><img src="https://imagebed001.oss-cn-shenzhen.aliyuncs.com/image-20220307092334496.png" alt="image-20220307092334496"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第5节和第6.1节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>三：光线、相机与天空</title>
    <url>/2022/02/23/%E5%85%89%E8%BF%BD1.3/</url>
    <content><![CDATA[<h4 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h4><p>如何将抽象的光线具体的表现出来并不困难，在初中物理的时候我们就使用一个点加上一个射线的方式来表示光线，于是我们可以用这样的公式描述它：<code>P(t)=A+t*b</code></p>
<p><img src="https://s2.loli.net/2022/03/05/s71P5mzYDjenywC.png" alt="image.png"></p>
<p><strong>A</strong>表示光线的原点（光源位置），<strong>b</strong>为一个单位向量表示一个方向，t则表示单位时间，通过给t取不同的值，我们可以得到沿路上所有的点的三维坐标，当然，这个值一般来说不会为负数，我们新建ray.h，输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//空构造。</span></span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    	<span class="comment">//带参构造，显然我们需要一个原点和一个方向。</span></span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//通过这个函数拿取原点值。</span></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">		<span class="comment">//通过这个函数拿取方向值。</span></span><br><span class="line">    	<span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//这个函数就对应了上方数学公式中的P(t)，通过传入一个时间t，能得到当前光线传播到的坐标位置。</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h4><p>我们把“相机”固定在一个位置，并且固定一下它观察的方向。</p>
<p>接下来需要解决两个问题：</p>
<ol>
<li>光线从哪里射出呢？相机位置。按照常理来说，太阳发出的光线从物体上弹射了多次，最终会被摄像机（或者人眼）捕捉。相机位置应该是光线的终点才对啊，怎么会是起点呢？<strong>原因是我们需要逆光路取色，这是路径追踪的经典光线模型，重点是我们的光线和现实中的光线是反过来的，如果正向光路进行光线追踪会极其困难，几乎寸步难行。</strong></li>
<li>光线朝哪个方向射出呢？这就要引出一个“虚拟视口”的概念。它就像一个相框，摆在相机的前面，相机发射的密集光铺满相框，就得到图像，具体方法为：<strong>按照行优先的顺序，从左上角开始，一排一排的射出光线，射出光线的数目就是像素的数目，换句话说，我们对每一个像素都会射出一根光线</strong>。</li>
</ol>
<p>将相机位置定位（0，0，0）这个场景是这样的：</p>
<p><img src="https://s2.loli.net/2022/03/05/qhcP98ZAYve1SCt.png" alt="image.png"></p>
<p>假设图中的虚拟视口上有800个像素，每个像素长宽都是0.1，最终得到一张40<em>20的图片，我们只需要瞄准<em>*每一个像素的中心</em></em>。</p>
<p>按照行优先左上角开始，发生的第一根光线应该是从（0，0，0）射向（-2+0.05，1-0.05，-1）方向。不必要求这个方向向量是一个单位向量，保持方向向量是单位向量并不能给项目提供更多便利。如此类推：第二个是（-2+0.15，1-0.05，-1）方向、第四十个是（-2+3.95，1-0.05，-1）方向、第八百个是（-2+3.95，1-1.95，-1）方向。</p>
<p>改写main函数，并且为其所在的文件添加一个全局函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个简单的决定光线所带回颜色的函数。</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先把这个光线的方向向量单位化。</span></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再根据这个单位化向量的y分量给他设定颜色，得保证t在[0,1]之间。</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 插值函数，t靠近0它就越靠近白色，越靠近1它就越靠近一种蓝色。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//图片数据，这次我们换一种角度去定义图片的长宽，我们定义一个长宽比，再把它的宽度定义出来。</span></span><br><span class="line">    <span class="comment">//长度就可以通过简单的计算得到。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟视口数据，我们保持它的高度（宽度）为2，长度同样通过长宽比得到。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//保持视口和实际图片的长宽比一致。</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height; </span><br><span class="line">    <span class="comment">//这是视口离相机的距离，保持为1就好，我们暂时把它写死。</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相机位置</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//相机水平方向，即X轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//相机头顶方向，即Y轴正方向。</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个是虚拟视口左下角所在位置的坐标，在上面那个图片例子里，它就是（-2，-1，-1）。</span></span><br><span class="line">    <span class="comment">//注意因为长宽比不是2/1而是16/9，所以本例子里这个值和图片中的值不同。</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环（render loop）</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//这个uv就是当前像素位置的横纵坐标偏移。</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//创造射线。</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            <span class="comment">//通过全局函数取到本像素颜色。</span></span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="comment">//写颜色到输出流。</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/qt3BYcAd9NI5kvS.png" alt="image.png"></p>
<p>通过光线在y轴方向上的分量得到一种类似于蓝天的效果，这个图片也将在后来成为我们的背景。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1：循环渲染射出光线瞄准的是哪里呢？</p>
<p>仔细计算可以发现，是每个像素的左上角，并不是中心点，其实左上角又或是中心点这一点的颜色都不能代表整个像素的颜色，这个问题后续将会解决。</p>
<p>2：更改ray_color函数可以制作一些更加炫酷的背景：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec = r.<span class="built_in">direction</span>() * <span class="number">1</span> - r.<span class="built_in">origin</span>(); </span><br><span class="line">    <span class="keyword">auto</span> absVec = <span class="built_in">vec3</span>(std::<span class="built_in">abs</span>(vec.<span class="built_in">x</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">y</span>()), std::<span class="built_in">abs</span>(vec.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unit_vector</span>(absVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/OVRxAhGDbnywlYm.png" alt="image.png"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第4节</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>二：点、向量、颜色</title>
    <url>/2022/02/21/%E5%85%89%E8%BF%BD1.2/</url>
    <content><![CDATA[<p>既然是光追，肯定离不开点和方向于颜色，在大多数工程中，颜色和方向是四维的向量，但是对于这个工程，三位向量可以满足需求，我们定义一个类来表示它们：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防止被重复引用，用ifndef去包裹所有代码。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要一些cmath类里面的数学函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精确引用，只需要开方函数就只引入最小的命名空间</span></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 空构造，默认构造一个（0，0，0）向量</span></span><br><span class="line">        <span class="built_in">vec3</span>() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 传入三个参数的构造。</span></span><br><span class="line">        <span class="built_in">vec3</span>(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义x，y，z分量。这样就可以用 向量.x() 直接拿取x分量。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//下面进行运算符重载。</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//单目 &#x27;-&#x27; 运算符 ，会对三维向量的每一维取反。</span></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符的const版本，返回右值。</span></span><br><span class="line">    	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// &#x27;[]&#x27; 运算符普通版本，返回左值</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;+=&#x27;运算符，const保护参数不被修改，返回引用允许操作符嵌套。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// &#x27;*=&#x27;运算符</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// &#x27;/=&#x27;运算符，直接使用*=去定义&#x27;/=&#x27;。</span></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//模相关。</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 模的平方。</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 模</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// 向量中的数组也直接暴露出去了，这里是float也没问题，看你的喜好。</span></span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给vec3类多起几个名字。</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point，在指定三维空间中的点的时候使用这种别名。</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color，在指定颜色的时候使用这种别名。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="类外补充"><a href="#类外补充" class="headerlink" title="类外补充"></a>类外补充</h4><p>接下来是一些加减乘除等操作，其中的有些操作并不可以写在类内，比如double类型<code>*</code>vec3类型，所以统一写在类外：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vec3 类外函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出流符号&quot;&lt;&lt;&quot;</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123; </span><br><span class="line">    <span class="comment">//当用户使用 cout &lt;&lt; vec3的时候，输出vec3中的各个分量值。</span></span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符，它的返回值不是引用，这很合理，我们永远不会把 “a + b”这样的东西放在赋值符号左侧</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，向量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符，标量*向量</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还是*运算符，但这次参数中标量和向量的顺序是反过来的。</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用*去定义/</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量点乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量叉乘，计算方法严格遵循数学定义。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单位化这个向量，就是把它的各个分量除以它的长度，正好，我们可以用上面刚刚写完的/运算符去定义它。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽离与简化"><a href="#抽离与简化" class="headerlink" title="抽离与简化"></a>抽离与简化</h4><p>在第一章时，有三行将0-1的通道映射到0-255的代码，这部分代码是固定的，可以统一将它们抽离出去，创建、<code>color.h</code>文件，以后的关于渲染颜色的代码统一放到这里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个全局的函数，接受一个输出流参数，和一个color参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把之前的代码两步并作一步，直接转到[0,255]区间然后直接输出出去。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来main函数的代码将相当简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//直接调用vec3类有参构造构造一个对象</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写颜色！如此的简单！</span></span><br><span class="line">            <span class="built_in">write_color</span>(std::cout, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第3节</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>一：生成第一张图片</title>
    <url>/2022/02/19/%E5%85%89%E8%BF%BD1.1/</url>
    <content><![CDATA[<p><strong>前言：</strong>前段时间在学习C++ primer的同时，我还有幸接触到了一本非常有趣的书，它通过我们的vs写出的代码直接模拟光线追踪生成图像。地址：<a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a>。它非常的有趣也具有很高的学习价值，所以我想把学习的过程记录下来，也欢迎大家来一起学习并找出其中的错误，废话不多说，直接开始！</p>
<h4 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h4><p>首先明确我们这里使用的是ppm格式的图片格式，它是通过类似于<code>vector&lt;vector&lt;int&gt;&gt;</code>的方式记录下每个色素的RGB值。</p>
<p><img src="https://s2.loli.net/2022/03/04/enLDpxsbyNRazIu.png" alt="image.png"></p>
<p>此外在开头还需要做一些说明：</p>
<ul>
<li>P3#代表颜色使用ASCII码表示</li>
<li>3 2#代表3行两列，它使得我们接下来的数字不需要按照行列摆放工整，而是可以</li>
<li>255#表示使用0-255来表示一个通道的颜色</li>
</ul>
<p>可以试着通过代码来生成一张这样的图片：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义图片的宽度和高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印ppm文件的开头</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以左下角为原点，从左上方依次打印像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//将r和g通道控制在0-1内</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in"><span class="keyword">double</span></span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in"><span class="keyword">double</span></span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line">			<span class="comment">//之后统一将它们映射到0-255</span></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">			<span class="comment">//依次输出rgb，注意中间空格</span></span><br><span class="line">            std::cout &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完代码之后，我们以release方式运行，之所以不选择debug模式，主要还是因为太耗费时间，在保证代码不出现错误的情况下，使用release可以节省一些时间。</p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>以上代码只能让信息输出到控制台，而我们希望将其输出到一个文件内，所以我们可以使用命令行实现：</p>
<ul>
<li>打开命令行输入项目所在硬盘加冒号之后回车，如：<code>D:</code></li>
<li>接着输入，cd+空格+项目文件下的release文件夹地址后回车，如：<code>cd D:\C++\RayTracing\x64\Release</code>同时还要注意是X86还是X64。</li>
<li>之后输入<code>raycast.exe &gt; image.ppm</code>，raycast.exe为我们的程序，使用<code>&gt;</code>重定向将数据输出到文件名为image1.1的文件中，同时指定文件格式为ppm</li>
</ul>
<p>最后依次回车之后我们就可以在release文件夹下看到一个image的图片文件，如果打不开，可以下载一个极速看图软件。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220304224339897.png" alt="image-20220304224339897"></p>
<p>一张非常绚丽的图，正如我们代码中的那样，从左到右越来越红，从下到上越来越绿。</p>
<h4 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h4><p>现在我们并不知道图片能够多久加载完成，当所需要的图片像素点非常多时，这个问题会更加明显，所以我们使用std::cerr来显式加载的进度，它主要用于显示错误消息，且不被缓冲，可以发送到显示器，并且不被重定向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 提示还有多少行数据没有处理完。</span></span><br><span class="line">       std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提示已经完全搞定。</span></span><br><span class="line">   std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>同时使用“\r”可以把光标强行移回本行开头，这样这次输出的内容就会覆盖掉这一行原本的内容，就好像每次到来的新东西会“冲洗”掉之前输出的东西。</p>
<p>注意这一行的结尾是std::flush，它表示再输出完这一行之后，会强行把内存中缓冲区内的数据打出到错误输出流里（清空缓冲区）。<a href="https://blog.csdn.net/sss_0916/article/details/95622404?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5.pc_relevant_default&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8">endl、ends和flush的区别</a></p>
<p>再次使用命令行就可以看到</p>
<p><img src="https://s2.loli.net/2022/03/04/hHqw6jYGFof7dPX.png" alt="image.png"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></p>
<p>参考自《RayTracingInOneWeekend》第2节。</p>
]]></content>
      <categories>
        <category>光线追踪</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>光追渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十六章</title>
    <url>/2022/02/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> string&amp; v1, <span class="keyword">const</span> string&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl &lt; v2) <span class="keyword">return</span> -l; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; v1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于像这样除了类型意外一模一样的函数，我们可以使用模板来适配各种各样的类型。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板，而不是为每一个类型定义一个新的函数。则compare的模板可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; vl) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板定义以关键字template开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(&lt;)和大于号(&gt;）包围起来。</p>
<p><strong>在模板定义中,模板参数列表不能为空。</strong></p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>调用一个函数模板时，编译器用函数的实参来推断模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt; endl; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>

<p>编译会推断出实参int，并绑定到T，这样推断出来的为我们<strong>实例化</strong>一个特定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T为int</span></span><br><span class="line"><span class="comment">//实例化出int compare (const vector&lt;int&gt;&amp;,const vector&lt;int&gt;&amp;)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;, vec2&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1, vec2) &lt;&lt;endl; <span class="comment">// T为vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里编译器会实例化两个不同版本的compare。其中一个T为int，另一个T为vector<int>，编译器生成的版本成为模板的实例。</p>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>我们的compare函数有一个模板类型参数(type parameter)。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确:返回类型和参数类型相同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">Tfoo</span> (T* p)&#123;</span><br><span class="line">	T tmp = *p; <span class="comment">// tmp 的类型将是指针p指向的类型/ / ...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数前必须使用关键字class或typename:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误:U之前必须加上class或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;)</span> </span>;</span><br><span class="line"><span class="comment">//正确:在模板参数列表中,typename和class没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="built_in">calc</span> (<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> U&amp;) ;</span><br></pre></td></tr></table></figure>

<p>因为可以使用非类的类型作为模板实参，所以使用typename更为直观。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了模板参数，我们还可以定义非类型参数，简言之就是一个固定的值，当模板被实例化后，非类型模板参数就被这个值所取代，这个值也必须时常量表达式，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span> (p1, p2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compare</span> ( <span class="string">&quot;hi&quot;</span>, <span class="string">&#x27;mom&quot;)</span></span><br></pre></td></tr></table></figure>

<p>最后编译器使用字面常量大小代替N和M：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1) [<span class="number">3</span>],<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。</p>
<p>通常在需要常量表达式的地方需要用到此参数。</p>
<h4 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确:inline说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误:inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>通过const＋引用的方式，我们保证了函数可以用于不能拷贝的类型。</p>
<p>此外，我们没必要即使用<code>&lt;</code>又使用<code>&gt;</code>运算符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的比较操作</span></span><br><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -l;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//即使用于指针也正确的compare版本;参见14.8.2节（第510页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">( less&lt;T&gt;()(vl, v2))</span> <span class="keyword">return</span> -1</span>;</span><br><span class="line"><span class="keyword">if</span> ( less&lt;T&gt;() (v2, v1)) <span class="keyword">return</span> l;<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的（据查阅资料，less<T>的默认实现用的就是&lt;，所以这其实并未起到让这种比较有一个良好定义的作用—译者注)。</p>
<p><strong>模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>编译器遇到模板时，只有当实例化除模板特例时，才会生成代码。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同:为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>关键概念:模板和头文件</strong></p>
<p>模板包含两种名字:</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p>当使用模板时,所有不依赖于模板参数的名字都必须是可见的,这是由模板的提供者来保证的。而且,模板的提供者必须保证，当模板被实例化时,模板的定义,包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件,包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件,以及用来实例化模板的任何类型的头文件。</p>
<h4 id="实例化器件错误报告"><a href="#实例化器件错误报告" class="headerlink" title="实例化器件错误报告"></a>实例化器件错误报告</h4><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<p>例如原始版本的<code>if (vl &lt; v2) return -l;//要求类型T的对象支持&lt;操作</code>其中如果调用者传入类型没有<code>&lt;</code>运算符，则会在第三个阶段报错。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板是用来蓝图的，编译器不能为类推断参数类型。必须在尖括号中提供额外的信息，用来代替参数的模板实参列表。</p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>我们实现StrBlib的模板版本，为Bolb，不在针对string，使用时用户需要指出元素类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t ypedef T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;T&gt; : :size_type size_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: : initializer_list&lt;T&gt; il);</span><br><span class="line">	<span class="comment">// Blob中的元素数目</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">	<span class="comment">//移动版本，参见13.6.3节（第484页)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std : : <span class="built_in">move</span>(t)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (size_type i); <span class="comment">// 在14.5节(第501页)中定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: : shared ptr&lt;std : : vector&lt;T&gt;&gt; data;<span class="comment">//若data[i]无效，则抛出msg</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std: :string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例如，我们将元素访问操作的返回类型定义为T&amp;。当用户实例化Blob时，T就会被替换为特定的模板实参类型。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>使用类模板时，提供额外信息，这些信息实际上是显示模板实参列表，它们被绑定到模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;					<span class="comment">//空Blob&lt;int&gt;</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; 	<span class="comment">//有5个元素的Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是编译器生成一个类似这样的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std: :vector&lt;<span class="keyword">int</span>&gt;: :size_type size_type; </span><br><span class="line">	<span class="built_in">Blob</span>();</span><br><span class="line">	<span class="built_in">Blob</span>(std: :initializer_list&lt;<span class="keyword">int</span>&gt; il); <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: :shared ptr&lt;std: :vector&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std : : string &amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联,也不会对任何其他B1ob类型的成员有特殊访问权限。</strong></p>
<h4 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h4><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的data 成员使用了两个模板，vector和 shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是Blob的模板参数。因此，data的定义如下:</p>
<p><code>std: :shared_ ptr&lt;std: : vector&lt;T&gt;&gt; data;</code></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</p>
<p>当我们定义一个成员函数时，模板实参与模板形参相同。对于strBlob的一个给定的成员函数</p>
<p><code>ret-type StrBlob : : member-name(parm-list)</code></p>
<p>对应的Blob的成员应该是这样的:</p>
<p><code>template &lt;typename T&gt; ret-type Blob&lt;T&gt;: :member-name(parm-list)</code></p>
<h4 id="check和元素访问成员"><a href="#check和元素访问成员" class="headerlink" title="check和元素访问成员"></a>check和元素访问成员</h4><p>我们首先定义check成员，它检查一个给定的索引:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">check</span>(size_type i,<span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;=data-&gt;<span class="built_in">size</span> ())</span><br><span class="line">		<span class="keyword">throw</span> std: :<span class="built_in">out_of_range</span>(msg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用模板参数指出返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;: : <span class="built_in">back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>); <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt; : : <span class="keyword">operator</span>[](size_type i) &#123;</span><br><span class="line">	<span class="comment">//如果i太大，check会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    <span class="built_in">check</span> (i, <span class="string">&quot;subscript out of range&quot;</span> ) ;</span><br><span class="line">	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pop_back函数与原StrBlob的成员几乎相同:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Blob&lt;T&gt;: :<span class="built_in">pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Blob构造函数"><a href="#Blob构造函数" class="headerlink" title="Blob构造函数"></a>Blob构造函数</h4><p>与类模板外函数一样，构造函数先定义模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>() : <span class="built_in">data</span> (std: :make_shared&lt;std: :vector&lt;T&gt;&gt;())&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>分配一个空vcector，并将指向vector的指针保存在data中，还要有接受一个initializer_list参数的构造函数将其类型参数工作为initializer list参数的元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std: :initializer_list&lt;T&gt; il):</span><br><span class="line">			<span class="built_in">data</span>(std: :make_shared&lt;std: :vector&lt;T&gt;&gt;(il))&#123; &#125;	</span><br></pre></td></tr></table></figure>

<p>为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob的元素类型兼容:</p>
<p><code>Blob&lt;string&gt; articles = &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot; &#125;;</code></p>
<h4 id="类模板成员的实例化"><a href="#类模板成员的实例化" class="headerlink" title="类模板成员的实例化"></a>类模板成员的实例化</h4><p>只有当程序用到它时才会进行实例化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; squares = &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt; : :size ( ) const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != squares.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	squares[i] = i*i;<span class="comment">//实例化Blob&lt;int&gt; : : operator[] (size_t)</span></span><br></pre></td></tr></table></figure>

<p>实例化了 Blob<int>类和它的三个成员函数: operator[ ] 、 size和接受initializer_list<int>的构造函数。</p>
<p><strong>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
<h4 id="在类内简化模板类名"><a href="#在类内简化模板类名" class="headerlink" title="在类内简化模板类名"></a>在类内简化模板类名</h4><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若试图访问一个不存在的元素，BlobPtr抛出一个异常template &lt;typename T&gt; class BlobPtr &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, <span class="keyword">size_t</span> sz - <span class="number">0</span>):</span><br><span class="line">		<span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; </span><br><span class="line">        <span class="comment">// (*p)为本对象指向的vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递增和递减</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置运算符</span></span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--( );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check 返回一个指向vector的shared_ptr</span></span><br><span class="line">	std: :shared_ptr&lt;std: :vector&lt;T&gt;&gt;</span><br><span class="line">		<span class="built_in">check</span>(std : : <span class="keyword">size_t</span>, <span class="keyword">const</span> std : : string&amp;) <span class="keyword">const</span>; </span><br><span class="line">	<span class="comment">// 保存一个weak ptr，表示底层vector可能被销毁</span></span><br><span class="line">	std : : weak_ptr&lt;std : : vector&lt;T&gt;&gt; wptr;</span><br><span class="line">	std : : <span class="keyword">size_t</span> curr; <span class="comment">//数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在递增和递减函数中，我们返回的是BlobPtr&amp;，而不使用BlobPtr<T>&amp;，因为当处于一个类模板的作用域时，自身引用时就等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>

<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>由于在类外，只有遇到类名才代表进入类的作用域，所以类外函数返回自身需要使用BlobPtr<T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后置:递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;: :<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查;调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//保存当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>;<span class="comment">//推进一个元素;前置++检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数体已经进入类内，所以可以直接使用BlobPtr。</p>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</strong></p>
<h4 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h4><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<h4 id="一对一友好关系"><a href="#一对一友好关系" class="headerlink" title="一对一友好关系"></a>一对一友好关系</h4><p>我们的Blob类应该将BlobPtr类和模板版本的Blob相等运算符定义为友元，此外我们在Blob加入可以用==运算符的友元函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置声明，在 Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span><span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;); </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">		(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">	<span class="comment">//其他成员定义，与12.1.1（第405页）相同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里在Blob类中出现的5个T，说明它将对应的类与函数声明为友元，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;<span class="comment">// BlobPtr&lt;char&gt;和operator==&lt;char&gt;都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;<span class="comment">// BlobPtr&lt;int&gt;和operator==&lt;int&gt;都是本对象的友元</span></span><br></pre></td></tr></table></figure>

<h4 id="通过和特定的模板友好关系"><a href="#通过和特定的模板友好关系" class="headerlink" title="通过和特定的模板友好关系"></a>通过和特定的模板友好关系</h4><p>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> &#123;</span><span class="comment">//C是一个普通的非模板类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;<span class="comment">//用类c实例化的Pal是c的一个友元/l Pal2的所有实例都是c的友元;这种情况无须前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">c2</span> &#123;</span><span class="comment">// C2本身是一个类模板</span></span><br><span class="line">	<span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;; <span class="comment">// Pal的模板声明必须在作用域之内</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> x&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">	<span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span><span class="comment">//不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
<h4 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Type; <span class="comment">//将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成为Bar<Foo>的友元，sales data将成为Bar<Sales data>的友元，依此类推。</p>
<h4 id="模板的类型别名"><a href="#模板的类型别名" class="headerlink" title="模板的类型别名"></a>模板的类型别名</h4><p>可以给已经实例化的类起别名：<code>typedef Blob&lt;string&gt; StrBlob;</code>模板起别名的方式为则不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以固定多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">// books是一个pair&lt;string,unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars是一个pair&lt;Vehicle,unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids是一个pair&lt;Student,unsigned&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>类模板也可以声明static成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> std: :<span class="function"><span class="keyword">size_t</span> <span class="title">count</span> <span class="params">()</span></span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">//其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> std: : <span class="keyword">size_t</span> ctr;<span class="comment">//其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的static成员会在同一个类型内共享，如Foo<X>这个类型的所有对象，共享这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化static成员Foo&lt;string&gt; ::ctr和Foo&lt;string&gt; : :count</span></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line"><span class="comment">//所有三个对象共享相同的Foo&lt;int&gt; : :ctr和Foo&lt;int&gt; : : count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2,fi3;</span><br></pre></td></tr></table></figure>

<p>数据成员也同样如此，且必须有且仅有一个定义，所有该特定类的对象共享此成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt; : : ctr = <span class="number">0</span>; <span class="comment">//定义并初始化ctr</span></span><br></pre></td></tr></table></figure>

<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问static成员，我们必须引用一个特定的实例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;						<span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">count</span> () ;	 <span class="comment">//实例化Foo&lt;int&gt; ; :count</span></span><br><span class="line">ct = fi.<span class="built_in">count</span> ();					<span class="comment">//使用Foo&lt;int&gt; : : count</span></span><br><span class="line">ct= Foo: :<span class="built_in">count</span> ();					<span class="comment">//错误:使用哪个模板实例的count?</span></span><br></pre></td></tr></table></figure>

<p>static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板参数的名字不仅可以是T还可以是其他任何命名。</p>
<h4 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h4><p>一个模板参数可用范围是在其声明之后，至模板声明或定义结束之前。与其他任何名字一样的是模板参数隐藏外层作用域声明的相同的名字，不同的是，在模板内不能重用模板参数名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a,B b)</span></span></span><br><span class="line"><span class="function">	A tmp </span>= a;<span class="comment">// tmp的类型为模板参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;<span class="comment">//错误:重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于模板名字不能重用，所以在模板参数列表也只能出现一次：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误:非法重用模板参数名v</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> v, <span class="keyword">typename</span> v&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>模板的声明必须包括模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明但不定义compare和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
<h4 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h4><p>由于使用：：运算符在模板参数上就会有困难，如：T：：men，它不知道men声明类型成员和static数据成员，所以必须知道这个T是否表示一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>如果希望使用一个类型成员就必须显示使用typename关键字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> T: :size_type * p;</span><br></pre></td></tr></table></figure>

<p><strong>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用 class。</strong></p>
<h4 id="默认的模板实参"><a href="#默认的模板实参" class="headerlink" title="默认的模板实参"></a>默认的模板实参</h4><p>就像函数的默认实参一样，我们也可以为模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2，Ff = <span class="built_in">F</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(vl, v2) ) <span class="keyword">return</span> -l;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户调用时，可以自己提供，也可以使用默认的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = <span class="built_in">compare</span> (<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//使用less; i为-1</span></span><br><span class="line"><span class="comment">//结果依赖于item1和item2中的isbn</span></span><br><span class="line"><span class="function">sales_data <span class="title">item1</span><span class="params">(cin)</span>, <span class="title">item2</span><span class="params">(cin)</span> </span>;</span><br><span class="line"><span class="keyword">bool</span> j = <span class="built_in">compare</span> (iteml, item2,compareIsbn);</span><br></pre></td></tr></table></figure>

<p>与函数默认实参一样,对于一个模板参数,只有当它右侧的所有参数都有默认实参时它才可以有默认实参。</p>
<h4 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h4><p>同样的，类可以使用默认模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> &#123;</span><span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Numbers</span>(T V = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line">	<span class="comment">//对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>

<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><h4 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h4><p>若一个普通类中有一个模板函数，便被称为成员模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数对象类，对给定指针执行delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DebugDelete</span>(std::ostream&amp; s = std::cerr) :<span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">	<span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std : : endl; <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::ostream &amp; os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个类似unique_ptr的使用的默认删除器，根据不同的类型进行销毁操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">//可像delete表达式一样使用的对象</span></span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用 DebugDelete: :operator() (double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在一个临时 DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip) ;</span><br></pre></td></tr></table></figure>

<p>我们就可以用这个类型替换unique_ptr中的删除器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁p指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;int&gt; (int *)</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>，DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>,DebugDelete())</span></span>;</span><br><span class="line"><span class="comment">//销毁sp指向的对象</span></span><br><span class="line"><span class="comment">//实例化 DebugDelete: :operator ( )&lt;string&gt; (string* )</span></span><br><span class="line"><span class="function">unique _ptr&lt;string,DebugDelete&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> string,DebugDelete() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>当unique_ptr析构函数调用时，De—类便会实例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DebugDelete的成员模板实例化样例</span></span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">int</span> *p) <span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">void</span> DebugDelete: :<span class="built_in"><span class="keyword">operator</span></span>()(string *p)<span class="keyword">const</span> &#123; <span class="keyword">delete</span> p; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h4><p>类和成员有各自的模板，即可以像这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="built_in">Blob</span> (It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;<span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::<span class="built_in">Blob</span> (It b, It e):</span><br><span class="line">		<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h4><p>为了实例化上一个模板类的成员模板，我们必须同时提供类和函数的实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] =&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">long</span>&gt; vi = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; w = &#123; <span class="string">&quot;now&quot;</span> , <span class="string">&quot;is&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;time&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类及其接受两个int*参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span> <span class="params">(begin(ia), end (ia))</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt; : :iterator的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin (), vi.end ())</span></span>;</span><br><span class="line"><span class="comment">//实例化Blob&lt;string&gt;及其接受两个list&lt;const char*&gt; : :iterator参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;string&gt; <span class="title">a3</span> <span class="params">( w.begin (), w.end ())</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义a1时就实例化了如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; : :<span class="built_in">Blob</span> (<span class="keyword">int</span>* , <span class="keyword">int</span>* );</span><br></pre></td></tr></table></figure>

<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板,并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>在新标准中，我们可以通过显式实例化(explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;		<span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;				<span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">//declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</span></span><br><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;				<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>

<p>编译器遇到extern声明时，它不会在本文件中生成实例化代码，而是承诺其他地方有这样的实例化，我现在只是使用它，对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p>extern声明必须在任何使用此实例之前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Application.cc</span></span><br><span class="line"><span class="comment">//这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sal,sa2; <span class="comment">//实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; al = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(al)</span></span>; <span class="comment">//拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">compare</span>(a1 [<span class="number">0</span>],a2[<span class="number">0</span>]);<span class="comment">//实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>

<p>上面的这些使用extern的实例必须在其他地方有定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">//实例化文件必须为每个在其他文件中声明为extern 的类型和函数提供一个(非extern)的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;<span class="comment">//实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>

<p><strong>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
<h4 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h4><p><strong>在一个类模板的实例化定义中,所用类型必须能用于模板的所有成员函数。</strong></p>
<h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>unique_ptr避免了间接调用删除其的运行时开销，而shared_ptr使用户可以重载删除器。前者有效率，后者有灵活度。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li>const转换:可以将一个非 const对象的引用（或指针）传递给一个const的引用（或指针）形参。</li>
<li>数组或函数指针转换:如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T，T)</span></span>;<span class="comment">//实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 引用</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">s2</span> <span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);<span class="comment">//调用fobj(string,string); const被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);<span class="comment">//调用fref(const string&amp;, const string&amp;)</span></span><br><span class="line"><span class="comment">//将s1转换为const是允许的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b) ;</span><br><span class="line"><span class="comment">//调用f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a,b);</span><br><span class="line"><span class="comment">//错误:数组类型不匹配</span></span><br></pre></td></tr></table></figure>

<p>在最后一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针(参见6.2.4节，第195页)。a和 b的类型是不匹配的，因此调用是错误的。</p>
<p><strong>将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有const转换及数组或函数到指针的转换。</strong></p>
<h4 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h4><p>模板的参数只允许几种有限的类型转换，因此传递的这些形参必须具有相同的类型。我们的compare函数接受两个const T&amp;参数，其实参必须是相同类型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);<span class="comment">//错误:不能实例化compare (long, int)</span></span><br></pre></td></tr></table></figure>

<p>如果希望可以类型转换，可以将函数模板定义为两个类型参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span> <span class="params">(<span class="keyword">const</span> A&amp; v1,<span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vl&lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2&lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cout,<span class="number">42</span>); <span class="comment">//实例化print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span> <span class="params">( <span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span> (f，<span class="number">10</span>);<span class="comment">//使用print (ostream&amp;, int);将f转换为ostream&amp;</span></span><br></pre></td></tr></table></figure>

<p>第一个函数参数是一个已知类型ostream&amp;。第二个参数 obj 则是模板参数类型。由于os 的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换:</p>
<p><strong>如果函教参教类型不是模板参数，则对实参进行正常的类型转换。</strong></p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>某些时候模板参数无法推断除类型，允许用户控制模板实例化。</p>
<h4 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h4><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">Tl <span class="title">sum</span><span class="params">(T2，T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没有任何参数可供推断出T1的类型，所以调用时必须提供一个显示模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);<span class="comment">// long long sum(int，long)</span></span><br></pre></td></tr></table></figure>

<p>显式模板实参时一一对应的，只有右边的可以忽略，但必须可以从函数参数推断出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//糟糕的设计:用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span> <span class="params">(T2,T1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则我们总是必须为所有三个形参指定实参:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误:不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; (i, lng) ;<span class="comment">//正确:显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>，<span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>所以把需要显示提供的参数放在最前面</p>
<h4 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h4><p>如果模板类型参数已经显式指定，页可以进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng,<span class="number">1024</span>);					<span class="comment">//错误:模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare (long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt; (lng,<span class="number">1024</span>);			<span class="comment">//正确:实例化compare(int,int)</span></span><br></pre></td></tr></table></figure>

<p>第一个调用由于类型不匹配错误，后面的调用由于显式指定，而可以进行正常的类型转换。</p>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span> (It beg, It end)&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不知道返回结果的准确类型，但所需类型是所处理的序列的元素类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span> (vi.<span class="built_in">begin</span> (), vi.<span class="built_in">end</span>() ); 	<span class="comment">//fcn应该返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span> (ca.<span class="built_in">begin</span> (), ca.<span class="built_in">end</span>());		<span class="comment">// fcn应该返回string&amp;</span></span><br></pre></td></tr></table></figure>

<p>我们知道函数应该返回*beg，而且知道我们可以用decltype (*beg)来获取表达式类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg,It end)</span> -&gt; <span class="title">decitype</span> <span class="params">(*beg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h4><p>如果并不想返回引用而是返回其中的值，可以使用标准库<strong>类型转换</strong>模板。在头文件type_traits中，如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化 remove_reference&lt;int&amp;&gt;，则type 成员将是int。类似的，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string，依此类推。更一般的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span> (*beg) &gt;::type</span><br></pre></td></tr></table></figure>

<p>组合使用它们就可以在函数中返回元素值的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了使用模板参数的成员，必须用typename，参见16.1.3节（第593页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span> <span class="params">(It beg,It end)</span> -&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span> <span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg; <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/23/VcSsM9odI4FApYJ.png" alt="image.png"></p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>可以用一个函数模板对一个函数指针进行赋值，可根据形参生成一个实例，被指针所指：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> ( *pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<p>如果不能从函数指针类型却低估模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func的重载版本;每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*) (<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span> (compare); <span class="comment">//错误:使用compare的哪个实例?</span></span><br></pre></td></tr></table></figure>

<p>由于既可以接受int和string版本的compare，所以调用失败。不过可以显式的指出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确:显式指出实例化哪个compare版本</span></span><br><span class="line"><span class="built_in">func</span> (compare&lt;<span class="keyword">int</span>&gt;);<span class="comment">//传递compare (const int&amp;,const int&amp;)</span></span><br></pre></td></tr></table></figure>

<p><strong>当参数是一个函数模板实例的地址时,程序上下文必须满足:对每个模板参数,能唯一确定其类型或值。</strong></p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><h4 id="左值引用函数参数推断类型"><a href="#左值引用函数参数推断类型" class="headerlink" title="左值引用函数参数推断类型"></a>左值引用函数参数推断类型</h4><p>一个函数参数是模板类型参数的普通引用时，只能传递给它一个左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参必须是一个左值//对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line"><span class="built_in">f1</span>(i);<span class="comment">// i是一个int;模板参数类型T是int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">// ci是一个const int;模板参数T是const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>); <span class="comment">//错误:传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果是const T&amp;,则推断结果不会是一个const类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">//f2中的参数是const &amp; ;实参中的const是无关的</span></span><br><span class="line"><span class="comment">//在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i);<span class="comment">//i是一个int;模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">//ci是一个const int，但模板参数T是int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);<span class="comment">//一个const&amp;参数可以绑定到一个右值;T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h4><p>如果函数参数是右值引用，如T&amp;&amp;，推断出T的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp; &amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">//实参是一个int类型的右值;模板参数T是int</span></span><br></pre></td></tr></table></figure>

<h4 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h4><p>如果一个函数参数是指向模板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&amp;)。</p>
<h4 id="编写接受右值引用参数的模板函数"><a href="#编写接受右值引用参数的模板函数" class="headerlink" title="编写接受右值引用参数的模板函数"></a>编写接受右值引用参数的模板函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">	Tt = val; <span class="comment">//拷贝还是绑定一个引用?</span></span><br><span class="line">	t = <span class="built_in">fcn</span> (t) ; <span class="comment">//赋值只改变t还是既改变t又改变val?</span></span><br><span class="line">	<span class="keyword">if</span> (val == t)&#123;<span class="comment">/* ...*/</span> &#125;<span class="comment">//若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，如果传入42，则T会推断为int，但如果传入int的左值，则T会推断为int&amp;，则如果修改t的同时也会修改val。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; )</span> </span>;		<span class="comment">//绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;		<span class="comment">//左值和const右值</span></span><br></pre></td></tr></table></figure>

<p>通常是这样重载模板函数，与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>在13.6.2节中我们注意到，虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<h4 id="std-move如何定义"><a href="#std-move如何定义" class="headerlink" title="std::move如何定义"></a>std::move如何定义</h4><p>标准库的的move</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// static_cast是在4.11.3节（第145页）中介绍的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt; (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很短，但其中有些微妙之处。首先，move的函数参数T&amp; &amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span> <span class="params">( <span class="string">&quot;hi! &quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std: :<span class="built_in">move</span>(<span class="built_in">string</span> ( <span class="string">&quot;bye ! &quot;</span>) );<span class="comment">//正确:从一个右值移动数据</span></span><br><span class="line">s2 = std: :<span class="built_in">move</span>(sl);<span class="comment">//正确:但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>

<h4 id="std-move如何工作"><a href="#std-move如何工作" class="headerlink" title="std::move如何工作"></a>std::move如何工作</h4><p>如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型。因此，在<code>std: : move (string ( &quot;bye ! &quot;))</code>中:</p>
<ul>
<li>推断出的T的类型为string。</li>
<li>因此，remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp; 。</li>
<li>move的函数参数t的类型为string&amp; &amp;。</li>
</ul>
<p>因此，这个调用实例化move<string>，即函数<code>string&amp;&amp; move(string &amp;t)</code></p>
<h4 id="左值static-cast到右值引用时允许的"><a href="#左值static-cast到右值引用时允许的" class="headerlink" title="左值static_cast到右值引用时允许的"></a>左值static_cast到右值引用时允许的</h4><p>我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是const的以及实参是左值还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受一个可调用对象和另外两个参数的模板//对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现:顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f,T1 t1,T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用一个接受引用的参数就会出问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span><span class="comment">//注意v2是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;++v2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数第二个参数为引用，说明我们希望通过函数改变原变量的值，但是使用模板调用就会丢失这个引用的属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,i);			<span class="comment">//f改变了实参i</span></span><br><span class="line"><span class="built_in">flip1</span>(f,j,<span class="number">42</span>);		<span class="comment">//通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非int&amp;。因此，这个flip1调用会实例化为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn) (<span class="keyword">int</span>,<span class="keyword">int</span>&amp; ), <span class="keyword">int</span> t1,<span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h4><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值〉使得我们可以保持const属性,因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&amp;&amp;和 T2&amp;&amp;,通过引用折叠（参见 16.2.5节，第608页）就可以保持翻转实参的左值/右值属性（参见16.2.5节，第608页):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t2, t1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样调用就传递给t1一个左值j，t1会折叠为int&amp;，则t1会绑定到j上，就可以通过函数改变j的值。</p>
<p><strong>如果一个函数参数是指向模板类型参数的右值引用(如 T&amp;&amp;)，它对应的实参的const属性和左值/右值属性将得到保持。</strong></p>
<p>但是不能用于接受右值引用参数的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp; &amp;i, <span class="keyword">int</span>&amp; j)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传递一个右值给flip2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>);<span class="comment">//错误:不能从一个左值实例化int&amp; &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="std-forward保持类型信息"><a href="#std-forward保持类型信息" class="headerlink" title="std::forward保持类型信息"></a>std::forward保持类型信息</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line">	<span class="built_in">finalFcn</span> (std::forward&lt;Type&gt;(arg));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节。</strong></p>
<p>于是我们可以重写前面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tl,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f,T1 &amp; &amp;t1,T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">f</span> (std: :forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h4 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h4><p>首先编写俩个不同的函数模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	ostringstream ret;	<span class="comment">//参见8.3节（第287页)</span></span><br><span class="line">	ret &lt;&lt; t;			<span class="comment">//使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="built_in">str</span>(); 	<span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个对象对应string表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">//注意:此函数不能用于char*;参见16.3节（第617页)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p;	<span class="comment">//打印指针本身的值</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;<span class="built_in">debug_rep</span> (*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret &lt;&lt;<span class="string">&quot; null pointer&quot;</span> ;<span class="comment">//或指出 p为空</span></span><br><span class="line">	<span class="keyword">return</span> ret.<span class="built_in">str</span>();<span class="comment">//返回ret绑定的string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内容并不重要，我们先看使用它们：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">( <span class="string">&quot;hi&quot;</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>这个调用只有第一个版本是可行的，第二个版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。</p>
<p>如果用一个指针调用debug_rep</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(&amp;s) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>两个函数都生成可行的实例:</p>
<ul>
<li>debug rep(const string*&amp;)，由第一个版本的debug_rep实例化而来，T被绑定到string*。</li>
<li>debug rep(string*)，由第二个版本的 debug_rep实例化而来，T被绑定到string。</li>
</ul>
<p>但第二个版本更加精确，第一个版本需要进行普通指针到const的转换，编译器也会选择第二个版本。</p>
<h4 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span> (sp) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配:</p>
<ul>
<li><code>debug rep(const string*&amp;)</code>，由第一个版本的 debug_rep 实例化而来，T被绑定到<code>string*</code>。</li>
<li><code>debug rep(const string*)</code>，由第二个版本的 debug_rep 实例化而来，T被绑定到const string。</li>
</ul>
<p>再这种时候编译器会选择最特例化的，我的理解是，最简洁的，则选择第一个版本。</p>
<h4 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印双引号包围的string</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27; &quot;&quot; +s + &#x27;</span><span class="string">&quot;&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当同时匹配同样好的模板和非模板函数的时候，编译器一定会选择非模板版本。</p>
<h4 id="重载模板和类型转换"><a href="#重载模板和类型转换" class="headerlink" title="重载模板和类型转换"></a>重载模板和类型转换</h4><p>如果使用这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>) &lt;&lt; endl;<span class="comment">//调用debug_rep(T*)</span></span><br><span class="line"><span class="comment">//本例中所有三个debug _rep版本都是可行的:</span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> T&amp;)</span>，<span class="comment">//T被绑定到char [10]。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span><span class="params">(T*)</span>，<span class="comment">//T被绑定到const char。</span></span></span><br><span class="line"><span class="function">debug <span class="title">rep</span> <span class="params">(<span class="keyword">const</span> strina&amp;)</span>，<span class="comment">//要求从const char*到string 的类型转换。</span></span></span><br></pre></td></tr></table></figure>

<p>前两个版本都是匹配的，而第二个版本会被认为是精确匹配的，非模板版本是可行的，但需要一次用户定义的类型转换。所以选择第二个。</p>
<p>如果更希望使用字符版本，可以定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符指针转换为string，并调用string版本的 debug_reg</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span> (<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h4><p>为了使用<code>char*</code>版本的函数，必须提前准备好其中的模板函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *P)</span></span>;</span><br><span class="line"><span class="comment">//为了使debug_rep(char*)的定义正确工作，下面的声明必须在作用域中string debug_rep (const string &amp;);</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span> <span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function">i</span></span><br><span class="line"><span class="function"><span class="comment">//如果接受一个const string&amp;的版本的声明不在作用域中，</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回语句将调用debug_rep(const T&amp;)的T实例化为string 的版本return debug_rep(string(p) );</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</strong></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个<strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。存在两种参数包:<strong>模板参数包</strong>template parameter packet)，表示零个或多个模板参数;<strong>函数参数包</strong>（function parameteroacket)，表示零个或多个函数参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包; rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与往常一样，编译器从函数的实参推断模板参数类型。对于可变参数模板，编译器会推断保重的参数数目：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span> ;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>,d);	<span class="comment">//包中有三个参数</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="built_in">foo</span>(d,s);			<span class="comment">//包中有一个参数</span></span><br><span class="line"><span class="built_in">foo</span> ( <span class="string">&quot;hi&quot;</span>);		<span class="comment">//空包</span></span><br><span class="line"><span class="comment">//编译器会为foo实例化出四个不同的版本:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;，<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> string&amp;)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h4><p>若需要知道包中的运算符，使用sizeof…运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt;endl; <span class="comment">//类型参数的数目</span></span><br><span class="line">	cout&lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;		<span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>. . . Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;...rest)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;，&quot;</span>;			<span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>print (cout, i, s,42); //包中有两个参数</code>来调用上面的函数，首先会匹配到第二个函数，然后递归调用第二个函数，直至最后一个参数由第一个函数打印。</p>
<p><strong>当定义可变参数版本的 print时，非可变参数版本的声明必须在作用域中。否则,可变参数版本会无限递归。</strong></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>除了获取其大小以外，我们还可以<strong>扩展</strong>，我们还要提供扩展元素的<strong>模式</strong>。就时分解为构成的元素，在模式右边放一个省略号(…)触发扩展。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;<span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span> <span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span><span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);		<span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个扩展操作扩展模板参数包，为 print生成函数参数列表。第二个扩展操作出现在对print的调用中。此模式为print调用生成实参列表。</p>
<h4 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">	<span class="comment">//print (os,debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span> (os,<span class="built_in">debug_rep</span> (rest)... ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看这样的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将包传递给debug_rep; print (os，debug_rep(a1,a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os,<span class="built_in">debug_rep</span>(rest.. .) );<span class="comment">//错误:此调用无匹配函数</span></span><br></pre></td></tr></table></figure>

<p>它们的区别就是第一个对扩展包中的每一个调用函数，第二个是在调用中展开：</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;...)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员的定义，同13.5节（第465页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">chk_n_alloc</span>(); <span class="comment">//如果需要的话重新分配 StrVec内存空间</span></span><br><span class="line">	alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emplace_back的函数体调用了chk_n_alloc（参见13.5节，第465页）来确保有足够的空间容纳一个新元素，然后调用了construct在first_free 指向的位置中创建了一个元素。construct调用中的扩展为</p>
<p><code>std: : forward&lt;Args&gt;(args) ...</code><br>它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素</p>
<p><code>std::forward&lt;T&gt;(t)</code></p>
<p>其中T,表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如.假定svec是一个strVec，如果我们调用</p>
<p><code>svec.emplace_back (10,&#39;c&#39;);//将cccccccccc添加为新的尾元素</code></p>
<p>construct调用中的模式会扩展出</p>
<p><code>std::forward&lt;int&gt; (10), std::forward&lt;char&gt;(c)</code></p>
<p>通过在此调用中使用forward，我们保证如果用一个右值调用emplace back，则construct也会得到一个右值。例如，在下面的调用中:</p>
<p><code>svec.emplace back (s1 + s2);//使用移动构造函数</code></p>
<p>传递给emplace_back的实参是一个右值，它将以如下形式传递给construct</p>
<p><code>std: :forward&lt;string&gt; (string ( &quot;the end&quot; ))</code></p>
<p>forward<string>的结果类型是string&amp;&amp;，因此construct将得到一个右值引用实参。construct会继续将此实参传递给string 的移动构造函数来创建新元素。</p>
<p><strong>建议:转发和可变参数模板</strong></p>
<p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的emp lace_ back函数一样的形式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">(Args&amp;&amp;... args)</span> <span class="comment">//将Args扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// work的实参既扩展Args又扩展args</span></span><br><span class="line">	<span class="built_in">work</span>(std: : forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们希望将fun的所有实参转发给另一个名为work的函数,假定由它完成函数的实际工作。类似emplace_back中对 construct的调用,work调用中的扩展既扩展了模板参数包也扩展了函数参数包。<br>由于 fun的参数是右值引用,因此我们可以传递给它任意类型的实参;由于我们使用std:: forward传递这些实参，因此它们的所有类型信息在调用work时都会得到保持。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个版本;可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp; )</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们定义了另一个版本的compare，当传递给compare一个字符串字面常量或者一个数组时，编译器才会调用，而传递给它字符指针，就会调用第一个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span> ;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);<span class="comment">//调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>( <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;mom&quot;</span> );<span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>因为无法将指针转换为数组的引用，因此参数是p1和p2时，第二个版本compare不可行。</p>
<p>为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例化( template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<h4 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h4><p>特例化一个函数模板时，必须为每个模板参数提供实参，在template后跟&lt;&gt;，指出正在实例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个特例化版本时，函数的参数类型必须与先前模板中对应类型匹配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>特例化中T对应的为const char*，模板函数中为一个常量指针，而我们需要一个指向常量的指针，我们需要在特例化版本中使用的类型是const char * const &amp;，即一个指向const char的const指针的引用。</p>
<h4 id="函数重载与模板特例化"><a href="#函数重载与模板特例化" class="headerlink" title="函数重载与模板特例化"></a>函数重载与模板特例化</h4><p><strong>特例化的本质是实例化一个模板,而非重载它。因此,特例化不影响函数匹配。</strong></p>
<p><strong>关键概念:普通作用域规则应用于特例化</strong></p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且,在任何使用模板实例的代码之前,特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板,很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是,这种错误编译器又无法发现。</p>
<p><strong>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面,然后是这些模板的特例化版本。</strong></p>
<h4 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h4><p>我们将has模板定义一个特例化版本，用它保存Sale_data对象，为了让我们自己的数据类型能使用hash<key_type>，必须定义hash模板的一个特例化版本。一个特例化hash类必须定义:</p>
<ul>
<li>一个重载的调用运算符（参见14.8节，第506页)，它接受一个容器关键字类型的对象，返回一个size_t。</li>
<li>两个类型成员，result type和 argument_type，分别调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义，参见13.1.2节，第443页)。</li>
</ul>
<p>首先打开命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;<span class="comment">//我们正在定义一个特例化版本，模板参数为sales_data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Sales_data&gt; </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> sales_data argument_type;<span class="comment">// 默认情况下，此类型需要==</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> sales_data&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;string&gt;() (s.bookNo) ^</span><br><span class="line">            hash&lt;<span class="keyword">unsigned</span>&gt;() (s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="keyword">double</span>&gt;() (s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//关闭std命名空间;注意:右花括号之后没有分号</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十五章</title>
    <url>/2022/02/12/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p><strong>面向对象程序设计（object-oriented programming）</strong>的核心思想是<strong>数据抽象</strong>、<strong>继承</strong>和<strong>动态绑定</strong>。</p>
<ul>
<li>使用数据抽象，我们可以将类的接口与实现分离；</li>
<li>使用继承，可以定义相似的类型并对其相似关系建模；</li>
<li>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>通过<strong>继承（inheritance）</strong>联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类(base class)<strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为</strong>派生类( derived class)**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（ virtual function)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过使用类派生列表(class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是 : 首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="comment">//Bulk_quote继承了Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为使用public派生，所以可以使用基类成员，可以把Bulk quote的对象当成Quote的对象来使用。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>用它可以分别处理Quote和Bulk_quote的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据传入item形参的对象类型调用Quote::net_price</span></span><br><span class="line">    <span class="comment">//或者Bulk_quote::net_price</span></span><br><span class="line">	<span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;ISBN:&quot;</span> &lt;&lt; item.<span class="built_in">isbn</span> ()<span class="comment">//调用Quote: :isbn</span></span><br><span class="line">		&lt;&lt;<span class="string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>函数形参中的item是基类的引用，我们既可以使用基类的该函数，又可以使用派生类中的该函数，这回根据对象的类型决定执行哪一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// basic的类型是Quote; bulk的类型是Bulk_quote</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, basic,<span class="number">20</span>);			<span class="comment">//调用Quote的net_price</span></span><br><span class="line"><span class="built_in">print_total</span> (cout, bulk,<span class="number">20</span>);			<span class="comment">//调用Bulk quote的net price</span></span><br></pre></td></tr></table></figure>

<p>函数的运行版本由实参决定，所以动态绑定又被称为运行时绑定。</p>
<p><strong>在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。</strong></p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">//关于=default请参见7.1.4节（第 237页)</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> std::string &amp;book,<span class="keyword">double</span> sales_price) </span><br><span class="line">        : <span class="built_in">bookNo</span> (book), <span class="built_in">price</span>(sales_price)&#123; &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="comment">//返回给定数量的书籍的销售总额</span></span><br><span class="line">	<span class="comment">//派生类负责改写并使用不同的折扣计算算法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">					</span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span> () = <span class="keyword">default</span>;	<span class="comment">//对析构函数进行动态绑定</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string bookNo;				<span class="comment">//书籍的ISBN 编号</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;				<span class="comment">//代表普通状态下不打折的价格</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如此。</strong></p>
<h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>派生类需要提供自己新定义覆盖从基类而来的虚函数。任何希望在派生类中改变的函数定义为virtual，而不希望改变的直接定义为函数。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用<strong>受保护的( protected）</strong>访问运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须使用类派生列表指出从哪继承而来。派生类必须将继承类的虚函数重新声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;		<span class="comment">//Bulk_quote继承自Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span> (<span class="keyword">const</span> std::string&amp;,<span class="keyword">double</span>,std::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">//覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;		<span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span> ;			<span class="comment">//以小数表示的折扣额</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再派生类中使用public继承，所以回隐式包含isbn函数</p>
<h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类可以不覆盖它继承的虚函数，但必须重新声明：如果没有覆写，其行为类似其他的普通成员。</p>
<p>派生类可以再它覆盖的函数前使用virtual，可以在函数const关键字后添加override。</p>
<h4 id="派生类对象及派生类向基类转换"><a href="#派生类对象及派生类向基类转换" class="headerlink" title="派生类对象及派生类向基类转换"></a>派生类对象及派生类向基类转换</h4><p>派生类大致可以认为是这样分布：</p>
<p><img src="https://s2.loli.net/2022/02/15/wRpdlhZ4XqbNygO.png" alt="image.png"></p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote item;				<span class="comment">//基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">//p指向Quote对象</span></span><br><span class="line">p = &amp;bulk ;				<span class="comment">// p指向bulk 的 Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;		<span class="comment">// r绑定到bulk 的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>这种派生类到基类的转换回隐式的进行，所以可以将派生类的引用或指针用在基类引用或者指针上。</p>
<h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p>派生类构造函数可以调用基类的构造函数帮助建立自己的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std::string&amp; book,<span class="keyword">double</span> p,</span></span></span><br><span class="line"><span class="params"><span class="function">			std::<span class="keyword">size_t</span> qty,<span class="keyword">double</span> disc)</span>:</span></span><br><span class="line"><span class="function">			Quote(book, p), min_qty(qty), discount (disc)&#123;</span> &#125;</span><br><span class="line">		<span class="comment">//与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除非特别指出，否则派生类的所有成员都会执行默认初始化。编译器会首先初始化基类的部分，然后按顺序声明派生类的成员。</p>
<h4 id="派生类使用基类成员"><a href="#派生类使用基类成员" class="headerlink" title="派生类使用基类成员"></a>派生类使用基类成员</h4><p>派生类可以访问基类的公有成员和受保护成员:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt;= min_qty)</span><br><span class="line">		<span class="keyword">return</span> cnt *(<span class="number">1</span> - discount) * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员（例如min_qty和discount)的方式与使用基类成员（例如price）的方式没什么不同。</p>
<p><strong>关键概念:遵循基类的接口</strong><br>必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口,即使这个对象是派生类的基类部分也是如此。<br>派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了静态成员，则它在整个继承体系中只存在该成员的唯一定义。不论有几个派生，每个静态成员都只存在唯一实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span> <span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">const</span> Derived&amp;)</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmem</span> ();		<span class="comment">//正确:Base定义了statmem</span></span><br><span class="line">	Derived::<span class="built_in">statmem</span> ();	<span class="comment">//正确:Derived继承了statmem</span></span><br><span class="line">	<span class="comment">//正确:派生类的对象能访问基类的静态成员</span></span><br><span class="line">	derived_obj.<span class="built_in">statmem</span> () ;<span class="comment">//通过Derived对象访问</span></span><br><span class="line">	<span class="built_in">statmem</span> ();				<span class="comment">//通过this对象访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类声明方式和一般类一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote;<span class="comment">//错误:派生列表不能出现在这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>				<span class="comment">//正确:声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>

<h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>如果想将派生类作为基类，则必须已经被定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>;</span>				<span class="comment">//声明但未定义</span></span><br><span class="line"><span class="comment">//错误:Quote必须被定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>派生类包含从基类中来的成员，为了使用它们，必须先知道它们。也表明了一个类不能派生它本身。</p>
<p>一个类是基类，同时也可以是派生类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base &#123;<span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1 &#123;<span class="comment">/* ...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个继承关系中，Base是D1的**直接基类( direct base)<strong>，同时是D2的</strong>间接基类( indirectbase)**。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。</p>
<p>每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员;该直接基类的成员又含有其基类的成员;依此类推直至继承链的顶端。</p>
<h4 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h4><p>类名后加上final可防止类被继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span> <span class="comment">/** / &#125;;			//NoDerived不能作为基类</span></span><br><span class="line"><span class="comment">class Base &#123;/* */</span> &#125;;	</span><br><span class="line"><span class="comment">// Last是final的;我们不能继承</span></span><br><span class="line">Lastclass Last <span class="keyword">final</span> : Base &#123;<span class="comment">/**/</span> &#125;;		<span class="comment">// Last不能作为基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> NoDerived&#123;<span class="comment">/**/</span>&#125;;				<span class="comment">//错误:NoDerived是final的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> Last &#123;<span class="comment">/* */</span> &#125;;					<span class="comment">//错误: Last是final的</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>在继承关系的类中，基类的指针和引用可以绑定到派生类对象上，所以使用基类指针或者引用时，并不清楚绑定对象的真实类型。</p>
<p><strong>和内置指针一样,智能指针类也支持派生类向基类的类型转换,这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</strong></p>
<h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><p>在继承关系中必须区分两种类型，表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型，动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当print_total调用net_price 时(参见15.1节，第527页):</span></span><br><span class="line"><span class="keyword">double</span> ret = item.<span class="built_in">net_price</span> (n) ;</span><br></pre></td></tr></table></figure>

<p>item在前面时用Quote&amp;去定义的，那么Quote&amp;就是item的静态类型，动态类型知道在运行时调用该函数才会知道。如果传递一个Bulk_quote对象给print_total，则item的动态类型于静态类型不一致。只有引用和指针动态和静态类型才会不一致。</p>
<h4 id="不存在基类想派生类的隐式类型转换"><a href="#不存在基类想派生类的隐式类型转换" class="headerlink" title="不存在基类想派生类的隐式类型转换"></a>不存在基类想派生类的隐式类型转换</h4><p>派生类可以向基类转换是因为每一个派生类对象都包含一个基类的部分。所以一个基类对象既可以独立存在可以作为派生类的一部分存在。但任何派生类对象都不可以向基类隐式的转换，包括引用和指针。</p>
<p><strong>总结</strong>：要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样,派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节（第544页)详细介绍可访问性的问题。</li>
</ul>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在我们使用基类的引用或指针调用虚函数时会执行动态绑定。因为知道运行时才知道调用了哪个版本，所以所有的虚函数都必须有定义，不论它是否被用到。</p>
<h4 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h4><p>虚函数执行哪个版本完全依赖于运行时绑定到其对象的实际动态类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, base, <span class="number">10</span>);			<span class="comment">//调用Quote::net price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">derived</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">.19</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, derived, <span class="number">10</span>);			<span class="comment">//调用Bulk_quote::net_price</span></span><br></pre></td></tr></table></figure>

<p>依据调用对象的不同，会调用两种不同的函数。此外动态绑定也只有当通过指针或引用调用虚函数才会发生：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">base = derived;			<span class="comment">//把derived的Quote部分拷贝给base</span></span><br><span class="line">base.<span class="built_in">net_price</span> (<span class="number">20</span>);	<span class="comment">//调用Quote::net price</span></span><br></pre></td></tr></table></figure>

<p><strong>关键概念:C++的多态性</strong><br>OOP的核心思想是多态性（polymorphism)。多态性这个词源自希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型,因为我们能使用这些类型的“多种形式”而无须在意它们的差异。<strong>引用或指针的静态类型与动态类型不同</strong>这一事实正是C++语言支持多态性的根本所在。</p>
<p>当我们使用基类的引用或指针调用基类中定义的一个函数时,我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本,判断的依据是引用或指针所绑定的对象的真实类型。</p>
<p>另一方面,对非虚函数的调用在编译时进行绑定。类似的,通过对象进行的函数(虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此,通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。</p>
<p><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</strong></p>
<h4 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>当我们在派生类中可以再一次使用virtual关键字指出函数的性质。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参、返回类型必须与被覆盖的基类函数完全一致。有一个例外是当类的虚函数返回类型是类本身的指针和引用时，规则无效：也就是说，如果D由B派生得到，则基类的虚函数可以返回B<code>*</code>而派生类的对应函数可以返回D<code>*</code>，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
<h4 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h4><p>我们使用override来覆盖继承而来的虚函数，但该函数并没有覆盖已存在的虚函数，此时编译器将会报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span> <span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;		<span class="comment">//正确:f1与基类中的f1匹配</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;				<span class="comment">//错误:B没有形如2 (int)的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:f3不是虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//错误:B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">	<span class="comment">//从B继承f2()和f3 ()，覆盖f1 (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;<span class="comment">//不允许后续的其他类覆盖f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 正确:覆盖从间接基类B继承而来的f2</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//错误:D2已经将f2声明成final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>final和 override说明符出现在形参列表(包括任何const或引用修饰符）以及尾置返回类型之后。</strong></p>
<h4 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h4><p>虚函数可以有默认实参，如果某次函数调用使用默认实参，则实参值由静态类型决定：</p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。</p>
<p><strong>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>
<h4 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h4><p>如果希望虚函数调用不要进行动态绑定，而是强迫其执行某个版本，可以使用作用域运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>此代码在编译时就可以完成解析</p>
<p><em>通常情况下,只有成员函数(或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。</em></p>
<p><em>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归</em></p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>我们可以将一个函数定义为纯虚函数，这样做的目的时为了告诉用户，当前此函数没有任何意义，所以它无需定义，通过在函数体位置添加=0就可以声明一个纯虚函数，它只能出现在类内部虚函数声明语句处：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Disc_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">		std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Quote</span>(book, price),</span><br><span class="line">		<span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//折扣适用的购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount - <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//表示折扣的小数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<h4 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h4><p>含有纯虚函数的类是<strong>抽象基类</strong>，这种类只负责定义接口，后续的其他类可以覆盖接口，我们不可以直接创建一个抽象基类的对象，因为此时的其中的纯虚函数并没有被定义，我们可以在派生类中覆盖此函数，然后就可以创建派生类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></span><br><span class="line">Disc_quote discounted;		<span class="comment">//错误:不能定义 Disc quote的对象</span></span><br><span class="line">Bulk_quote bulk;			<span class="comment">//正确:Bulk quote中没有纯虚函数</span></span><br></pre></td></tr></table></figure>

<p>如果不给出纯虚函数的定义，它任然是抽象基类。</p>
<h4 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h4><p>重新实现Bulk_quote，让它继承Disc_quote：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当同一书籍的销售量超过某个值时启用折扣</span></span><br><span class="line"><span class="comment">//折扣的值是一个小于1的正的小数值，以此来降低正常销售价格</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span><br><span class="line">			std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">		<span class="built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;;<span class="comment">//覆盖基类中的函数版本以实现一种新的折扣策略</span></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std : : <span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的 Bulk_quote 的直接基类是 Disc_quote，间接基类是 Quote。每个Bulk quote对象包含三个子对象:一个(空的)Bulk_quote部分、一个 Disc_quote子对象和一个Quote子对象。</p>
<p>每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，也必须提供构造函数，在构造函数中调用直接基类的构造函数，进而继续调用间接基类 的构造函数。</p>
<p><strong>关键概念:重构</strong><br>在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。</p>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<p>值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。</p>
<h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问</strong>（ accessible)。</p>
<h4 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h4><p>如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是 public和 private 中和后的产物:</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;						<span class="comment">// protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky: :prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">//不能访问Base: :prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//正确:clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误:clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp; b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>例子中派生类成员函数使用基类对象访问受保护的成员是不可行的。</p>
<h4 id="公有、私有、受保护继承"><a href="#公有、私有、受保护继承" class="headerlink" title="公有、私有、受保护继承"></a>公有、私有、受保护继承</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// public成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">	<span class="comment">// protected成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> priv_mem;</span><br><span class="line">	<span class="comment">// private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="comment">// 正确:派生类能访问protected成员int f() &#123; return prot_mem; &#125;</span></span><br><span class="line">	<span class="comment">//错误:private成员对于派生类来说是不可访问的char g() &#123; return priv_mem;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">// 依旧不能访问</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生访问说明符对派生类的成员（及友元）能否访问直接基类成员没有影响。访问权限只与基类中的访问说明符有关。派生类只能访问直接基类的受保护的与共有的成员。</p>
<p>派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内）对于基类成员的访问权限，概括来说：</p>
<ul>
<li>如果是共有继承，那么继承而来的成员访问等级不变。</li>
<li>受保护继承，继承而来的访问等级上升一级，public变为protect。</li>
<li>私有继承，所有继承成员访问等级上升到最高，及全部为private</li>
</ul>
<h4 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h4><p>派生类向基类的转换（参见15.2.2 节，第530页)是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B:</p>
<ul>
<li>只有当D 公有地继承B时，用户代码才能使用派生类向基类的转换;如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换;派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换;反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<p><strong>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的;反之则不行。</strong></p>
<p><strong>关键概念:类的设计与受保护的成员</strong><br>不考虑继承的话,我们可以认为一个类有两种不同的用户:普通用户和类的实现者。</p>
<p>其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有(实现)部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的。</p>
<h4 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h4><p>就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="comment">//添加friend声明，其他成员与之前的版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span>			<span class="comment">// Pal在访问Base的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; 		<span class="comment">//正确: Pal是 Base的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;			<span class="comment">//错误: Pal不是Sneaky的友元</span></span><br><span class="line">    <span class="comment">//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125;		<span class="comment">//正确: Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在f2中j是Sneaky成员而不是Base成员，由于pal只是Base的友元所以不能访问其派生类成员。而f3访问的是Sneaky中的Base成员所以可以访问。</p>
<p>当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// D2对Base 的 protected和private成员不具有特殊的访问能力class D2 : public Pal &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b.prot_mem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//错误:友元关系不能继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h4><p>使用using声明可以改变和继承某个名字的访问级别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std : : <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std : : <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">//注意:private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base : : size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base : : n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>using使得不论如何继承而来的成员在保持using前一个访问说明符的访问等级，如size是public，n是protect。但是派生的类只能为可以访问的名字提供using声明</p>
<h4 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h4><p>默认情况下class定义派生类是私有继承，而struct是共有继承。但更建议显示的声明出来。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p><strong>派生类的作用域嵌套在基类内</strong>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt;bulk.<span class="built_in">isbn</span> () ;</span><br></pre></td></tr></table></figure>

<p>名字isbn的解析将按照下述过程所示:</p>
<ul>
<li>因为我们是通过Bulk_quote的对象调用isbn的，所以首先在Bulk_quote中查找，这一步没有找到名字isbn</li>
<li>因为Bulk quote是 Disc quote 的派生类，所以接下来在 Disc_quote 中查找，仍然找不到。</li>
<li>因为 Disc_quote是 Quote的派生类，所以接着查找Quote;此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中的isbn。</li>
</ul>
<h4 id="编译时进行名字查找"><a href="#编译时进行名字查找" class="headerlink" title="编译时进行名字查找"></a>编译时进行名字查找</h4><p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况)，但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p>这是因为当使用基类指针时，可使用的成员已经确定，如果使用它绑定一个派生类对象，且派生类对象又新增了几个成员，此时对于这个指针来说，它并不知道这些多出来的成员，自然也无法使用它们。</p>
<h4 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h4><p>如果派生类中定义了其基类同名的成员，那么此成员将会隐藏基类中的同名成员，就像局部变量被优先使用。主要还是因为派生类的作用域嵌套在基类内。</p>
<h4 id="通过作用域运算符使用隐藏成员"><a href="#通过作用域运算符使用隐藏成员" class="headerlink" title="通过作用域运算符使用隐藏成员"></a>通过作用域运算符使用隐藏成员</h4><p>通过在同名成员前加上作用域就可以调用它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base : :mem;&#125; <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>建议还是不要同名。</p>
<p>*<em>关键概念:名字查找与继承</em><br>理解函数调用的解析过程对于理解C++的继承至关重要,假定我们调用p-&gt;mem ()（或者obj .mem())，则依次执行以下4个步骤:</p>
<ul>
<li>首先确定p(或obj)的静态类型。因为我们调用的是一个成员,所以该类型必然是类类型。</li>
<li>在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到,则编译器将报错。</li>
<li>一旦找到了mem,就进行常规的类型检查(参见6.1节,第183页)以确认对于当前找到的 mem，本次调用是否合法。</li>
<li>假设调用合法,则编译器将根据调用的是否是虚函数而产生不同的代码:<ul>
<li>如果 mem是虚函数且我们是通过引用或指针进行的调用,则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用,则编译器将产生一个常规函数调用。</li>
</ul>
</li>
</ul>
<h4 id="一如既往，名字查找先于类型检查"><a href="#一如既往，名字查找先于类型检查" class="headerlink" title="一如既往，名字查找先于类型检查"></a>一如既往，名字查找先于类型检查</h4><p>如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类(即内层作用域）的成员与基类（即外层作用域)的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致。</p>
<h4 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h4><p>现在可以理解为什么基类与派生类的虚函数必须有相同的形参列表了，如果不相同就会隐藏同名成员，而不是覆写。不然就无法通过基类引用或指针访问派生类的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//隐藏基类的fcn，这个fcn不是虚函数</span></span><br><span class="line">    <span class="comment">// D1继承了Base : :fcn ()的定义</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//形参列表与Base 中的fcn不一致</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//是一个新的虚函数，在 Base中不存在</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">//是一个非虚函数，隐藏了D1 : : fcn (int)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;		<span class="comment">//覆盖了Base的虚函数fcn</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">//覆盖了D1的虚函数f2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过基类调用隐藏的虚函数"><a href="#通过基类调用隐藏的虚函数" class="headerlink" title="通过基类调用隐藏的虚函数"></a>通过基类调用隐藏的虚函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1l = &amp;bobj, * bp2 = &amp;dlobj, * bp3 = &amp;d2obj; </span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用，将在运行时调用 Base : : fcn</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用 Base : : fcn</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();			<span class="comment">//虚调用,将在运行时调用D2 : :fcn</span></span><br><span class="line">D1* dlp = &amp;dlobj; D2* d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;<span class="built_in">f2</span>();			<span class="comment">//错误:Base没有名为f2的成员</span></span><br><span class="line">dlp-&gt;<span class="built_in">f2</span>();			<span class="comment">//虚调用，将在运行时调用D1 : :f2()</span></span><br><span class="line">d2p-&gt;<span class="built_in">f2</span>();			<span class="comment">// 虚调用，将在运行时调用D2: : f2()</span></span><br></pre></td></tr></table></figure>

<p>对于调用非虚函数，并不会发生动态绑定，由指针的类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *pl = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//错误:Base中没有接受一个int的fcn</span></span><br><span class="line">p2-&gt;<span class="built_in">fcn</span> (<span class="number">42</span>);			<span class="comment">//静态绑定，调用D1 : :fcn(int)</span></span><br><span class="line">p3-&gt;<span class="built_in">fcn</span> ( <span class="number">42</span>);			<span class="comment">//静态绑定，调用D2 : :fcn (int)</span></span><br></pre></td></tr></table></figure>

<h4 id="覆盖重载函数"><a href="#覆盖重载函数" class="headerlink" title="覆盖重载函数"></a>覆盖重载函数</h4><p>和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。</p>
<p>一种好的解决方案是为重载的成员提供一条using声明语句（参见15.5节，第546页)，这样我们就无须覆盖基类中的每一个重载版本了。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见15.2.1节，第528页)，这样我们就能动态分配继承体系中的对象了。</p>
<p>当delete一个动态分配的对象的指针时执行析构函数，但如果指针指向了其“子孙”，则有可能出现指针静态类型与被删除对象的动态类型不符。所以必须在基类中将析构函数定义为析构函数保证函数的执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;		<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如果基类的析构函数不是虚函数,则delete一个指向派生类对象的基类指针将产生未定义的行为。</strong></p>
<p>在之前的准则中：如果一个类需要一个析构函数，那么它同样也需要拷贝和赋值操作。但基类的析构是一个重要的例外。它的虚函数并没有内容所以可以没有其他操作。</p>
<h4 id="虚析构函数阻止合成移动"><a href="#虚析构函数阻止合成移动" class="headerlink" title="虚析构函数阻止合成移动"></a>虚析构函数阻止合成移动</h4><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>这里的合成的拷贝，赋值或析构与普通类似，</p>
<p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构<br>函数类似:它们对类本身的成贝依城优对一个对象的直接基类部分进行初始化、赋值或销成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如，</p>
<ul>
<li>合成的Bulk quote默认构造函数运行Disc_quote 的默认构造函数，后者又运行Quote的默认构造函数。</li>
<li>Quote 的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0。</li>
<li>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化 qty和discount。</li>
<li>Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它什么具体工作也不做。</li>
</ul>
<p>拷贝构造也是类似，此外基类成员是合成或自定义都没有影响，但唯一的要求是成员应该可以访问比关切不是被删除的。</p>
<p>如前所述，Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作。如我们即将看到的那样，Quote没有移动操作意味着它的派生类也没有。</p>
<h4 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h4><ul>
<li>如果基类中基础操作（构造、拷贝。。。）是删除的函数或不可访问，那么派生类对应的成员也是被删除的，因为派生类不能通过这些基类成员来为基类执行这些操作。</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</li>
<li>和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>();</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">//其他成员，不含有移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">	<span class="comment">//没有声明任何构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D d;					<span class="comment">//正确:D的合成默认构造函数使用B的默认构造函数</span></span><br><span class="line"><span class="function">D <span class="title">d2</span><span class="params">(d)</span></span>;				<span class="comment">//错误:D的合成拷贝构造函数是被删除的</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std: : move(d))</span></span>;	<span class="comment">//错误:隐式地使用D的被删除的拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h4><p>如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦 Quote定义了自己的移动操作，那么它必须同时显式地定义铂贝操作（参见13.6.2节，第476页):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次进行默认初始化</span></span><br><span class="line">	<span class="built_in">Quote</span>(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//对成员依次拷贝</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//移动赋值virtual ~Quote() = default;</span></span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数不仅仅要负责自己的成员初始化还有基类成员。而析构函数只负责销毁派生类自己分配的资源</p>
<p><strong>当派生类定义了拷贝或移动操作时,该操作负责铂贝或移动包括基类部分成员在内的整个对象。</strong></p>
<h4 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h4><p>派生类拷贝或移动构造通常是应用对应的基类构造来初始化对象的基类部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中</span></span><br><span class="line">    <span class="comment">//显式地调用该构造函数</span></span><br><span class="line">	<span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d) : <span class="built_in">Base</span>(d)</span><br><span class="line">		<span class="comment">//拷贝基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ...*/</span>	&#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">Base</span>(std : : <span class="built_in">move</span>(d))<span class="comment">//移动基类成员</span></span><br><span class="line">		<span class="comment">/* D的成员的初始值*/</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将D类型的对象d传递给基类的拷贝构造函数。这个构造负责将d的基类部分拷贝给要创建的对象。如果d并没有基类初始值，则默认初始化。</p>
<p><strong>在默认情况下,基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝(或移动)构造函数。</strong></p>
<h4 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h4><p>派生类的赋值运算符也必须显示地为其基类部分赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base: : operator=(const Base&amp;)不会被自动调用</span></span><br><span class="line">D D: :<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base: :<span class="keyword">operator</span>=(rhs); <span class="comment">//为基类部分赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类的成员赋值</span></span><br><span class="line">	<span class="comment">//酌情处理自赋值及释放已有资源等情况return *this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用基类的赋值操作无论基类的构造函数或赋值运算符是合成还是自定义，派生类的对应操作都能够使用它们。</p>
<h4 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h4><p>派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Base : : ~Base被自动调用执行</span></span><br><span class="line">	~<span class="built_in">D</span>() &#123;<span class="comment">/*该处由用户定义清除派生类成员的操作*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象销毁的顺序与创建的顺序相反。从子孙到祖先。</p>
<h4 id="在构造和析构函数中调用虚函数"><a href="#在构造和析构函数中调用虚函数" class="headerlink" title="在构造和析构函数中调用虚函数"></a>在构造和析构函数中调用虚函数</h4><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>一个类只能初始化的直接基类，一个类也只能继承其直接类的构造函数。类不能默认继承默认的拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为派生类合成。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。举个例子，我们可以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote : : Disc_quote;<span class="comment">//继承Disc_quote的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std: :<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>生成的构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">derived</span> (parms) : <span class="built_in">base</span> (args)&#123; &#125;</span><br><span class="line"><span class="comment">//在我们的 Bulk_quote类中，继承的构造函数等价于:</span></span><br><span class="line"><span class="function">Bulk <span class="title">quote</span><span class="params">(<span class="keyword">const</span> std : : string &amp; book, <span class="keyword">double</span> price,</span></span></span><br><span class="line"><span class="params"><span class="function">	std : : <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc)</span> :</span></span><br><span class="line"><span class="function">	Disc quote(book, price, qty, disc) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。</p>
<h4 id="继承的构造函数的特点"><a href="#继承的构造函数的特点" class="headerlink" title="继承的构造函数的特点"></a>继承的构造函数的特点</h4><p>和普通using不一样的是，构造函数的using声明不会改变构造函数的访问级别，且using声明也不能指定exlicit或者constexpr。继承的构造函数会具有相同的属性。</p>
<p>当基类的构造函数含有默认的实参时，这些实参并不会被继承，相反的是，派生类会获得多个继承的构造函数，每个构造函数分别省略掉由默认实参的形参。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p><strong>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”,因此容器和存在继承关系的类型无法兼容。</strong></p>
<h4 id="在容器中放置智能指针而非对象"><a href="#在容器中放置智能指针而非对象" class="headerlink" title="在容器中放置智能指针而非对象"></a>在容器中放置智能指针而非对象</h4><p>容器中防止继承关系的对象时，通常存放的是基类的指针（智能指针更好）。</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>我们定义一个表示购物篮的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Basket使用合成的默认构造函数和拷贝控制成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; sale)</span> </span>&#123; items.<span class="built_in">insert</span>(sale); &#125;</span><br><span class="line">	<span class="comment">//打印每本书的总价和购物篮中所有书的总价</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(std : : ostream&amp;)</span><span class="keyword">const</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//该函数用于比较shared_ptr，multiset成员会用到它</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> std : : shared_ptr&lt;Quote&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs-&gt;<span class="built_in">isbn</span>() &lt; rhs-&gt;<span class="built_in">isbn</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//multiset保存多个报价，按照compare成员排序</span></span><br><span class="line">	std::multiset&lt;std::shared ptr&lt;Quote&gt;, <span class="keyword">decltype</span> (compare)*&gt; items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的类使用一个multiset（参见11.2.1节，第377页)来存放交易信息，这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在一起（参见11.2.2节，第 378页)。</p>
<p>这个声明看起来不太容易理解，但是从左向右读的话，我们就能明白它其实是定义了一个指向Quote对象的shared ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。multiset成员的名字是 items，我们初始化items并令其使用我们的compare函数。</p>
<h4 id="定义Basket的成员"><a href="#定义Basket的成员" class="headerlink" title="定义Basket的成员"></a>定义Basket的成员</h4><p>这个成员的名字是total_receipt，它负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> Basket : : <span class="built_in">total_receipt</span>(ostream&amp; os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0.0</span>;		<span class="comment">//保存实时计算出的总价格</span></span><br><span class="line">	<span class="comment">// iter指向ISBN相同的一批元素中的第一个</span></span><br><span class="line">	<span class="comment">// upper_bound返回一个迭代器，该迭代器指向这批元素的尾后位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = items.<span class="built_in">cbegin</span>();</span><br><span class="line">			iter != items.<span class="built_in">cend</span>();</span><br><span class="line">			iter = items.<span class="built_in">upper_bound</span>(*iter))&#123;</span><br><span class="line">		<span class="comment">//我们知道在当前的Basket中至少有一个该关键字的元素</span></span><br><span class="line">        <span class="comment">//打印该书籍对应的项目</span></span><br><span class="line">		sum += <span class="built_in">print_total</span>(os, **iter, items.<span class="built_in">count</span>(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;Total sale: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//打印最终的总价格</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的for循环中upper函数会跳过相同的书直接指到下一种书。此外在print_total函数中，第二个参数第一次解引用得到一个指向该对象的指针指针，再一次解引用才能得到这个Quto对象（或派生对象）。使用multiset统计有多少个相同元素。</p>
<h4 id="隐藏指针"><a href="#隐藏指针" class="headerlink" title="隐藏指针"></a>隐藏指针</h4><p>接下的需要定义add_item成员，先看使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.<span class="built_in">add_item</span> (make_shared&lt;Quote&gt; ( <span class="string">&quot;123&quot;</span>,<span class="number">45</span>));</span><br><span class="line">bsk,<span class="built_in">add_item</span> (make_shared&lt;Bulk_quote&gt; (<span class="string">&quot;345&quot;</span>，<span class="number">45</span>，<span class="number">3</span>，<span class="number">.15</span>));</span><br></pre></td></tr></table></figure>

<p>下一步重新定义add_item使它接受一个Quote对象而非shared_ptr，新版本的add_item将负责内存的分配。定义两个版本，一个拷贝它给定的对象，另一个采取移动操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span> </span>;			<span class="comment">//拷贝给定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span> <span class="params">(Quote&amp;&amp; sale)</span> </span>;				<span class="comment">//移动给定的对象</span></span><br></pre></td></tr></table></figure>

<p>此时遇到的问题是，函数不知道分配的类型，若<code>new Quote(sale)</code>，则可能不正确，传入其派生类的对象时，会被切掉一部分。</p>
<h4 id="模拟虚拷贝"><a href="#模拟虚拷贝" class="headerlink" title="模拟虚拷贝"></a>模拟虚拷贝</h4><p>我们给Quote添加一个虚函数，函数申请一份当前对象的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">	<span class="comment">//这些成员使用的引用限定符参见13.6.3节（第483页)</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">							</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span>(std : : <span class="built_in">move</span> (*<span class="keyword">this</span>)); &#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line">	<span class="function">Bulk_quote* <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span> &amp; <span class="params">(<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (*<span class="keyword">this</span>); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    Bulk_quote* clone () &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">						&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote (std: : move ( *<span class="keyword">this</span>)) ;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">//其他成员与之前的版本一致</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<p>因为我们拥有add_item的拷贝和移动版本，所以我们分别定义clone的左值和右值版本。</p>
<p>使用clone写出新版的add_item:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span>	<span class="comment">//拷贝给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(std: :shared_ptr&lt;Quote&gt;(sale.<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span>		<span class="comment">//移动给定的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		items.<span class="built_in">insert</span>(</span><br><span class="line">			std: :shared_ptr&lt;Quote&gt;(std: :<span class="built_in">move</span>(sale).<span class="built_in">clone</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clone根据作用与左值右值分不同的版本，add_item也有调用不同版本的重载。Sale的动态类型决定了运行Quote还是Bulk_quote函数。然后为这个对象绑定智能指针放在容器内。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer文本查询程序</title>
    <url>/2022/02/07/C++%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>​        此为C++ Primer中第十二章中的一个文本查询程序，我想通过自己的分析来更加透彻的理解整个程序的设计，于是将此节单独作为一章重点去看：</p>
<h1 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h1><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>当程序读取输入文件时，它必须记住单词出现的每一行。因此，程序需要逐行读取输入文件，并将每一行分解为独立的单词</li>
<li>当程序生成输出时，<ul>
<li>它必须能提取每个单词所关联的行号</li>
<li>行号必须按升序出现且无重复</li>
<li>它必须能打印给定行号中的文本。</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>当输入element时，得到的是：</p>
<p><img src="https://s2.loli.net/2022/02/07/7ANskrKFnG3qV1o.png" alt="image.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​        首先看这里我认为最重要一个对应关系，单词→行号。每一个单词都有n行与之对应，那么容易想到的方法是用容器将每个单词的行号记录下来，由于每个行号只出现一次且需要升序排列，所以最优解就是使用set容器，接着如何实现通过行号找到那一行文字呢？我们可以想到使用<code>vector&lt;string&gt;</code>按行号保存文本。此外使用一个map可以将单词与它对应的set容器绑定起来，就可以实现，单词对应行号，行号对应文本。</p>
<p>​        还有一个问题是：如何建立起这个map和set，我们定义一个函数，命名为istringstream，思路大致是从vector<string>读取每个元素（每行文本），访问每个单词前首先判断map中没有这个单词，如果有：就将对应的set中加入这一次遍历的下标（即行号），如果没有：就创建一个set，并将单词与set加入map中。</p>
<h3 id="大致的类"><a href="#大致的类" class="headerlink" title="大致的类"></a>大致的类</h3><p>​        我们需要将这些结构与操作串联起来，从定义一个保存输入文件的类开始，将类命名为TextQuery，它包含一个vector和一个map。我们用这个类来构造vector和map，并且执行查询操作。</p>
<p>​        之后如果我们查到了到底要返回什么呢？返回那么一大串的东西最好的方法就是定义另一个类，这个类内应该有一个打印操作。我们将它命名为QueryResult。</p>
<h3 id="类之间的数据共享"><a href="#类之间的数据共享" class="headerlink" title="类之间的数据共享"></a>类之间的数据共享</h3><p>​        再仔细看一下这个QueryResult类，由于我们必须要返回文本，所以要用到提到过的保存整个文本的vector，然而它是第一类的成员，我们拷贝一份貌似没有必要，因为我们只需要调用其中很小的一部分，这样会造成大量的浪费，那么使用一个类内的迭代器（或指针）可以嘛？答案也是不行，因为如果第一个类在第二个类之前销毁，那么打印操作就会访问一个不存在的对象中的数据。最好的办法就是使用我们“最牛逼”的shared_ptr来反映数据结构中的共享关系。</p>
<h3 id="设计类之前先使用类"><a href="#设计类之前先使用类" class="headerlink" title="设计类之前先使用类"></a>设计类之前先使用类</h3><p>​        当我们设计一个类时，在真正实现成员之前先编写程序使用这个类，是一种非常有用的方法。通过这种方法，可以看到类是否具有我们所需要的操作。例如，下面的程序使用了TextQuery和 QueryResult类。这个函数接受一个指向要处理的文件的ifstream，并与用户交互，打印给定单词的查询结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//infile是一个ifstream，指向我们要处理的文件</span></span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>; 	<span class="comment">//保存文件并建立查询map</span></span><br><span class="line">	<span class="comment">//与用户交互:提示用户输入要查询的单词，完成查询并打印结果</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;enter word to look for, or q to quit: &quot;</span>;</span><br><span class="line">		string s;</span><br><span class="line">		<span class="comment">//若遇到文件尾或用户输入了&#x27;q&#x27;时循环终止</span></span><br><span class="line">		<span class="keyword">if</span>(!(cin &gt;&gt; s) || s == <span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//指向查询并打印结果</span></span><br><span class="line">		<span class="built_in">print</span>(cout, tq.<span class="built_in">query</span>(s)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><h3 id="TextQuery框架"><a href="#TextQuery框架" class="headerlink" title="TextQuery框架"></a>TextQuery框架</h3><p>​        首先是TextQuery，用用户提供的一个istream读取文件，类中应该还有query操作，接受string，返回QueryResult表示string出现的行。我们创建一个头文件命名为textquery，在其中输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEXTQUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXTQUERY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span><span class="comment">// 为了定义函数query的返回类型，这个定义是必需的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//简化行下标</span></span><br><span class="line">	<span class="keyword">using</span> line_no = vector&lt;string&gt;::size_type;</span><br><span class="line">	<span class="comment">//通过用户提供的文本的构造函数</span></span><br><span class="line">	<span class="built_in">TextQuery</span>(std::ifstream&amp;);</span><br><span class="line">	<span class="comment">//返回查询结果的函数，由于只是查询所以应该加上const</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> string&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//输入的文件</span></span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;</span><br><span class="line">	<span class="comment">//每个单词到它所在的行号的集合的映射</span></span><br><span class="line">	std::map&lt;string, shared_ptr&lt;std::set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​        至于这里为什么出现这么多的std，而不是直接引入整个命名空间：在头文件这样做是非常危险的，由于C++头文件通常与源文件分开存放，对于不知道这个头文件里有什么的用户来说，使用这个头文件就有可能会导致很多的命名冲突。这里建议在任何文件中都不要这样做。</p>
<h3 id="QueryResult框架"><a href="#QueryResult框架" class="headerlink" title="QueryResult框架"></a>QueryResult框架</h3><p>​        QueryResult类有三个数据成员：一个string，保存查询单词：一个shared_ptr，指向保存输入文件的vector；一个shared ptr，指向保存单词出现行号的set。它唯一的一个成员函数是一个构造函数，初始化这三个数据成员。在刚才的类之后，紧接着写入以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">    <span class="comment">//将ostream声明为友元函数，之后用来打印结果</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">QueryResult</span>(string s,</span><br><span class="line">		shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; p,</span><br><span class="line">		shared_ptr&lt;vector&lt;string&gt;&gt; f) :</span><br><span class="line">		<span class="built_in">sought</span>(s), <span class="built_in">lines</span>(p), <span class="built_in">file</span>(f) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 查询单词</span></span><br><span class="line">	string sought; 							</span><br><span class="line">    <span class="comment">//出现的行号</span></span><br><span class="line">	shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; lines;</span><br><span class="line">    <span class="comment">//输入文件</span></span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;		 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里为什么不在TextQuery类之前那里写呢？因为这个类中我们用到了TextQuery中的line_no，这两个类其实是你中有我，我中有你的关系，所以我们在开头需要一个声明，在之后去定义他。</p>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><h3 id="TextQuery构造函数"><a href="#TextQuery构造函数" class="headerlink" title="TextQuery构造函数"></a>TextQuery构造函数</h3><p>接下来是类的实现，我们创建一个源文件，取名为textquery.cpp，首先是构造函数，直接写入代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取输入文件并建立单词到行号的映射</span></span><br><span class="line">TextQuery::<span class="built_in">TextQuery</span>(std::ifstream&amp; is) : <span class="built_in">file</span>(<span class="keyword">new</span> vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	string text;</span><br><span class="line">	<span class="comment">//对文件中每一行</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(is, text)) &#123;</span><br><span class="line">		<span class="comment">//保存此行文本</span></span><br><span class="line">		file-&gt;<span class="built_in">push_back</span>(text);</span><br><span class="line">		<span class="comment">//当前行号</span></span><br><span class="line">		<span class="keyword">int</span> n = file-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//将行文本分解为单词</span></span><br><span class="line">		<span class="function">std::istringstream <span class="title">line</span><span class="params">(text)</span></span>;</span><br><span class="line">		string word;</span><br><span class="line">		<span class="comment">//对行中每个单词</span></span><br><span class="line">		<span class="keyword">while</span> (line &gt;&gt; word) &#123;</span><br><span class="line">			<span class="comment">//如果单词不在 wm 中，以之为下标在wm中添加一项</span></span><br><span class="line">			<span class="comment">// lines是一个shared_ptr</span></span><br><span class="line">			<span class="keyword">auto</span>&amp; lines = wm[word];</span><br><span class="line">			<span class="keyword">if</span> (!lines)</span><br><span class="line">				<span class="comment">//分配一个新的set</span></span><br><span class="line">				lines.<span class="built_in">reset</span>(<span class="keyword">new</span> set&lt;line_no&gt;);</span><br><span class="line">			lines-&gt;<span class="built_in">insert</span>(n);<span class="comment">//将此行号插入set中</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到在函数体之前就已经为file分配了动态内存，同时由于file是指针类型这里需要使用-&gt;来使用push函数，之后使用istringstream处理当前这一行的字符，按空格存入word内，在第二个while循环中，首先定义lines获取在map中的这个单词的set容器，注意这里line是一个只能指针类型，由于有可能是第一次录入改单词，则需要对line进行判断，若不存在则需要新分配一个set，这里同样需要动态的分配内存。最后不论一定要将则一行的行号传入这个set容器中。</p>
<h3 id="query函数"><a href="#query函数" class="headerlink" title="query函数"></a>query函数</h3><p>它接受一个string参数，用它在map中对应行号，如果找到就构造一个QueryResult返回。这里有一个问题是如果没有找到返回什么呢？我们可以定义一个局部的static对象，它指向空的行号set的shared_ptr，没有找到就返回它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(<span class="keyword">const</span> string&amp; sought)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果未找到sought，我们将返回一个指向此set的指针</span></span><br><span class="line">	<span class="keyword">static</span> shared_ptr&lt;set&lt;line_no&gt;&gt; <span class="built_in">nodata</span>(<span class="keyword">new</span> set&lt;line_no&gt;);</span><br><span class="line">	<span class="comment">//使用find而不是下标运算符来查找单词，避免将单词添加到wm中!</span></span><br><span class="line">	<span class="keyword">auto</span> loc = wm.<span class="built_in">find</span>(sought);</span><br><span class="line">	<span class="keyword">if</span> (loc == wm.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">QueryResult</span>(sought, nodata, file);<span class="comment">//未找到</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">QueryResult</span>(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果ctr的值大于1，返回word的复数形式</span></span><br><span class="line"><span class="function">string <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr, <span class="keyword">const</span> string &amp;word, <span class="keyword">const</span> string &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ctr &gt; <span class="number">1</span>) ? word + ending : word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="keyword">const</span> QueryResult&amp; qr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; qr.lines-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">make_plural</span>(qr.lines-&gt;<span class="built_in">size</span>(), <span class="string">&quot;time&quot;</span>, <span class="string">&quot;s&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : *qr.lines)</span><br><span class="line">		<span class="comment">//避免行号从0开始给用户带来的困惑</span></span><br><span class="line">		os &lt;&lt; <span class="string">&quot;\t (line &quot;</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">&quot;)&quot;</span></span><br><span class="line">		<span class="comment">//使用标准库:文本查询程序</span></span><br><span class="line">		&lt;&lt; *(qr.file-&gt;<span class="built_in">begin</span>() + num) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文本查询程序2-0"><a href="#文本查询程序2-0" class="headerlink" title="文本查询程序2.0"></a>文本查询程序2.0</h1><p>利用C++继承与多态的性质改进该类， 以实现更多功能。</p>
<h2 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h2><ul>
<li><p>单词查询，用于得到匹配某个给定string的所有行:</p>
<p>Executing Query for: Daddy<br>Daddy occurs 3 times<br>(line 2) Her Daddy says when the wind blows<br>(line 7) “Daddy , shush, there is no such thing , “<br>(line 10) shyly, she asks,”I mean,Daddy ,is there?”</p>
</li>
<li><p>逻辑非查询，使用~运算符得到不匹配查询条件的所有行:</p>
<p>Executing Query for: ~(Alice)<br>~(Alice) occurs 9 times<br>( line 2) Her Daddy says when the wind blows<br>(line 3) through her hair, it looks almost alive,( line 4) like a fiery bird in flight.</p>
</li>
<li><p>逻辑或查询，使用|运算符返回匹配两个条件中任意一个的行:</p>
<p>Executing Query for: (hair l Alice)<br>(hair \ Alice) occurs 2 times<br>(line 1) Alice Emma has long flowing red hair.(line 3) through her hair, it looks almost alive,</p>
</li>
<li><p>逻辑与查询，使用&amp;运算符返回匹配全部两个条件的行:</p>
<p>Executing query for: (hair &amp; Alice)<br>(hair &amp;Alice) occurs 1 time<br>(line 1)Alice Emma has long f1owing red hair.</p>
</li>
<li><p>此外，我们还希望能够混合使用这些运算符，比如:fiery &amp; bird l wind</p>
<p>Executing Query for: ((fiery &amp; bird)l wind)                                                                                                                ( (fiery &amp; bird) l wind) occurs 3 times<br>(line 2) Her Daddy says when the wind blows                                                                                                        (line 4) like a fiery bird in flight.<br>(line 5) A beautiful fiery bird, he tells her ,</p>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们可以将集中不同的查询建模成相互独立的类，它们共享一个公共基类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wordQuery		<span class="comment">// Daddy</span></span><br><span class="line">NotQuery		<span class="comment">// ~Alice</span></span><br><span class="line">orQuery			<span class="comment">// hair l Alice</span></span><br><span class="line">AndQuery		<span class="comment">// hair &amp; Alice</span></span><br></pre></td></tr></table></figure>

<p>这些类将只包含两个操作:</p>
<ul>
<li>eval，接受一个TextQuery对象并返回一个 QueryResult，eval函数使用给定的TextQuery对象查找与之匹配的行。</li>
<li>rep，返回基础查询的string表示形式，eval函数使用rep创建一个表示匹配结果的QueryResult，输出运算符使用rep打印查询表达式。</li>
</ul>
<p><strong>关键概念:继承与组合</strong></p>
<p>继承体系的设计本身是一个非常复杂的问题,已经超出了本书的范围。然而,有一条设计准则非常重要也非常基础，每个程序员都应该熟悉它。</p>
<p>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种(IsA)”关系。在设计良好的类体系当中，公有派生类的对象应该可以用在任何需要基类对象的地方。</p>
<p>类型之间的另一种常见关系是“有一个(Has A)”关系，具有这种关系的类暗含成员的意思。</p>
<p>在我们的书店示例中，基类表示的是按规定价格销售的书籍的报价。Bulk_quote“是一种”报价结果，只不过它使用的价格策略不同。我们的书店类都“有一个”价格成员和ISBN成员。</p>
<h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>由于这四种查询并不存在继承关系，从概念上来说互为熊底，它们都共享同一个接口，我们定义一个抽象基类Query_base，并把eval和rep定义为纯虚函数。</p>
<p><img src="https://s2.loli.net/2022/02/18/WJghfcmUL6SvKPE.png" alt="image.png"></p>
<h4 id="将层次关系隐藏于接口类中"><a href="#将层次关系隐藏于接口类中" class="headerlink" title="将层次关系隐藏于接口类中"></a>将层次关系隐藏于接口类中</h4><p>我们的程序将致力于计算查询结果，而非仅仅构建查询的体系。为了使程序能正常运行，我们必须首先创建查询命令，最简单的办法是编写C++表达式。例如，可以编写下面的代码来生成之前描述的复合查询:</p>
<p><code>Query q = Query(&quot;fiery&quot;) &amp; Query (&quot;bird&quot;) | Query ( &quot;wind&quot; ) ;</code></p>
<p>用户不会直接使用这些类，而是使用Query保存一个Query_base指针，用户将通过 Query 对象的操作间接地创建并处理Query _base对象。我们定义Query对象的三个重载运算符以及一个接受string参数的Query构造函数，这些函数动态分配一个新的Query base派生类的对象:</p>
<ul>
<li><code>&amp;</code>运算符生成一个绑定到新的AndQuery对象上的Query对象;</li>
<li><code>|</code>运算符生成一个绑定到新的orQuery对象上的Query对象;</li>
<li><code>~</code>运算符生成一个绑定到新的NotQuery对象上的Query对象;</li>
<li>接受string 参数的Query构造函数生成一个新的wordQuery对象。</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/18/RcP7iGoENgdhuf9.png" alt="image.png"></p>
<h2 id="Query-base类和Query类"><a href="#Query-base类和Query类" class="headerlink" title="Query_base类和Query类"></a>Query_base类和Query类</h2><p>首先定义Query_base类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个抽象基类，具体的查询类型从中派生，所有成员都是private的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> line_no = TextQuery: :line_no; <span class="comment">//用于eval函数virtual ~Query_base() = default;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// eval返回与当前Query 匹配的QueryResult</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// rep是表示查询的一个string</span></span><br><span class="line">	<span class="keyword">virtual</span> std: :<span class="function">string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把所有操作都纯虚函数，因此Query_base是一个抽象基类，因为不直接使用它，所有没有public成员。</p>
<h4 id="Query类"><a href="#Query类" class="headerlink" title="Query类"></a>Query类</h4><p>它负责提供外界的接口，并隐藏继承体系。每个Query对象都含有一个指向Query_base对象的智能指针。</p>
<p>接受一个string参数的Query构造函数将创建一个新的wordQuery对象，然后将它的 shared_ prt成员绑定到这个新创建的对象上。&amp;、|和~运算符分别创建AndQuery、OrQuery和 NotQuery对象，这些运算符将返回一个绑定到新创建的对象上的Query对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个管理Query base继承体系的接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">	<span class="comment">//这些运算符需要访问接受shared _ptr的构造函数，而该函数是私有的</span></span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~ (<span class="keyword">const</span> Query &amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>/ (<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp; (<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;); </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Query</span>(<span class="keyword">const</span> std: :string&amp;);															</span><br><span class="line">	<span class="comment">//构建一个新的wordouery</span></span><br><span class="line">	<span class="comment">//接口函数:调用对应的Query base操作</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; t)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q-&gt;<span class="built_in">eval</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	std: :<span class="function">string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> q-&gt;<span class="built_in">rep</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Query</span>(std: :shared_ptr&lt;Query_base&gt; query) : <span class="built_in">q</span>(query)&#123; &#125;</span><br><span class="line">	std: :shared_ptr&lt;Query_base&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Query-的输出运算符"><a href="#Query-的输出运算符" class="headerlink" title="Query 的输出运算符"></a>Query 的输出运算符</h3><p>输出运算符可以很好地解释我们的整个查询系统是如何工作的:std: :ostream &amp;<br>operator&lt;&lt;(std: :ostream &amp;os,const Query &amp;query)<br>/ / Query: :rep通过它的Query base指针对rep ()进行了虚调用return os&lt;&lt;query.rep (;<br>当我们打印一个 Query时，输出运算符调用Query类的公有rep成员。运算符函数通过指针成员虚调用当前Query所指对象的rep成员。也就是说，当我们编写如下代码时:<br>Query andq = Query (sought1) &amp;Query (sought2 );<br>cout &lt;&lt; andq &lt;&lt; endl;<br>输出运算符将调用andq 的 Query: :rep,而 Query: :rep通过它的Query base指针虚调用Query _base版本的rep函数。因为andq指向的是一个AndQuery对象，所以本次的函数调用将运行AndQuery: : rep。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十四章</title>
    <url>/2022/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>它们由关键字operato和其后要定义的运算符号组成，其他和函数相同。当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显式)参数数量比运算对象的数量少一个。</p>
<p>我们只能重载<strong>一部分</strong>的<strong>已有</strong>运算符。对于重载的运算符，优先级和结合律与对应内置运算符（原先的）保持一致（不考虑运算对象）。</p>
<h4 id="调用重载运算符"><a href="#调用重载运算符" class="headerlink" title="调用重载运算符"></a>调用重载运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个非成员运算符函数的等价调用</span></span><br><span class="line">datal + data2 ;<span class="comment">//普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);<span class="comment">//等价的函数调用</span></span><br></pre></td></tr></table></figure>

<p>也可以像调用成员函数一样调用它们</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">datal +=data2;				<span class="comment">//基于“调用”的表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+= (data2);	<span class="comment">//对成员运算符函数的等价调用</span></span><br></pre></td></tr></table></figure>

<h4 id="某些运算符不应被重载"><a href="#某些运算符不应被重载" class="headerlink" title="某些运算符不应被重载"></a>某些运算符不应被重载</h4><p>通常情况下,不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p>
<h4 id="使用与内置类型一致的含义"><a href="#使用与内置类型一致的含义" class="headerlink" title="使用与内置类型一致的含义"></a>使用与内置类型一致的含义</h4><p>如果类的操作与运算符相关，才适合重载它们：</p>
<ol>
<li>如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致。</li>
<li>如果类的某个操作是检查相等性，则定义 operator==;如果类有了operator==，意味着它通常也应该有operator!=。</li>
<li>如果类包含一个内在的单序比较操作，则定义 operator&lt;;如果类有了operator&lt;，则它也应该含有其他关系操作。</li>
<li>重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容:逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。</li>
</ol>
<p><em>尽量明智的重载它们，使操作符保持原有的操作逻辑</em></p>
<h4 id="赋值和复合赋值运算符"><a href="#赋值和复合赋值运算符" class="headerlink" title="赋值和复合赋值运算符"></a>赋值和复合赋值运算符</h4><p>例如类中有+和=运算符那么最好也重载+=。</p>
<h4 id="选择成员或非成员"><a href="#选择成员或非成员" class="headerlink" title="选择成员或非成员"></a>选择成员或非成员</h4><p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择:·</p>
<ol>
<li>赋值(=)、下标（[ ])、调用（( )）和成员访问箭头(-&gt;)运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员,但并非必须,这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ol>
<p>如果希望在含有混合类型的表达式中使用对称性运算符，例如求int和doubie的和，因为它们都可以是第一个运算对象。所以必须定义为非成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;<span class="comment">//正确:我们能把一个const char*加到一个string对象中</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">//如果+是string 的成员，则产生错误</span></span><br></pre></td></tr></table></figure>

<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>输出运算符的第一个形参是非常量的ostream对象的引用。非常量是因为向流写入内容会改变其状态；使用引用是我们无法赋值一个ostream对象。</p>
<h4 id="Sales-data的输出运算符"><a href="#Sales-data的输出运算符" class="headerlink" title="Sales_data的输出运算符"></a>Sales_data的输出运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; item.<span class="built_in">isbn</span> () &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">		&lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前类内的print函数一样，打印一个Sales_data类意味着打印三个数据成员。</p>
<h4 id="输出运算符尽量减少格式化"><a href="#输出运算符尽量减少格式化" class="headerlink" title="输出运算符尽量减少格式化"></a>输出运算符尽量减少格式化</h4><p>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
<h4 id="输入输出运算符必须是非成员函数"><a href="#输入输出运算符必须是非成员函数" class="headerlink" title="输入输出运算符必须是非成员函数"></a>输入输出运算符必须是非成员函数</h4><p>与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sales data data;</span><br><span class="line">data &lt;&lt; cout;		<span class="comment">//如果 operator&lt;&lt;是sales_data的成员</span></span><br></pre></td></tr></table></figure>

<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<h4 id="Sale-data的输入运算符"><a href="#Sale-data的输入运算符" class="headerlink" title="Sale_data的输入运算符"></a>Sale_data的输入运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> price; <span class="comment">// 不需要初始化，因为我们将先读入数据到price，之后才使用它</span></span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	<span class="keyword">if</span>(is)<span class="comment">//检查输入是否成功</span></span><br><span class="line">		item. revenue = item. units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		item = <span class="built_in">Sales_data</span> () ;<span class="comment">//输入失败:对象被赋予默认的状态return is;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if的判断检查读取操作是否成功，这样如果发生了错误，则运算符将给定的对象重置为空。</p>
<p><strong>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</strong></p>
<h4 id="输入时的错误"><a href="#输入时的错误" class="headerlink" title="输入时的错误"></a>输入时的错误</h4><p>执行输入时有可能发生错误：</p>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。例如在读取完bookNo后，输入运算符假定接下来读入的是两个数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都将失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<p>前面的函数中，没有诸葛检查读取操作，而是读取了所有数据后赶在使用这些数据前一次性检查。失败后的price的值是未定义的。所以只需要在错误时默认初始化这个对象</p>
<p><strong>当读取操作发生错误时,输入运算符应该负责从错误中恢复。</strong></p>
<h4 id="标示错误（略）"><a href="#标示错误（略）" class="headerlink" title="标示错误（略）"></a>标示错误（略）</h4><h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
<p>如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是<strong>使用复合赋值来定义算术运算符</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设两个对象指向同一本书</span></span><br><span class="line">sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> sales_data &amp;lhs,<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	sales_data sum = lhs;	<span class="comment">//把lhs的数据成员拷贝给sum</span></span><br><span class="line">	sum += rhs;				<span class="comment">//将rhs加到sum中</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs,<span class="keyword">const</span> sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  lhs.<span class="built_in">isbn</span> () == rhs.<span class="built_in">isbn</span> () &amp;&amp;</span><br><span class="line">			lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">       		lhs.revenue == rhs.revenue;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs,<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !( lhs==rhs ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中体现的设计准则：</p>
<ul>
<li>如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数:因为用户肯定希望能使用==比较对象，所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了==运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下，相等运算符应该具有传递性，换句话说，如果a==b和 b==c都为真，则a==c也应该为真。</li>
<li>如果类定义了operator==，则这个类也应该定义operator!=。对于用户来说，当他们能使用==时肯定也希望能使用!=，反之亦然。</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个,这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>如果存在唯一一种逻辑可靠的&lt;定义,则应该考虑为这个类定义&lt;运算符。如果类同时还包含==,则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>除了拷贝赋值和移动赋值外，还可以定义其他赋值运算吧别的对象作为右侧对象。例如vector接受花括号元素列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">= &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//可以把运算符添加到StrVec</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	strVec &amp;<span class="keyword">operator</span>=(std::initializer_list&lt;std::string&gt;);</span><br><span class="line">    <span class="comment">//其他成员与13.5节（第465页）一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">strVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//alloc_n_copy分配内存空间并从给定范围内拷贝元素</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span> (), il.<span class="built_in">end</span> () );</span><br><span class="line">    <span class="built_in">free</span> ( );				<span class="comment">//销毁对象中的元素并释放内存空间</span></span><br><span class="line">	elements = data.first;	<span class="comment">//更新数据成员使其指向新空间</span></span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和其他赋值函数一样需要先释放当前内存空间，创建一片新的空间，不同之处是，无需检查对象向自身的赋值。</p>
<p><strong>我们可以重载赋值运算符。不论形参的类型是什么,赋值运算符都必须定义为成员函数。</strong></p>
<h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h4><p>复合运算符不一定是类成员，不过倾向于把包括复合在内的所有运至运算都定义在类的内部，与内置类型保持一致。复合赋值也要返回左侧对象的引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为成员的二元运算符:左侧运算对象绑定到隐式的this指针//假定两个对象表示的是同一本书</span></span><br><span class="line">sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>它必须是成员函数。它通常以访问元素的引用作为返回值，这样可以出现在赋值运算的任意一端。此外，如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string&amp; <span class="keyword">operator</span>[] (std::<span class="keyword">size_t</span> n)</span><br><span class="line">		&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">	<span class="keyword">const</span> std::string&amp; <span class="keyword">operator</span>[] (std::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">		&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">	<span class="comment">//其他成员与13.5（第465页）一致</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *elements;	<span class="comment">//指向数组首元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这两个下标运算符用法类似vector或者数组中的下标，非常量可以赋值，而常量不可以赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设svec是一个StrVec对象</span></span><br><span class="line"><span class="keyword">const</span> Strvec cvec = svec;		<span class="comment">//把svec 的元素拷贝到cvec中</span></span><br><span class="line"><span class="comment">//如果svec中含有元素，对第一个元素运行string 的 empty函数</span></span><br><span class="line"><span class="keyword">if</span> (svec.<span class="built_in">size</span>() &amp; &amp; svec[<span class="number">0</span>].<span class="built_in">empty</span>())&#123;</span><br><span class="line">&#123;</span><br><span class="line">	svec[<span class="number">0</span>]= <span class="string">&quot;zero&quot;</span>;		<span class="comment">//正确:下标运算符返回string的引用</span></span><br><span class="line">	cvec[<span class="number">0</span>]= <span class="string">&quot;Zip&quot;</span>;			<span class="comment">//错误:对cvec取下标返回的是常量引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>因为这两个运算符改变的是操作对象的状态，所以建议将其设定为成员函数。</p>
<p><strong>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</strong></p>
<h4 id="定义前置递增-递减"><a href="#定义前置递增-递减" class="headerlink" title="定义前置递增/递减"></a>定义前置递增/递减</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//递增和递减运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>++();			<span class="comment">//前置运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	<span class="comment">//其他成员和之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置版本:返回递增/递减对象的引用</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">	<span class="comment">//如果curr已经指向了容器的尾后位置，则无法递增它</span></span><br><span class="line">	<span class="built_in">check</span> (curr, <span class="string">&quot;increment past end of StrBlobPtr&quot;</span> );++curr;</span><br><span class="line">	<span class="comment">//将curr在当前状态下向前移动一个元素</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()&#123;</span><br><span class="line">	<span class="comment">//如果curr是0，则继续递减它将产生一个无效下标--curr;</span></span><br><span class="line">	<span class="comment">//将curr在当前状态下向后移动一个元素</span></span><br><span class="line">	<span class="built_in">check</span> (curr,<span class="string">&quot;decrement past begin of StrBlobPtr&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定要注意检查递增递减后的值是否还有意义，且最好返回引用。</p>
<h4 id="区分前置和后置"><a href="#区分前置和后置" class="headerlink" title="区分前置和后置"></a>区分前置和后置</h4><p>因为普通的重载无法区分前置和后置版本，所以后置版本接受一个额外的int类型的形参，使用时编译器提供值为0的形参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//递增和递减运算符</span></span><br><span class="line">	strBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>) ;	<span class="comment">//后置运算符</span></span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>) ;</span><br><span class="line">	<span class="comment">//其他成员和之前的版本一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后置版本:递增/递减对象的值但是返回原值</span></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">    strBlobPtr ret = *<span class="keyword">this</span>;	<span class="comment">//记录当前的值</span></span><br><span class="line">	++*<span class="keyword">this</span>;				<span class="comment">//向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">	<span class="keyword">return</span> ret;				<span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">//此处无须检查有效性，调用前置递减运算时才需要检查</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;	<span class="comment">//记录当前的值</span></span><br><span class="line">	-―*<span class="keyword">this</span>;				<span class="comment">//向后移动一个元素,前置--需要检查递减的有效性</span></span><br><span class="line">	<span class="keyword">return</span> ret;				<span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置运算符依然调用前置运算符完成，此外由于不需要用到int形参，所以不需要命名。</p>
<h4 id="显示调用后置运算符"><a href="#显示调用后置运算符" class="headerlink" title="显示调用后置运算符"></a>显示调用后置运算符</h4><p>可以通过函数调用方式调用后置版本，但必须传递一个值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(al)</span></span>;		<span class="comment">//p指向a1中的vector</span></span><br><span class="line">p.<span class="keyword">operator</span>++(O);		<span class="comment">//调用后置版本的operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();			<span class="comment">//调用前置版本的operator++</span></span><br></pre></td></tr></table></figure>

<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span></span><br><span class="line">	&#123; </span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">check</span> (curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];		<span class="comment">//(*p)是对象所指的vector</span></span><br><span class="line">    &#125;</span><br><span class="line">	std::string* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span></span><br><span class="line">	&#123;	</span><br><span class="line">        <span class="comment">//将实际工作委托给解引用运算符</span></span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>* ();</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个运算符用法与指针或者vector迭代器操作完全一致，需要检查curr是否在范围内，是的话返回curr所指元素的引用。</p>
<p><strong>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</strong></p>
<h4 id="对箭头返回值的限定"><a href="#对箭头返回值的限定" class="headerlink" title="对箭头返回值的限定"></a>对箭头返回值的限定</h4><p>箭头运算符永远不能丢掉成员访问这个最基本的含义。对于对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;的类的对象。根据point类型的不同，point-&gt;mem分别等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*point).mem;			<span class="comment">// point是一个内置的指针类型</span></span><br><span class="line">point.<span class="built_in"><span class="keyword">operator</span></span>()-&gt;mem;	<span class="comment">// point是类的一个对象</span></span><br></pre></td></tr></table></figure>

<p>此外，代码都会发生错误，它的执行过程如下：</p>
<ol>
<li>如果point是指针,则我们应用内置的箭头运算符,表达式等价于(*point) .mem.首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类型没有名为mem的成员，程序会发生错误。</li>
<li>如果point是定义了operator-&gt;的类的一个对象,则我们使用point.operator-&gt;()的结果来获取mem。其中，如果该结果是一个指针，则执行第1步;如果该结果本身含有重载的 operator-&gt; ()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。</li>
</ol>
<p><strong>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</strong></p>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>它使我们可以像调用函数一个调用对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">( )</span> <span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &lt;<span class="number">0</span> ? -val : val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用的过程非常像函数的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absobj;				<span class="comment">//含有函数调用运算符的对象</span></span><br><span class="line"><span class="keyword">int</span> ui = <span class="built_in">absobj</span>(i);			<span class="comment">//将i传递给abs0bj.operator ( )</span></span><br></pre></td></tr></table></figure>

<p><strong>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</strong></p>
<h4 id="含有状态的函数对象类"><a href="#含有状态的函数对象类" class="headerlink" title="含有状态的函数对象类"></a>含有状态的函数对象类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Printstring</span>(ostream &amp;o = cout, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>) : <span class="built_in">os</span>(o) , <span class="built_in">sep</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span> </span>&#123; os&lt;&lt;s &lt;&lt; sep; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ostream &amp;os;			<span class="comment">//用于写入的目的流</span></span><br><span class="line">	<span class="keyword">char</span> sep;				<span class="comment">//用于将不同输出隔开的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类有默认构造函数接受一个输出流引用和用于分隔的字符，之后调用运算符使用这些成员来协助打印给定的string。</p>
<p>当定义PrintString的对象时，对于分隔符及输出流既可以使用默认值也可以提供我们自己的值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Printstring printer;		<span class="comment">//使用默认值，打印到cout</span></span><br><span class="line"><span class="built_in">printer</span> (s);				<span class="comment">//在cout中打印s，后面跟一个空格</span></span><br><span class="line"><span class="function">Printstring <span class="title">errors</span> <span class="params">(cerr, <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">errors</span>(s);					<span class="comment">//在cerr中打印s，后面跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>函数对象常常作为泛型算法的实参。例如，可以使用标准库for_each 算法（参见10.3.2节，第348页）和我们自己的 PrintString类来打印容器的内容:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(vs.begin (), vs.end(), PrintString (cerr, <span class="string">&#x27;\n&#x27;</span>) )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>编写lambda后，编译器就将它翻译成一个未命名的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据单词的长度对其进行排序，对于长度相同的单词按照字母表顺序排序</span></span><br><span class="line"><span class="built_in">stable_sort</span> (words. <span class="built_in">begin</span> () , words.<span class="built_in">end</span> (),</span><br><span class="line">				[](<span class="keyword">const</span> string &amp;a, <span class="keyword">const</span> string &amp;b)</span><br><span class="line">             		&#123;freturn a.<span class="built_in">size</span> () &lt; b.<span class="built_in">size</span>();&#125;);</span><br><span class="line"><span class="comment">//其行为类似于下面这个类的一个未命名对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shorterstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> string &amp;s1,<span class="keyword">const</span> string &amp;s2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    	</span>&#123; <span class="keyword">return</span> sl.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用这个类替代 lambda表达式后，我们可以重写并重新调用</span></span><br><span class="line">stable_sort:<span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>() ,<span class="built_in">Shorterstring</span>());</span><br></pre></td></tr></table></figure>

<h4 id="表示lambda及相应的捕获行为的类"><a href="#表示lambda及相应的捕获行为的类" class="headerlink" title="表示lambda及相应的捕获行为的类"></a>表示lambda及相应的捕获行为的类</h4><p>当lambda表达式通过引用捕获变量时，程序确保lambda执行时引用所引用对象存在。这个lambda产生的类未每个值建立对应的数据成员，同时创建构造函数，捕获的值用于初始化变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= Sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span> (words.<span class="built_in">begin</span>() , words.<span class="built_in">end</span>(),[sz] (<span class="keyword">const</span> string &amp;a)</span><br><span class="line">						&#123; <span class="keyword">return</span> a.<span class="built_in">size</span> () &gt;= sz;&#125; );</span><br><span class="line"><span class="comment">//该lambda表达式产生的类将形如:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> &#123;</span></span><br><span class="line">	<span class="built_in">SizeComp</span>(<span class="keyword">size_t</span> n): <span class="built_in">sz</span>(n)&#123; <span class="comment">//该形参对应捕获的变量</span></span><br><span class="line">    <span class="comment">//该调用运算符的返回类型、形参和函数体都与lambda一致</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">		</span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">size_t</span> sZ;</span><br><span class="line">	<span class="comment">//该数据成员对应通过值捕获的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用时必须提供一个实参用于构造函数。</span></span><br><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= sz</span></span><br><span class="line">    <span class="keyword">auto</span> wc = <span class="built_in">find_if</span> (words.<span class="built_in">begin</span> (), words.<span class="built_in">end</span> () , <span class="built_in">sizeComp</span>(sz) );</span><br></pre></td></tr></table></figure>

<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>C++语言中有几种可调用的对象:函数、函数指针、lambda表达式（参见10.3.2节,第346页)、bind创建的对象（参见10.3.4节，第354页）以及重载了函数调用运算符的类</p>
<h4 id="不同类型可以有相同的调用形式"><a href="#不同类型可以有相同的调用形式" class="headerlink" title="不同类型可以有相同的调用形式"></a>不同类型可以有相同的调用形式</h4><p>对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i +j; &#125;</span><br><span class="line"><span class="comment">//lambda，其产生一个未命名的函数对象类</span></span><br><span class="line"><span class="keyword">auto</span> mod = [ ](<span class="keyword">int</span> i, <span class="keyword">int</span> j）&#123; <span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line">struct divide &#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor) &#123;</span><br><span class="line">		<span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然各不相同但共享一种调用形式：<code>int(int,int)</code></p>
<p>我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个函数表(function table）用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。</p>
<p>假定我们的所有函数都相互独立，并且只处理关于 int的二元运算，则map可以定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建从运算符到函数指针的映射关系，其中函数接受两个int、返回一个int</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>(*）(<span class="keyword">int</span> ,<span class="keyword">int</span>) &gt; binops;</span><br><span class="line"><span class="comment">//我们可以按照下面的形式将add的指针添加到binops 中:</span></span><br><span class="line"><span class="comment">//正确:add是一个指向正确类型函数的指针</span></span><br><span class="line">binops.<span class="built_in">insert</span>( &#123; <span class="string">&quot;+&quot;</span>，add&#125; );<span class="comment">//&#123; &quot;+&quot;，add&#125;是一个pair(参见11.2.3节，379页)</span></span><br></pre></td></tr></table></figure>

<p>但是我们不能将mod或者divide存入 binops，因为他们时类类型，所以类型并不匹配。</p>
<h4 id="标准库function类型"><a href="#标准库function类型" class="headerlink" title="标准库function类型"></a>标准库function类型</h4><p>我们可以使用一个名为function的新的标准库类型解决上述问题，function定义在functional头文件中。</p>
<p><img src="https://s2.loli.net/2022/02/15/7iVLtUCMzxBcaTZ.png" alt="image.png"></p>
<p>声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; f1 = add;				<span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; f2= <span class="built_in">divide</span>() ;		<span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i * j; &#125;; <span class="comment">//lambda</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span> (<span class="number">4</span>,<span class="number">2</span>）&lt;&lt;endl;						</span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span> (<span class="number">4</span>,<span class="number">2</span>) &lt;&lt;endl;					</span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span> (<span class="number">4</span>,<span class="number">2</span>) &lt;&lt;endl;					</span><br></pre></td></tr></table></figure>

<p>使用function重新定义map</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列举了可调用对象与二元运算符对应关系的表格</span></span><br><span class="line"><span class="comment">//所有可调用对象都必须接受两个int、返回一个int</span></span><br><span class="line"><span class="comment">//其中的元素可以是函数指针、函数对象或者lambda</span></span><br><span class="line">map&lt;string, function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br></pre></td></tr></table></figure>

<p> 把可调用对象都添加到这个map中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">	&#123; <span class="string">&quot;+&quot;</span>, add&#125; ,					<span class="comment">//函数指针</span></span><br><span class="line">	&#123; <span class="string">&quot;-&quot;</span>, std::minus&lt;<span class="keyword">int</span>&gt; () &#125; ,	<span class="comment">//标准库函数对象</span></span><br><span class="line">	&#123; <span class="string">&quot;/&quot;</span>, <span class="built_in">divide</span> () &#125;,				<span class="comment">//用户定义的函数对象</span></span><br><span class="line">	&#123; <span class="string">&quot;*&quot;</span>, [] (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; H&#125;，<span class="comment">//未命名的lambda</span></span><br><span class="line">    &#123; <span class="string">&quot;%&quot;</span>, mod&#125; &#125;;					<span class="comment">//命名了的lambda对象</span></span><br></pre></td></tr></table></figure>

<p>最后在这个map中使用索引调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">binops [ <span class="string">&quot;+&quot;</span>](<span class="number">10</span>，<span class="number">5</span>); <span class="comment">//调用add (10,5)</span></span><br><span class="line">binops [ <span class="string">&quot;-&quot;</span>](<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//使用minus&lt;int&gt;对象的调用运算符</span></span><br><span class="line">binops [ <span class="string">&quot;/&quot;</span>](<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//使用divide对象的调用运算符</span></span><br><span class="line">binops [ <span class="string">&quot;*&quot;</span>](<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//调用lambda函数对象</span></span><br><span class="line">binops [ <span class="string">&quot;%&quot;</span>](<span class="number">10</span>，<span class="number">5</span>); <span class="comment">//调用lambda函数对象</span></span><br></pre></td></tr></table></figure>

<h4 id="重载函数与function"><a href="#重载函数与function" class="headerlink" title="重载函数与function"></a>重载函数与function</h4><p>我们不可以直接向重载的函数名存入function类型的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i +j;&#125;</span><br><span class="line"><span class="function">sales_data <span class="title">add</span> <span class="params">(<span class="keyword">const</span> sales_data&amp;, <span class="keyword">const</span> sales_data&amp;)</span></span>;</span><br><span class="line">map&lt;string, function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>( &#123; <span class="string">&quot;+&quot;</span>, add&#125; );<span class="comment">//错误:哪个add?</span></span><br></pre></td></tr></table></figure>

<p>解决方法是储存一个函数的指针，而不是函数名字</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp)(<span class="built_in">int</span>,<span class="built_in">int</span>) = <span class="keyword">add</span>;			<span class="comment">//指针所指的add是接受两个int的版本</span></span><br><span class="line">binops.insert( &#123; <span class="string">&quot;+&quot;</span>, fp&#125; );		<span class="comment">//正确:fp指向一个正确的add版本</span></span><br><span class="line"><span class="comment">//同样，我们也能使用lambda来消除二义性:</span></span><br><span class="line"><span class="comment">//正确:使用lambda来指定我们希望使用的add版本</span></span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>，[](<span class="built_in">int</span> a, <span class="built_in">int</span> b) (<span class="keyword">return</span> <span class="keyword">add</span>(a,b);&#125; &#125; );</span><br></pre></td></tr></table></figure>

<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换(class-type conversions)，这样的转换有时也被称作用户定义的类型转换（user-defined conversions)。</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>它是类的特殊成员函数，负责将一个类类型转换成其他类型，型式为：<code>operator type() const;</code></p>
<p>其中 type表示某种类型。类型转换运算符可以面向任意类型(除了void之外)进行定义，只要该类型能作为函数的返回类型(参见6.1节，第184页)。因此，我们不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。</p>
<p><strong>一个类型转换函数必须是类的成员函数;它不能声明返回类型,形参列表也必须为空。类型转换函数通常应该是const。</strong></p>
<h4 id="定义含类型转换的类"><a href="#定义含类型转换的类" class="headerlink" title="定义含类型转换的类"></a>定义含类型转换的类</h4><p>令表示0到255之间的整数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span> (<span class="keyword">int</span> i = <span class="number">0</span>) : <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span> ( <span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;		<span class="comment">//首先将4隐式地转换成SmallInt，然后调用SmallInt : :operator=</span></span><br><span class="line">si + <span class="number">3</span>;		<span class="comment">//首先将si隐式地转换成int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>

<p>这个类即定义了类类型向其他类型的转换，也有其他类型向类类型的转换（通过内置转为int再转为类类型）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内置类型转换将double实参转换成int</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;			<span class="comment">//调用SmallInt (int)构造函数</span></span><br><span class="line"><span class="comment">//SmallInt的类型转换运算符将si转换成int</span></span><br><span class="line">si + <span class="number">3.14</span>;					<span class="comment">//内置类型转换将所得的int继续转换成double</span></span><br></pre></td></tr></table></figure>

<p>编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。因此，我们可以将任何算术类型传递给SmallInt的构造函数。类似的，我们也能使用类型转换运算符将一个SmallInt对象转换成int，然后再将所得的int转换成任何其他算术类型。</p>
<p>因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp; )</span> </span>;</span><br><span class="line"><span class="comment">//错误:不是成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//错误:指定了返回类型</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;	<span class="comment">//错误:参数列表不为空</span></span><br><span class="line">	<span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">42</span>;&#125;<span class="comment">//错误:42不是一个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>避免过度使用类行转换函数</strong></p>
<h4 id="类型转换可能产生意外的结果"><a href="#类型转换可能产生意外的结果" class="headerlink" title="类型转换可能产生意外的结果"></a>类型转换可能产生意外的结果</h4><p>例如一个像bool类型的转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i; <span class="comment">//如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的!</span></span><br></pre></td></tr></table></figure>

<p>这段程序试图将输出运算符作用于输入流。因为istream本身并没有定义&lt;&lt;，所以本来代码应该产生错误。然而，该代码能使用istream的 bool类型转换运算符将cin转换成bool,而这个bool值接着会被提升成int并用作内置的左移运算符的左侧运算对象。这样一来，提升后的bool值(1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。</p>
<h4 id="显示的类型转换运算符"><a href="#显示的类型转换运算符" class="headerlink" title="显示的类型转换运算符"></a>显示的类型转换运算符</h4><p>为防止上述情况，C++11引入此运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//编译器不会自动执行这一类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和显示构造函数一样，编译器不会将显示的类型转换用于隐式类型转换，使用时就必须显示的进行强制类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;		<span class="comment">//正确:SmallInt的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;					<span class="comment">//错误:此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;<span class="comment">//正确:显式地请求类型转换</span></span><br></pre></td></tr></table></figure>

<p>该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行:</p>
<ul>
<li>if、 while及do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>逻辑非运算符（!)、逻辑或运算符（)、逻辑与运算符（&amp;&amp;）的运算对象</li>
<li>条件运算符（?:）的条件表达式。</li>
</ul>
<h4 id="转换为bool"><a href="#转换为bool" class="headerlink" title="转换为bool"></a>转换为bool</h4><p>无论我们什么时候在条件中使用流对象，都会使用为IO类型定义的operatorbool。例如:<br><code>while (std: :cin &gt;&gt; value)</code><br>while语句的条件执行输入运算符，它负责将数据读入到value并返回cin。为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin的条件状态是good(参见8.1.2节，第280页)，则该函数返回为真;否则该函数返回为假。</p>
<p><strong>向bool的类型转换通常用在条件部分,因此 operator bool 一般定义成explicit的。</strong></p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。</p>
<p>在两种情况下可能产生多重转换路径。</p>
<ul>
<li>第一种情况是两个类提供相同的类型转换:例如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说它们提供了相同的类型转换。</li>
<li>第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。</li>
</ul>
<p><strong>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</strong></p>
<h4 id="实参匹配和相同的类型转换"><a href="#实参匹配和相同的类型转换" class="headerlink" title="实参匹配和相同的类型转换"></a>实参匹配和相同的类型转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最好不要在两个类之间构建相同的类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">const</span> B&amp;);		<span class="comment">//把一个B转换成A</span></span><br><span class="line">	<span class="comment">//其他数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span><span class="keyword">const</span></span>;	<span class="comment">//也是把一个B转换成A</span></span><br><span class="line">    <span class="comment">//其他数据成员</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">A <span class="title">f</span> <span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">Bb;</span><br><span class="line">A a= <span class="built_in">f</span>(b);	<span class="comment">//二义性错误:含义是f(B:: operator A())</span></span><br><span class="line">			<span class="comment">//还是f(A: :A(const B&amp;))?</span></span><br></pre></td></tr></table></figure>

<p>代码中同时存在两种B获得A的方法，造成编译器无法判断，此时必须显示调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>() ) ;		<span class="comment">//正确:使用B的类型转换运算符</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));					<span class="comment">//正确:使用A的构造函数</span></span><br></pre></td></tr></table></figure>

<p>但最好的办法就是避免此情况</p>
<h4 id="二义性与转换目标的为内置类型的多重转换"><a href="#二义性与转换目标的为内置类型的多重转换" class="headerlink" title="二义性与转换目标的为内置类型的多重转换"></a>二义性与转换目标的为内置类型的多重转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="built_in">A</span> (<span class="keyword">int</span> = <span class="number">0</span>);				<span class="comment">//最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">	<span class="built_in">A</span> (<span class="keyword">double</span>);</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> <span class="keyword">const</span></span>;	 <span class="comment">//最好不要创建两个转换对象都是算术类型的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">( <span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);			<span class="comment">//二义性错误:含义是f(A::operator int ())</span></span><br><span class="line">				<span class="comment">//还是f(A::operator double ()) ?</span></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>g)</span></span>;		<span class="comment">//二义性错误:含义是A::A(int)还是A::A(double)?</span></span><br></pre></td></tr></table></figure>

<p>在对f2的调用中，哪个类型转换都无法精确匹配long double。然而这两个类型转换都可以使用，只要后面再执行一次生成long double的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。</p>
<h4 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h4><p>要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。以下的经验规则可能对你有所帮助:</p>
<ul>
<li>不要令两个类执行相同的类型转换:如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。</li>
<li>避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时,接下来<ul>
<li>不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符,则类型转换操作将转换你的类型的对象,然后使用内置的运算符。</li>
<li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。</li>
</ul>
</li>
</ul>
<p>一言以蔽之:除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。</p>
<h4 id="重载函数与转换构造函数"><a href="#重载函数与转换构造函数" class="headerlink" title="重载函数与转换构造函数"></a>重载函数与转换构造函数</h4><p>举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">	<span class="built_in">c</span> (<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">	<span class="built_in">D</span> (<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span> <span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span> <span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span> (<span class="number">10</span>);<span class="comment">//二义性错误:含义是manip (c(10))还是manip(D(10) )</span></span><br></pre></td></tr></table></figure>

<p><em>如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型,则这通常意味着程序的设计存在不足。</em></p>
<h4 id="重载函数与用户定义的类型转换"><a href="#重载函数与用户定义的类型转换" class="headerlink" title="重载函数与用户定义的类型转换*"></a>重载函数与用户定义的类型转换*</h4><h3 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h3><p>调用对象函数与普通函数不同，如果a时一种类型，则a sym b可能是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a. <span class="built_in">operatorsym</span>(b);	<span class="comment">//a有一个operatorsym成员函数</span></span><br><span class="line"><span class="built_in">operatorsym</span>(a,b);	<span class="comment">//operatorsym是一个普通函数</span></span><br></pre></td></tr></table></figure>

<p>但重载的运算符并不能通过调用形式区分成员与非成员函数</p>
<p>当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span></span><br><span class="line">	SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span> (<span class="keyword">int</span> = <span class="number">0</span> ) ;		<span class="comment">//转换源为int的类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">( )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;<span class="comment">//转换目标为int的类型转换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可以使用这个类将两个 smallInt对象相加，但如果我们试图执行混合模式的算术运算，就将遇到二义性的问题:</span></span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;		<span class="comment">//使用重载的operator+</span></span><br><span class="line"><span class="keyword">int</span> i = s3 +<span class="number">0</span> ;				<span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>

<p>第二条加法语句具有二义性：因为我们可以把0转换成smallInt，然后使用smallInt 的+，或者把s3转换成int，然后对于两个int执行内置的加法运算。</p>
<p><strong>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</strong></p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十三章</title>
    <url>/2022/01/27/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>() ;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Foo</span> (<span class="keyword">const</span> Foo&amp;);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数必须是引用，且通常都是const的，拷贝构造通常是隐式使用，不应该是explicit的。</p>
<h4 id="合成的拷贝构造"><a href="#合成的拷贝构造" class="headerlink" title="合成的拷贝构造"></a>合成的拷贝构造</h4><p>无论我们有没有定义其他拷贝构造，编译器都会自动和合成一个拷贝构造函数。合成的拷贝构造函数会从给定对象中依次将每个非static成员拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定了它如何拷贝:对类类型的成员，会使用其拷贝构造函数来拷贝;内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。</p>
<h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span> <span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(dots)</span> </span>;<span class="comment">//直接初始化</span></span><br><span class="line">string s2 = dots;<span class="comment">//拷贝初始化</span></span><br><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line">string nines = <span class="built_in">string</span> (<span class="number">100</span>,<span class="string">&#x27;9&#x27;</span>) ;<span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>

<p>如果类中有一个移动构造函数，则拷贝初始化有时会使用移动构造而非拷贝构造，所谓移动构造就是指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。所以我们应了解何时发生拷贝构造：</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生·</p>
<ul>
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p>
</li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p>
</li>
<li><p>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>
</li>
</ul>
<p>此外当初始化标准容器或调用insert或push时，会使用拷贝初始化，而emplace成员创建的元素都是直接初始化。</p>
<h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>函数调用过程中，具有非引用类型的参数都要进行拷贝初始化，函数返回值为非引用时，返回值也会被用来做为接受对象拷贝初始化的参数。</p>
<p>所以拷贝初始化的参数必须是引用类型，不然就一直调用也不会成功。</p>
<h4 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h4><p>值初始化和拷贝初始化不是一模一样的，如果使用explicit构造函数，我们就不能隐式的调用它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//正确:直接初始化</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;<span class="comment">//错误:接受大小参数的构造函数是explicit的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;)</span></span>;<span class="comment">// f的参数进行拷贝初始化</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//错误:不能用一个explicit的构造函数考贝一个实参</span></span><br><span class="line"><span class="built_in">f</span>(vector&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>));<span class="comment">//正确:从一个int直接构造一个临时vector</span></span><br></pre></td></tr></table></figure>

<p>必须显示的调用explicit函数。</p>
<h4 id="编译器可以绕过拷贝构造函数"><a href="#编译器可以绕过拷贝构造函数" class="headerlink" title="编译器可以绕过拷贝构造函数"></a>编译器可以绕过拷贝构造函数</h4><p>拷贝/移动构造可以被忽略，直接创建对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="comment">//改写为</span></span><br><span class="line"><span class="function">string <span class="title">null_book</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>; <span class="comment">//编译器略过了拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>可以跳过拷贝/移动构造，但必须有且可访问。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><h4 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h4><p>重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数（参见7.1.2节，第231页)。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Foo&amp;); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>赋值运算符应该返回一个引用！</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>和前几个构造函数一样，如果类内未定义，就会自动生成。作为一个例子，下面的代码等价于sales_data的合成拷贝赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sales_data&amp; Sales_data::<span class="keyword">operator</span>= (<span class="keyword">const</span> Sales_data &amp;rhs) &#123;</span><br><span class="line">	bookNo = rhs.bookNo;<span class="comment">//调用string : : operator=</span></span><br><span class="line">	units_sold = rhs.units_sold;<span class="comment">//使用内置的int赋值</span></span><br><span class="line">	revenue = rhs.revenue;<span class="comment">//使用内置的double赋值</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回一个此对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它和拷贝构造函数的区别是，拷贝构造是从无到有，而拷贝赋值时本来就有，只是值发生改变。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>它与构造函数相反，构造函数初始化非static数据成员，还有其他工作，析构函数释放对象使用资源，销毁对象非static数据成员。它没有返回值，也不接受参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Foo</span>();<span class="comment">//析构函数</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于没有参数，所以不能被重载。</p>
<h4 id="函数任务"><a href="#函数任务" class="headerlink" title="函数任务"></a>函数任务</h4><p>它所有顺序都与构造函数相反，先执行函数体，然后销毁成员，且按出现次序逆序销毁。且析构部分时隐式的，销毁完全取决与类型。</p>
<p><em>隐式销毁内置指针类型的成员不会delete指向的对象</em></p>
<h4 id="何时调用析构"><a href="#何时调用析构" class="headerlink" title="何时调用析构"></a>何时调用析构</h4><p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line"><span class="comment">// p和p2指向动态分配的对象</span></span><br><span class="line">	Sales_data *p = <span class="keyword">new</span> sales_data;		<span class="comment">// p是一个内置指针</span></span><br><span class="line">	<span class="keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();<span class="comment">// p2是一个shared_ptr</span></span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;	<span class="comment">//拷贝构造函数将*p拷贝到item中</span></span><br><span class="line">	vector&lt;sales_data&gt; vec;	<span class="comment">//局部对象</span></span><br><span class="line">	vec.<span class="built_in">push_back</span> (*p2);	<span class="comment">//拷贝 p2指向的对象</span></span><br><span class="line">    <span class="keyword">delete</span> p;	<span class="comment">//对p指向的对象执行析构函数</span></span><br><span class="line">&#125;<span class="comment">//退出局部作用域;对item、p2和vec调用析构函数</span></span><br><span class="line"><span class="comment">//销毁p2会递减其引用计数;如果引用计数变为0，对象被释放//销毁vec会销毁它的元素</span></span><br></pre></td></tr></table></figure>

<p><em>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</em></p>
<h4 id="合成的析构函数"><a href="#合成的析构函数" class="headerlink" title="合成的析构函数"></a>合成的析构函数</h4><p>概念如前，下面等同合成析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员会被自动销毁，除此之外不需要做其他事情</span></span><br><span class="line">    ~<span class="built_in">Sales_data</span>() &#123; &#125;</span><br><span class="line">	<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><h4 id="需要析构函数的类也需要拷贝和拷贝赋值"><a href="#需要析构函数的类也需要拷贝和拷贝赋值" class="headerlink" title="需要析构函数的类也需要拷贝和拷贝赋值"></a>需要析构函数的类也需要拷贝和拷贝赋值</h4><p>如果一个类需要析构函数，那么肯定也需要一个拷贝函数和一个拷贝赋值运算符。例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std: : string &amp;s = std: :<span class="built_in">string</span> () ):</span><br><span class="line">		<span class="built_in">ps</span>(<span class="keyword">new</span> std: :<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line">	<span class="comment">//错误:HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用合成拷贝，则会简单的拷贝指针成员，则有可能多个对象指向相同内存。</p>
<h4 id="需要拷贝操作的类也需要赋值，反之亦然"><a href="#需要拷贝操作的类也需要赋值，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值，反之亦然"></a>需要拷贝操作的类也需要赋值，反之亦然</h4><p>作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个铂贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是，这个类不需要自定义析构函数。</p>
<h3 id="使用-defult"><a href="#使用-defult" class="headerlink" title="使用=defult"></a>使用=defult</h3><p>这段代码可以显示的要求编译生成合成版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//拷贝控制成员;使用default</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">sales_data</span>(<span class="keyword">const</span> sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    sales_data&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> sales_data &amp;);</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>使用此语句，合成函数将隐式声明为内联，如果不希望是内联的，应该对类外使用它（如上面的拷贝赋值）。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>对于某些类来说，拷贝和赋值时没有意义的，如iostream，所以组织拷贝，以避免多个对象的写入过读取相同的IO缓冲。</p>
<h4 id="定义删除的函数"><a href="#定义删除的函数" class="headerlink" title="定义删除的函数"></a>定义删除的函数</h4><p>通过将拷贝和拷贝赋值函数定义为<strong>删除的函数</strong>来组织拷贝，这是一种我们虽然声明，但不能使用的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">	<span class="built_in">Nocopy</span> () = <span class="keyword">default</span>;	<span class="comment">//使用合成的默认构造函数</span></span><br><span class="line">	<span class="built_in">NoCopy</span>(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">//阻止拷贝</span></span><br><span class="line">	NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Nocopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;	<span class="comment">//使用合成的析构函数</span></span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与=default不同：</p>
<ul>
<li>=delete必须在函数第一次声明的时候出现，而=default知道编译器生成代码时才需要，可以出现在定义处。</li>
<li>另一个是可以对任意函数使用（虽然主要是阻止拷贝），但=default只可以使用在有合成版本的函数。</li>
</ul>
<h4 id="析构函数不能删除"><a href="#析构函数不能删除" class="headerlink" title="析构函数不能删除"></a>析构函数不能删除</h4><p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。所以不可删除。</p>
<h4 id="合成的拷贝控制成员可能是删除的"><a href="#合成的拷贝控制成员可能是删除的" class="headerlink" title="合成的拷贝控制成员可能是删除的"></a>合成的拷贝控制成员可能是删除的</h4><p>本质上，这些规则的含义是:如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。</p>
<h4 id="private拷贝控制"><a href="#private拷贝控制" class="headerlink" title="private拷贝控制"></a>private拷贝控制</h4><p>新标准以前，组织是通过将函数放在private里的，但现在应该使用=delete。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>类行对象有两种拷贝语意，一种像值：拷贝像值对象，副本和源对象完全独立，改变副本不会对源对象有影响，如string。一种像指针：拷贝这种对象，共同使用底层数据，改变自己也会改变源对象，如shared_ptr。</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>像值的行为，每个对象应该拥有一份自己的拷贝。HasPtr</p>
<ul>
<li>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</li>
<li>定义一个析构函数来释放string</li>
<li>定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝string</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">		<span class="built_in">ps</span> (<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="comment">//对ps指向的string，每个HasPtr对象都有自己的拷贝</span></span><br><span class="line">    <span class="built_in">HasPtr</span> (<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">		<span class="built_in">ps</span> (<span class="keyword">new</span> std::<span class="built_in">string</span>(*p.ps)) , <span class="built_in">i</span>(p.i) &#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="类值拷贝赋值运算符"><a href="#类值拷贝赋值运算符" class="headerlink" title="类值拷贝赋值运算符"></a>类值拷贝赋值运算符</h4><p>赋值类运算符通常是组合了析构和构造函数，赋值的操作其实会销毁左侧运算对象的资源，其次需要保证再异常发发生时代码也是安全的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span> ( *rhs.ps); <span class="comment">//拷贝底层string</span></span><br><span class="line">	<span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">	ps = newp;<span class="comment">//从右侧运算对象拷贝数据到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写赋值运算符时，有两点需要记住:</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和铂贝构造函数的工作。</li>
</ul>
<p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后,销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
<p>如果直接删除自身数据，然后将指针指向赋予对象的数据，那么在将自身赋予自身时就会出现访问无效内存的异常。</p>
<h3 id="定义行为像指针"><a href="#定义行为像指针" class="headerlink" title="定义行为像指针"></a>定义行为像指针</h3><p>这个类拷贝指针成员本身不是它指向的string，我们的类拷贝时拷贝的是指针而不是指向的对象。同时在析构时也需要在最后一个指向对象的HasPtr销毁时，销毁对象。</p>
<p>这时就需要一个类似引用计数的东西，类似shared_ptr。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>它的工作方式：</p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
</ul>
<p>计时器不可以放在类中，否则无法正确更新它，最好的办法就是保存在动态内存中，把它当作底层数据，多个对象共享，同样在最后一个指向它的对象销毁时销毁。</p>
<h4 id="定义使用引用计数的类"><a href="#定义使用引用计数的类" class="headerlink" title="定义使用引用计数的类"></a>定义使用引用计数的类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数分配新的string和新的计数器，将计数器置为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span> ()):</span><br><span class="line">		<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p) :</span><br><span class="line">		<span class="built_in">ps</span>(p.ps) , <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123;++*use;&#125;</span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">	~<span class="built_in">HasPtr</span> ();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string *ps;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	std::<span class="keyword">size_t</span> *use; <span class="comment">//用来记录有多少个对象共享*ps 的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="拷贝与析构"><a href="#拷贝与析构" class="headerlink" title="拷贝与析构"></a>拷贝与析构</h4><p>当拷贝时，应该复制指针本身，并且递增关联的计数器。析构不能无脑delete，必须注意计数器数量，到0才可以delete。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span> (―-*use ==<span class="number">0</span>)&#123;<span class="comment">//如果引用计数变为0</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">//释放string内存</span></span><br><span class="line">		<span class="keyword">delete</span> use; <span class="comment">//释放计数器内存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	++*rhs.use; <span class="comment">//递增右侧运算对象的引用计数</span></span><br><span class="line">	<span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;<span class="comment">//然后递减本对象的引用计数</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">//如果没有其他用户</span></span><br><span class="line">		<span class="keyword">delete</span> use;<span class="comment">//释放本对象分配的成员</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;	<span class="comment">//将数据从rhs拷贝到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>通常的资源管理类都会有swap函数。如果类定义了自己的swap，算法将使用自定义版本，否则会使用标准库的swap，一次交换操作实际上包含了一次拷贝和两次赋值。如：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">HasPtr temp = v1;	//创建v1的值的一个临时副本</span><br><span class="line">v1 = v2.;	//将v2的值赋予v1</span><br><span class="line">v2 = temp;	//将保存的v1的值赋予v2</span><br></pre></td></tr></table></figure>

<p>但理论上可以省取这些内存分配的过程，直接交换指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *temp = v1.ps;	<span class="comment">//为v1.ps中的指针创建一个副本</span></span><br><span class="line">vl.ps = v2.ps;	<span class="comment">//将v2.ps 中的指针赋予v1.ps</span></span><br><span class="line">v2.ps = temp;	<span class="comment">//将保存的v1.ps中原来的指针赋予v2.ps</span></span><br></pre></td></tr></table></figure>

<h4 id="编写swap函数"><a href="#编写swap函数" class="headerlink" title="编写swap函数"></a>编写swap函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp; )</span> </span>;</span><br><span class="line">    <span class="comment">//其他成员定义，与13.2.1节（第 453页）中一样</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(HasPtr &amp;lhs,HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span> (lhs.ps, rhs.ps);	<span class="comment">//交换指针，而不是string数据</span></span><br><span class="line">    <span class="built_in">swap</span> (lhs.i, rhs.i) ;	<span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将swap定义为friend，一遍能够访问HasPtr的数据成员。swap不是必要的，但是重要的优化手段。</p>
<h4 id="与std-swap不同"><a href="#与std-swap不同" class="headerlink" title="与std::swap不同"></a>与std::swap不同</h4><p>使用时不应该加上std::</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span> ( lhs.h, rhs.h) ; <span class="comment">//使用HasPtr版本的swap</span></span><br><span class="line">    <span class="comment">//交换类型Foo的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在赋值运算中使用swap"><a href="#在赋值运算中使用swap" class="headerlink" title="在赋值运算中使用swap"></a>在赋值运算中使用swap</h4><p>定义swap后会用来用它定义赋值运算符。是将左侧对象与右侧对象的副本进行交换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数</span></span><br><span class="line"><span class="comment">//将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>= (HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交换左侧运算对象和局部变量rhs的内容</span></span><br><span class="line">	<span class="built_in">swap</span> (*<span class="keyword">this</span>, rhs);	<span class="comment">// rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//rhs被销毁，从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此版本参数不是引用，因此右侧传递进来的是一个副本，所以不需要额外的拷贝操作，它保证异常安全的同时也与原来的赋值运算实现一样。</p>
<h2 id="拷贝控制示例（单独成章）"><a href="#拷贝控制示例（单独成章）" class="headerlink" title="拷贝控制示例（单独成章）"></a>拷贝控制示例（单独成章）</h2><h2 id="动态内存管理类（单独成章）"><a href="#动态内存管理类（单独成章）" class="headerlink" title="动态内存管理类（单独成章）"></a>动态内存管理类（单独成章）</h2><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准中有可以移动而非拷贝的能力。很多时候对象拷贝完立刻被销毁了，移动可以大大提升性能。移动的另一个原因是源于IO类或unique_ptr这样的类包含不能被共享的资源，所以可以移动不能拷贝。</p>
<p><em>标准库容器、string和shared ptr类既支持移动也支持拷贝。IO类和unique ptr类可以移动但不能拷贝。</em></p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>符号为&amp;&amp;，它必须绑定到右值且只能绑定到一个将要销毁的对象，所以可以自由的移动到另一个对象中。</p>
<p>回忆左值和右值：一般而言，一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值。</p>
<p>右值引用也不过是对象的另一个名字，对于常规引用，我们可以称之为左值引用。</p>
<p>区别：我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;<span class="keyword">int</span> &amp;r n i;	<span class="comment">//正确:r引用i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;			<span class="comment">//错误:不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;		<span class="comment">//错误:i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>;<span class="comment">//正确:我们可以将一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;		<span class="comment">//正确:将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。<ul>
<li>我们可以将一个左值引用绑定到这类表达式的结果上。</li>
</ul>
</li>
<li>返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。<ul>
<li>我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const的左值引用或者一个右值引用绑定到这类表达式上。</li>
</ul>
</li>
</ul>
<h4 id="左值持久：右值短暂"><a href="#左值持久：右值短暂" class="headerlink" title="左值持久：右值短暂"></a>左值持久：右值短暂</h4><p>考察左值和右值表达式的列表，两者相互区别之处就很明显了:左值有持久的状态,而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。所以</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<h4 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h4><p>变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是,我们不能将一个右值引用绑定到一个右值引用类型的变量上,这有些令人惊讶:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;<span class="comment">//正确:字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">//错误:表达式rr1是左值!</span></span><br></pre></td></tr></table></figure>

<p>其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。</p>
<h4 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h4><p>虽然不能将右值引用绑定到左值，但可以显示将左值转换为对应右值引用类型，我们可以调用move来获得绑定到左值上的右值引用，在头文件utility中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span> (rr1); l l ok</span><br></pre></td></tr></table></figure>

<p>move对左值使用之后，可以像右值一样处理，但之后除了赋值或者销毁它外，但不能使用该对象的值。且应该直接使用std::move。</p>
<h3 id="移动构造和移动赋值函数"><a href="#移动构造和移动赋值函数" class="headerlink" title="移动构造和移动赋值函数"></a>移动构造和移动赋值函数</h3><p>我们可以为自己的类定义移动操作，他们就是从给定对象窃取而不是拷贝资源。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态—–销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源—–这些资源的所有权已经归属新创建的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strVec::<span class="built_in">strVec</span> (strVec &amp;&amp;s) <span class="keyword">noexcept</span><span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line"><span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">	: <span class="built_in">elements</span> (s.elements), <span class="built_in">first_free</span> (s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">	s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与拷贝构造函数不同，移动构造函数不分配任何新内存;它接管给定的Strvec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。strVec的析构函数在first_free 上调用deallocate。如果我们忘记了改变s.first free，则销毁移后源对象就会释放掉我们刚刚移动的内存。</p>
<h4 id="移动操作与异常"><a href="#移动操作与异常" class="headerlink" title="移动操作与异常"></a>移动操作与异常</h4><p>由于移动操作不分配任何资源，所以不会抛出任何异常，我们应该将此事通知给标准库，提升一些性能消耗。</p>
<p>方法就是在小括号之后冒号之前加上noexcept</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strvec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Strvec</span>(strvec&amp; &amp;)<span class="keyword">noexcept</span>; <span class="comment">//移动构造函数//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">	StrVec::<span class="built_in">StrVec</span> (StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/*成员初始化器*/</span>&#123;<span class="comment">/*构造函数体*/</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p>它与移动构造函数一个，应该标记为noexcept：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//直接检测自赋值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">		<span class="built_in">free</span>();	<span class="comment">//释放已有元素</span></span><br><span class="line">		elements = rhs.elements; <span class="comment">//从rhs接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">		cap = rhs.cap;</span><br><span class="line">		<span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">		rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多了一步操作就是检测this与rhs地址是否相同，也就是是否是同一个对象（这也是赋值运算需要重点考虑的：将自身赋予自身时能否不出错）。如果相同什么都不用做。</p>
<h4 id="移后源可以析构"><a href="#移后源可以析构" class="headerlink" title="移后源可以析构"></a>移后源可以析构</h4><p>编写移动操作必须保证移后对象可析构，在strVec中，将移后源对象的指针成员设置为nullptr来实现。</p>
<h4 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h4><p>编译器不会为某些类生成合成的移动函数，如果没有移动函数，类会使用对应的拷贝操作来代替移动。</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasx合成移动操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;			<span class="comment">//内置类型可以移动</span></span><br><span class="line">	std::string s;	<span class="comment">//string定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasx</span> &#123;</span></span><br><span class="line">	X mem;			<span class="comment">//×有合成的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">X x,x2 = std::<span class="built_in">move</span>(x) ;<span class="comment">//使用合成的移动构造函数</span></span><br><span class="line">hasx hx,hx2 = std::<span class="built_in">move</span> (hx) ;<span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>移动操作只有当我们显示要求编译器生成=default的移动操作而却不是所有成员都可以移动时才会将移动操作定义为删除的函数。</p>
<h4 id="移动右值，拷贝左值"><a href="#移动右值，拷贝左值" class="headerlink" title="移动右值，拷贝左值"></a>移动右值，拷贝左值</h4><p>如果一共类既有移动函数也有拷贝构造函数，那么会根据匹配规则使用，如在strvec类中，拷贝构造函数接受一个 const strvec的引用。因此，它可以用于任何可以转换为strVec的类型。而移动构造函数接受一个strVec&amp;&amp;，因此只能用于实参是（非static）右值的情形:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec v1, v2 ;</span><br><span class="line">v1 = v2;					<span class="comment">// v2是左值;使用拷贝赋值</span></span><br><span class="line"><span class="function">Strvec <span class="title">getvec</span><span class="params">(istream &amp;)</span></span>;	<span class="comment">// getvec返回一个右值</span></span><br><span class="line">v2 = <span class="built_in">getvec</span> (cin) ;			<span class="comment">// getVec (cin)是一个右值;使用移动赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="如果没有移动构造，会调用拷贝"><a href="#如果没有移动构造，会调用拷贝" class="headerlink" title="如果没有移动构造，会调用拷贝"></a>如果没有移动构造，会调用拷贝</h4><p>由于不会默认合成移动构造，所以用拷贝代替，且是绝对安全的</p>
<h4 id="拷贝赋值和移动赋值合并"><a href="#拷贝赋值和移动赋值合并" class="headerlink" title="拷贝赋值和移动赋值合并"></a>拷贝赋值和移动赋值合并</h4><p>如果为类添加一个移动构造函数，实际上也会获得移动赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//添加的移动构造函数</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : <span class="built_in">ps</span> (p.ps), <span class="built_in">i</span>(p.i)&#123;p.ps = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">//赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">						&#123; <span class="built_in">swap</span> (*<span class="keyword">this</span>, rhs); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="comment">//其他成员的定义，同13.2.1节（第453页)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<strong>左值被拷贝，右值被移动</strong>。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。<br>例如，假定hp和 hp2都是HasPtr对象:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hp = hp2; <span class="comment">// hp2是一个左值;hp2通过拷贝构造函数来拷贝</span></span><br><span class="line">hp = std::<span class="built_in">move</span> (hp2);<span class="comment">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>

<p><strong>建议:更新三/五法则</strong><br>所有五个拷贝控制成员应该看作一个整体:一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义持贝构造函数、拷贝赋值运算符和析构函数才能正确工作。一般来说拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十二章</title>
    <url>/2022/01/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部static对象（就是局部对象加上static）、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，在其定义的程序块运行时才存在: static 对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间( free store)或堆(heap)。程序用堆来存储动态分配(dynamically allocate)的对象一即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>在C++中，动态内存的管理是通过一对运算符来完成的: <strong>new</strong>，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化; <strong>delete</strong>, 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
<p>新标准提供了两个智能指针类型类管理动态对象。他们行为类似常规指针，却可以自动的释放锁指向的对象，这两种指针的区别在于管理底层指针的方式：</p>
<p><strong>shared_ ptr</strong>允许多个指针指向同-一个对象; <strong>unique_ ptr</strong>则“独占”所指向的对象。标准库还定义了一个名为<strong>weak_ ptr</strong>的伴随类，它是一种弱引用，指向shared_ ptr所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>创建时我们也需要提供指向的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;				<span class="comment">// shared_ _ptr, 可以指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="keyword">int</span>&gt;&gt; p2;			<span class="comment">// shared_ ptr， 可以指向int的list</span></span><br></pre></td></tr></table></figure>

<p>默认初始化的指针中保存着一个空指针，</p>
<p>智能之后着呢使用方式与普通指针类似，解引用返回指向的对象，在if使用，是检测它是否为空：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果p1不为空，检查它是否指向一个空string</span></span><br><span class="line"><span class="keyword">if</span> (p1 &amp;&amp; pl-&gt;<span class="built_in">empty</span>())</span><br><span class="line">	*p1 = <span class="string">&quot;hi&quot;</span>; 			<span class="comment">//如果p1指向一个空string,解引用p1,将一个新值赋予string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/27/QGMjaLHzpiNKeFV.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/27/UYdeStwyJBpqVKG.png" alt="image.png"></p>
<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><p>他是最安全的分配和使用动态内存的方法，函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，一样要给出创建对象类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指向一个值为42的int的shared_ ptr</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="comment">// p4指向一个值为&quot;999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="number">10</span>， <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line"><span class="comment">// p5指向一个值初始化的(参见3.3.1节，第88页)int,即，值为0</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;() ;</span><br></pre></td></tr></table></figure>

<p>通常使用auto来指向它</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;() ;</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr拷贝和赋值"><a href="#shared-ptr拷贝和赋值" class="headerlink" title="shared_ptr拷贝和赋值"></a>shared_ptr拷贝和赋值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>

<p>每一个shared_ptr都会有一个关联的计数器，为引用计数。拷贝一个shared_ptr、作为参数传递给函数或者作为返回值就会递增，给shared_ptr赋予新值或者它被销毁计数器会递减。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// r指向的int只有一个引用者</span></span><br><span class="line">r = q;	<span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line">		<span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line">		<span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line">		<span class="comment">// r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr销毁管理对象"><a href="#shared-ptr销毁管理对象" class="headerlink" title="shared_ptr销毁管理对象"></a>shared_ptr销毁管理对象</h4><p>当指向一个对象的最后一个智能指针被销毁，指针的析构函数会递减指向对象的析构函数的引用计数，计数为0，指针的析构函数会销毁对象，释放内存。</p>
<p>且动态对象不再被使用时，shared_ptr类会自动的释放对象，特性使得动态内存的使用变得容易，例如在函数创建智能指针在离开作用域后会自动的释放掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// factory 返回一个shared_ ptr, 指向一个动态分配的对象</span></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function">	<span class="comment">//恰当地处理arg</span></span></span><br><span class="line"><span class="function">	<span class="comment">// shared_ ptr负责释放内存</span></span></span><br><span class="line"><span class="function">	<span class="keyword">return</span> make_shared&lt;Foo&gt; <span class="params">(arg)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function">	shared_ptr&lt;Foo&gt; P </span>= <span class="built_in">factory</span>(arg) ;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">&#125; 	<span class="comment">// p离开了作用城，它指向的内存会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<h4 id="使用了动态生存期的资源的类"><a href="#使用了动态生存期的资源的类" class="headerlink" title="使用了动态生存期的资源的类"></a>使用了动态生存期的资源的类</h4><p>程序使用动态内存出于以下三种原因之一:</p>
<ol>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ol>
<p>目前使用的类分配资源都与对应对象生存期一致。例如每个vector拥有自己的元素，当拷贝一个vector时，原vector和副本vector是相互分离的。</p>
<p>如果我们希望有一个类，当它进行拷贝时，不是拷贝其中成员，而是不同对象之间共享相同的元素。所以当两个对象共享底层数据，当其中一个被销毁，我们不能单方面的销毁底层数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Blob&lt;string&gt; bl; <span class="comment">// 空Blob</span></span><br><span class="line">&#123; 	<span class="comment">//新作用域</span></span><br><span class="line">	Blob&lt;string&gt; b2 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">	bl = b2;<span class="comment">//bl和b2共享相同的元素</span></span><br><span class="line">&#125; 	<span class="comment">// b2被销毁了，但b2中的元素不能销毁</span></span><br><span class="line">	<span class="comment">// bl指向最初由b2创建的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="定义StrBlob"><a href="#定义StrBlob" class="headerlink" title="定义StrBlob"></a>定义StrBlob</h4><p>这里想要实现一个StrBlob类管理string元素，如果我们在类内直接使用一个vector来保存元素，那么当多个对象中的一个被销毁时就会把底层vector销毁，所以这里使用vector保存在动态内存中。</p>
<p>为了实现数据共享，我们为StrBlob设置一个shared_ptr来管理动态内存分配的vector。该指针可以记录有多少个StrBlob共享相同的vector。</p>
<p>还需要提供一些操作，当访问一个不存在的元素，会抛出异常，且有一个默认构造和单一构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrB1ob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="built_in">StrBlob</span>() ;</span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il) ;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>() ; &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> std: :string &amp;t)</span> </span>&#123;data-&gt;<span class="function">push_ <span class="title">back</span><span class="params">(t)</span></span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string&amp; <span class="title">front</span> <span class="params">()</span> </span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">back</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> std::string &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="StrBlob构造函数"><a href="#StrBlob构造函数" class="headerlink" title="StrBlob构造函数"></a>StrBlob构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrBlob::<span class="built_in">StrB1ob</span> (): <span class="built_in">data</span> (make_shared&lt;vector&lt;string&gt;&gt;()) &#123; &#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span> (initializer_list&lt;string&gt; il) :</span><br><span class="line"><span class="built_in">data</span> (make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问成员函数"><a href="#元素访问成员函数" class="headerlink" title="元素访问成员函数"></a>元素访问成员函数</h4><p>由于操作访问函数需要先检查存不存在，所以定义一个私有的工具函数check：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="keyword">const</span> string &amp;msg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(i &gt;= data-&gt;size())</span>	</span></span><br><span class="line"><span class="function">	<span class="keyword">throw</span> <span class="title">out_of_range</span><span class="params">(msg)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他操作首先调用check，如成功则继续下一步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">StrBlob::front</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果vector为空，check 会抛出一个异常</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;front on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span> () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;back on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>) ;</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还应对front和back的const版本进行重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string&amp; <span class="title">StrBlob::front</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果vector为空，check 会抛出一个异常</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;front on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span> () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>，<span class="string">&quot;back on empty StrB1ob&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StrBlob的拷贝、赋值和销毁"><a href="#StrBlob的拷贝、赋值和销毁" class="headerlink" title="StrBlob的拷贝、赋值和销毁"></a>StrBlob的拷贝、赋值和销毁</h4><p>该类型对象被拷贝’赋值或者销毁时，执行相应操作的是shared_ptr成员而不是vector，直到最后一个指向vector的指针对象被销毁。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>还可以使用new和delete来分配内存，但非常容出错。</p>
<h4 id="使用new动态分配内存和初始化对象"><a href="#使用new动态分配内存和初始化对象" class="headerlink" title="使用new动态分配内存和初始化对象"></a>使用new动态分配内存和初始化对象</h4><p>new分配的内存是无名的，返回一个指向该对象的指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; 			<span class="comment">// pi指向一个动态分配的、未初始化的无名对象</span></span><br><span class="line"><span class="comment">// 默认情况下，动态分配内存是默认初始化的，意味着内置类型或组合类型的值是未定义的。</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string; 	<span class="comment">//初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;			<span class="comment">// pi指向一个未初始化的int</span></span><br></pre></td></tr></table></figure>

<p>也可以使用列表初始化，或值初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);			<span class="comment">// pi指向的对象的值为1024</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>， <span class="string">&#x27;9&#x27;</span>);	<span class="comment">// *ps 为&quot;999999999&quot;</span></span><br><span class="line"><span class="comment">// vector 有10个元素，值依次从0到9</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">string *ps1 = <span class="keyword">new</span> string;			<span class="comment">//默认初始化为空string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>() ;			<span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pil = <span class="keyword">new</span> <span class="keyword">int</span>;					<span class="comment">//默认初始化; *pi1 的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();					<span class="comment">//值初始化为0; *pi2为0</span></span><br></pre></td></tr></table></figure>

<p>建议对动态分配的对象进行初始化操作。</p>
<p>如果提供了一个括号包围的初始化器，可以使用auto自动接管动态内存，但括号内必须仅有单一初始化器才可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span> (obj) ;				<span class="comment">// p指向一个与obj类型相同的对象</span></span><br><span class="line"><span class="comment">//该对象用obj进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125; ;				<span class="comment">// 错误:括号中只能有单个初始化器</span></span><br></pre></td></tr></table></figure>

<h4 id="动态分配const对象"><a href="#动态分配const对象" class="headerlink" title="动态分配const对象"></a>动态分配const对象</h4><p>一个动态内存的const对象必须进行初始化，对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显示初始化。new返回的也是一个const指针。</p>
<h4 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h4><p>当程序用光了所有可用内存，new就会失败，会抛出一个bad_alloc的异常，可以改变new的方式来阻止异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>; <span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p>这种new为<strong>定位new</strong>，这种形式允许我们传递额外参数，nothow就是告诉它不能抛出异常。以上类型都在头文件new中。</p>
<h4 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h4><p>我们使用delete来释放内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure>

<p>但传递给delete的指针必须是指向动态分配的内存或空指针，其他行为是未定义的。</p>
<p>const对象的值不能被改变，但是本身可以销毁，同样delete指向它的指针。</p>
<h4 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h4><p>如果不使用智能指针，那么必须显示的释放它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// factory 返回一个指针，指向一个动态分配的对象</span></span><br><span class="line"><span class="function">Foo* <span class="title">factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//视情况处理arg</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>(arg);	 <span class="comment">// 调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Foo *p = <span class="built_in">factory</span>(arg) ;	<span class="comment">//使用p但不delete它</span></span><br><span class="line">&#125;<span class="comment">//p离开了它的作用域，但它所指向的内存没有被释放!</span></span><br></pre></td></tr></table></figure>

<p>所以必须在use_factory中delete掉这个p，或者return出去让外部释放。</p>
<p><em>坚持使用智能指针，避免所有这些问题。</em></p>
<h4 id="delete之后重置指针"><a href="#delete之后重置指针" class="headerlink" title="delete之后重置指针"></a>delete之后重置指针</h4><p>delete指针之后，指针值就无效了，虽然指针已经无效，但有些仍保存着地址，为<strong>空悬指针</strong>：即指向一块曾经保存数据对象但现在已经无效的内存指针。</p>
<p>它和未初始化指针很像，解决办法是，在指针即将离开其作用域之前释放它所关联的内存，这样没有机会继续使用，也可以在delete之后给其赋值为nullptr。</p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>我们可以用new返回的指针来初始化智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">double</span>&gt; p1; 			<span class="comment">//shared_ ptr可以指向一个double</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; 	<span class="comment">//p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>接受参数的智能指针是explicit的，因此我们不能将一个内置指针隐式转换为智能指针，必须使用直接初始化形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">1024</span>);		<span class="comment">// 错误:必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;			<span class="comment">// 正确:使用了直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p) ; <span class="comment">// 错误:隐式转换为shared ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">shared_ ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> shared_ ptr&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p)) ;<span class="comment">//正确:显式地用int*创建shared_ ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可混用普通与智能指针"><a href="#不可混用普通与智能指针" class="headerlink" title="不可混用普通与智能指针"></a>不可混用普通与智能指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>))</span> </span>;</span><br><span class="line"><span class="comment">//危险: x是一个普通指针，不是一个智能指针</span></span><br><span class="line"><span class="built_in">process</span>(x); <span class="comment">//错误:不能将int*转换为一个shared_ ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(shared_ptr&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">// 合法的，但内存会被释放!</span></span><br><span class="line"><span class="keyword">int</span> j = *x;<span class="comment">//未定义的:x是一个空悬指针!</span></span><br></pre></td></tr></table></figure>

<p>将临时的shared_ptr传递给函数，在调用结束后就会被销毁，则x变为空悬指针。</p>
<p>当将一个shared_ptr绑定到一个 普通指针时，我们就将内存的管理责任交给了这个shared_ptr.-旦这样做了 ，我们就不应该再使用内置指针来访问shared__ptr所指向的内存了。</p>
<h4 id="也不要使用get初始化另一个智能指针或者为智能指针赋值"><a href="#也不要使用get初始化另一个智能指针或者为智能指针赋值" class="headerlink" title="也不要使用get初始化另一个智能指针或者为智能指针赋值"></a>也不要使用get初始化另一个智能指针或者为智能指针赋值</h4><p>智能指针定义了名为get的函数，返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况二设计的：是为了不能使用智能指针的代码使用，但此指针不能delete。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//引用计数为1</span></span><br><span class="line"><span class="keyword">int</span> *q = p.<span class="built_in">get</span>(); <span class="comment">//正确:但使用q时要注意，不要让它管理的指针被释放</span></span><br><span class="line">&#123; <span class="comment">//新程序块</span></span><br><span class="line"><span class="comment">//未定义:两个独立的shared_ptr指向相同的内存</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; (q) ;</span><br><span class="line">&#125; <span class="comment">//程序块结束，q被销毁，它指向的内存被释放</span></span><br><span class="line"><span class="keyword">int</span> foo = *p; <span class="comment">//未定义: p指向的内存已经被释放了</span></span><br></pre></td></tr></table></figure>

<h4 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h4><p>使用reset将一个新指针赋予它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>) ;		<span class="comment">//错误:不能将一个指针赋予shared_ ptr</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">1024</span>)) ;	<span class="comment">//正确: p指向一个新对象</span></span><br></pre></td></tr></table></figure>

<p>通常与unique一起使用，控制多个shared_ptr共享的对象，检查自己是当前对象仅有的用户，如果不是，在改变之前要做一次新的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">	p.<span class="built_in">reset</span> (<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">// 我们不是唯一用户;分配新的拷贝</span></span><br><span class="line">*p += newVal; <span class="comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>

<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>在函数中使用智能指针，即使函数发生了异常，局部对象也会被销毁，而如果使用new，则在delete之前出现异常不会自动释放。</p>
<h4 id="智能指针指针和哑类"><a href="#智能指针指针和哑类" class="headerlink" title="智能指针指针和哑类"></a>智能指针指针和哑类</h4><p>有一些为C和C++两种语言设计的类，通常要求用户显示的释放所使用的任何资源。我们可以使用管理动态内存类似的技术管理不具有良好定义的析构函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span>						<span class="comment">//表示我们正在连接什么</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span>						<span class="comment">//使用连接所需的信息</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span> <span class="params">(destination*)</span> </span>;		<span class="comment">//打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connection)</span> </span>;			<span class="comment">//关闭给定的连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/*其他参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获得一个连接;记住使用完后要关闭它</span></span><br><span class="line">	connection C = <span class="built_in">connect</span>(&amp;d) ;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//如果我们在f退出前忘记调用disconnect,就无法关闭c了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果connection没有析构函数，就会造成内存泄漏，可以使用shared_ptr保证connection被正确关闭。</p>
<h4 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h4><p>首先定义一个函数来代替delete，这个<strong>删除器</strong>函数必须能够完成对shared_ptr保存的指针进行释放的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span> <span class="params">(connection *p)</span> </span>&#123; <span class="built_in">disconnect</span>(*p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(destination &amp;d <span class="comment">/*其他参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	connection C = <span class="built_in">connect</span> (&amp;d) ;</span><br><span class="line">	<span class="function">shared_ptr&lt;connection&gt; <span class="title">P</span><span class="params">(&amp;C, end_connection)</span> </span>;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//当f退出时(即使是由于异常而退出), connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当p被销毁时，他会使用end_connection来代替delste，从而确保链接关闭。</p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的<br>前提下。为了正确使用智能指针，我们必须坚持一些基本规范:</p>
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针。</li>
<li>不delete get()返回的指针。</li>
<li>不使用get()初始化或reset另一个智能指针。</li>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr“拥有”它所指的对象，且只能有一个unique_ptr指向给定对象，指针被销毁时对象也会被销毁。定义它时，没有make_shared类似的函数，需要绑定一个new返回的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ ptr &lt;<span class="keyword">double</span>&gt; p1; <span class="comment">//可以指向一个double的unique_ ptr</span></span><br><span class="line"><span class="function">unique_ ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>且不支持拷贝或赋值操作</p>
<p><img src="https://s2.loli.net/2022/02/04/UGd3SAoe1xhXtra.png" alt="image.png"></p>
<p>但可以通过调用release或reset将指针转移所有权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将所有权从p1 (指向string Stegosaurus)转移给p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">// release 将p1置为空</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">//将所有权从p3转移给p2</span></span><br><span class="line">p2.<span class="built_in">reset</span> (p3.<span class="built_in">release</span>()); <span class="comment">// reset 释放了p2原来指向的内存</span></span><br></pre></td></tr></table></figure>

<p>release成员返回unique_ptr当前保存的指针并置空，并且切断了它和原指针的联系，如果不移交给智能指针，一定要delete。</p>
<p>reset成员接受可选指针，然后重新指向给定指针。</p>
<h4 id="函数中的unique-ptr"><a href="#函数中的unique-ptr" class="headerlink" title="函数中的unique_ptr"></a>函数中的unique_ptr</h4><p>我们可以拷贝或赋值一个精要呗销毁的unique_ptr，如函数返回它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//正确:从int*创建一个unique_ ptr&lt;int&gt;</span></span><br><span class="line"><span class="keyword">return</span> unique_ ptr&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(p) ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以返回一个局部对象的拷贝:</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (p) )</span> </span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种特殊的拷贝，将在之后介绍它。</p>
<h4 id="传递删除器"><a href="#传递删除器" class="headerlink" title="传递删除器"></a>传递删除器</h4><p>与shared_ptr类似，可以重载删除器，一样需要提供删除器类型，在创建或reset时提供指定类型的可调用的删除器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT, delT&gt; <span class="title">P</span> <span class="params">(<span class="keyword">new</span> objT, fcn)</span> </span>;</span><br></pre></td></tr></table></figure>

<p>用unique_ptr代替shared_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/*其他需要的参数*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	connection c = <span class="built_in">connect</span> (&amp;d); <span class="comment">//打开连接</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接将会关闭</span></span><br><span class="line">	<span class="function">unique_ptr&lt;connection, <span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">P</span><span class="params">(&amp;C， end_connection)</span> </span>;</span><br><span class="line">	<span class="comment">//使用连接</span></span><br><span class="line">	<span class="comment">//当f退出时(即使是由于异常而退出), connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中我们使用了decltype来指明函数指针类型。由于decltype (end_ connection) 返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>它是一种不控制所指向对象生存期的智能指针，它指向由一个shared（后面都简写）管理的对象将weak绑定到shared不会增加shared的引用计数，计数归0，即使有weak对象也会被释放。weak名字意为这种指针“弱”共享对象。</p>
<p><img src="https://s2.loli.net/2022/02/04/H8pSNcUh6Z9yQzO.png" alt="image.png"></p>
<p>创建weak时需要用shared初始化它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> P = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; <span class="comment">// wp弱共享p; p的引用计数未改变</span></span><br></pre></td></tr></table></figure>

<p>因为weak若共享特性，它指向的对象可能不存在，所以在访问时必须调用lock判断，它返回一个指向共享对象的shared：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">//如果np不为空则条件成立</span></span><br><span class="line"><span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核查指针类"><a href="#核查指针类" class="headerlink" title="核查指针类"></a>核查指针类</h4><p>如果将StrBolb类定义一个伴随指针，保存一个weak_ptr，指向StrBolob的data成员，使用weak不会影响StrBlob指向vector的生存期，但可以阻止用户访问不存在的vector。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于访问一个不存在元素的尝试，StrBlobPtr抛出一个异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StrBlobPtr</span>():<span class="built_in">curr</span> (<span class="number">0</span>) &#123; &#125;</span><br><span class="line">	<span class="built_in">StrBlobPtr</span>(StrB1ob &amp;a， <span class="keyword">size_t</span> sz = <span class="number">0</span>) :</span><br><span class="line">	<span class="built_in">wptr</span>(a.data)，<span class="built_in">curr</span>(sz) &#123; &#125;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">deref</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">StrBlobPtr&amp; <span class="title">incr</span><span class="params">()</span></span>; <span class="comment">// 前缀递增</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//若检查成功，check返回一个指向vector的shared_ptr</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</span><br><span class="line">	<span class="built_in">check</span>(std::<span class="keyword">size_t</span>，<span class="keyword">const</span> std::string&amp;) <span class="keyword">const</span> ;</span><br><span class="line">	<span class="comment">//保存一个weak_ptr,意味着底层vector可能会被销毁</span></span><br><span class="line">	std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr;</span><br><span class="line">	std::<span class="keyword">size_t</span> curr; <span class="comment">// 在数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此类需要注意不能将StrBlobPtr绑定到一个const StrBlob对象是因为构造函数只接受非const对象的引用</p>
<p>check函数也与之前不同需要检查指向的vector是否还存在：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;std: :vector&lt;std: :string&gt;&gt;</span><br><span class="line">StrBlobPtr::<span class="built_in">check</span>(std::<span class="keyword">size_t</span> i, <span class="keyword">const</span> std::string &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> ret = wptr.<span class="built_in">lock</span>(); <span class="comment">// vector还存在吗?</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">&quot;unbound StrBlobPtr&quot;</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= ret-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span> (msg) ;</span><br><span class="line">	<span class="keyword">return</span> ret; <span class="comment">// 否则，返回指向vector的shared_ptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><p>现在我们将定义deref和incr的函数来解引用和递增StrBlobPtr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">StrBlobPtr::deref</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span> (*p)[curr]; <span class="comment">// (*p) 是对象所指向的vector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前缀递增:返回递增后的对象的引用</span></span><br><span class="line"><span class="function">StrBlobPtr&amp; <span class="title">StrBlobPtr::incr</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果curr已经指向容器的尾后位置，就不能递增它</span></span><br><span class="line">	<span class="built_in">check</span>(curr, <span class="string">&quot; increment past end of StrBlobPtr&quot;</span>) ;</span><br><span class="line">	++curr; <span class="comment">//推进当前位置</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外为了访问data成员需要声明StrBlob的friend</span></span><br><span class="line"><span class="comment">//对于StrBlob 中的友元声明来说， 此前置声明是必要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line">	<span class="comment">//其他成员与12.1.1节(第405页)中声明相同</span></span><br><span class="line">	<span class="comment">//返回指向首元素和尾后元素的StrBlobPtr</span></span><br><span class="line">	<span class="function">StrBlobPtr <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">StrBlobPtr</span>(*<span class="keyword">this</span>) ; &#125;</span><br><span class="line">	<span class="function">StrBlobPtr <span class="title">end</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">auto</span> ret = <span class="built_in">StrBlobPtr</span>(*<span class="keyword">this</span>， data-&gt;<span class="built_in">size</span>()); <span class="keyword">return</span> ret;&#125;</span><br><span class="line">    <span class="comment">//这里就是</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>如果需要可变数量的对象时，可以使用在StraBlob中采取的方法。</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用get_size确定分配多少个int</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">get_size</span>()]; <span class="comment">// pia指向第一个int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用一个表示数组类型的类型别名分配：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];	<span class="comment">// arrT表示42个int的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;		<span class="comment">//分配一个42个int的数组; p指向第一个int</span></span><br></pre></td></tr></table></figure>

<p>最后的代码等于<code>int *P new int[42];</code></p>
<p>在分配后得到元素类型的指针，所以不能使用begin或end，不可以用范围for来处理动态数组的元素</p>
<p><strong>要记住我们所说的动态数组并不是数组类型，这是很重要的。</strong></p>
<h4 id="初始化动态分配的数组"><a href="#初始化动态分配的数组" class="headerlink" title="初始化动态分配的数组"></a>初始化动态分配的数组</h4><p>可以使用默认初始化或者值初始化（跟一对空括号）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];				<span class="comment">// 10 个未初始化的int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]() ;		<span class="comment">// 10个值初始化为0的int</span></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>] ;		<span class="comment">// 10个空string .</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>](); 	<span class="comment">// 10 个空string</span></span><br></pre></td></tr></table></figure>

<p>还可以提供初始化器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10个int分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//10个string,前4个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>]&#123;<span class="string">&quot;a&quot;</span>， <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>) &#125;;</span><br></pre></td></tr></table></figure>

<p>与内置初始化一样，初始化器会初始化开始部分的元素，剩余执行值初始化。</p>
<p>我们不可以在括号内给出初始化器，且不能用auto分配数组。</p>
<h4 id="动态分配空数组"><a href="#动态分配空数组" class="headerlink" title="动态分配空数组"></a>动态分配空数组</h4><p>可以用任意表达式唉确定分配相对数目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = <span class="built_in">get_size</span>(); 	<span class="comment">//get_size 返回需要的元素的数目</span></span><br><span class="line"><span class="keyword">int</span>* P = <span class="keyword">new</span> <span class="keyword">int</span>[n];		<span class="comment">//分配数组保存元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>* q = p; q != p + n; ++q) .</span><br><span class="line">	<span class="comment">/*处理数组*/</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即使为0，也能够正常运作</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">0</span>] ;			<span class="comment">//错误:不能定义长度为0的数组.</span></span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]; <span class="comment">// 正确:但cp不能解引用</span></span><br></pre></td></tr></table></figure>

<p>cp可以就像尾后迭代器一样使用</p>
<h4 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> P;		<span class="comment">// p必须指向一个动态分配的对象或为空</span></span><br><span class="line"><span class="keyword">delete</span> [] pa; 	<span class="comment">//pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure>

<p>释放元素是按逆序销毁，且方括号是必须的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>] ;		<span class="comment">// arrT是42个int的数组的类型别名</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;			<span class="comment">//分配一个42个int的数组; p指向第一个元素</span></span><br><span class="line"><span class="keyword">delete</span> [] p;				<span class="comment">//方括号是必需的，因为我们当初分配的是一个数组</span></span><br></pre></td></tr></table></figure>

<h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><p>标准库提供了一个可以管理new分配的数组的unique版本。但必须在对象后跟一对空方括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//up指向一个包含10个未初始化int的数组</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">up</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span> </span>;</span><br><span class="line">up.<span class="built_in">release</span>(); <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>

<p>当一个unique指向一个数组时，我们可以使用下标运算来访问数组中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="number">10</span>; ++i)</span><br><span class="line">	up[i] = i; <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/04/Swc3g5LlOX2bQsx.png" alt="image.png"></p>
<p>与unique不同的是shared不支持管理动态数组。如果希望使用shared管理动态数组需要自定义删除器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr，必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]， [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] P; &#125;)</span> </span>;</span><br><span class="line">sp.<span class="built_in">reset</span>(); <span class="comment">//使用我们提供的lambda释放数组，它使用delete []</span></span><br></pre></td></tr></table></figure>

<p>这里直接传递一个lambda表达式作为删除器。如果不提供删除器，则后果与delete不加[]一样。此外他也不支持下标运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shared_ ptr未定义下标运算符，并且不支持指针的算术运算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="number">10</span>; ++i)</span><br><span class="line">	* (sp.<span class="built_in">get</span>() + i) = i; <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure>

<p>所以只能使用get获取内置指针来访问数组元素</p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些缺陷：因为它将内存分配与对象构造组合在一起，所以会导致不必要的浪费：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *<span class="keyword">const</span> P = <span class="keyword">new</span> string[n]; <span class="comment">// 构造n个空string</span></span><br><span class="line">string s;</span><br><span class="line">string *q = P;		<span class="comment">// q指向第一个string</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; s &amp;&amp; q != P + n)</span><br><span class="line">	*q++ = s;			<span class="comment">//赋予*q一个新值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> size = q - P;		<span class="comment">//记住我们读取了多少个string</span></span><br><span class="line"><span class="comment">//使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// P指向一个数组;记得用delete[]来释放</span></span><br></pre></td></tr></table></figure>

<p>这里创建了n个string，但可能并不需要这么多，所以造成了浪费。</p>
<h4 id="新的方法allocalltor"><a href="#新的方法allocalltor" class="headerlink" title="新的方法allocalltor"></a>新的方法allocalltor</h4><p>它定义在头文件memory中，帮助我们将内存分配和对象构造分开。分配时需要给出类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;				<span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> P = alloc.<span class="built_in">allocate</span> (n) ;		<span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/04/CaKVzphwGWYIXc4.png" alt="image.png"></p>
<h4 id="分配未构造的内存"><a href="#分配未构造的内存" class="headerlink" title="分配未构造的内存"></a>分配未构造的内存</h4><p>使用alloc.construct构造对象，额外的参数用于调用对象的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; 						<span class="comment">//q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);				<span class="comment">//*q为空字符串</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++，<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);		<span class="comment">//*q为cccccccccc  </span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hi&quot;</span>);			 <span class="comment">//*q为hi !</span></span><br></pre></td></tr></table></figure>

<p>在没有构造的情况下访问内存试错误的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; *p &lt;&lt;endl; <span class="comment">//正确:使用string的输出运算符</span></span><br><span class="line">cout &lt;&lt; *q &lt;&lt;endl; <span class="comment">//灾难:q指向未构造的内存!</span></span><br></pre></td></tr></table></figure>

<p>当用完对象后，必须对每个构造元素调用destroy来销毁它们。接受一个指针对指向对象执行析构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">	alloc.<span class="built_in">destroy</span>(--q);<span class="comment">//释放我们真正构造的string</span></span><br></pre></td></tr></table></figure>

<p>销毁元素后可以重新使用内存，也可以归还系统</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n) ;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，第二个大小参数必须与调用allocate时一样。</p>
<h4 id="拷贝和填充未初始化内存"><a href="#拷贝和填充未初始化内存" class="headerlink" title="拷贝和填充未初始化内存"></a>拷贝和填充未初始化内存</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配比vi中元素所占用空间大一倍的动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p = alloc.<span class="built_in">allocate</span>(vi.<span class="built_in">size</span> () * <span class="number">2</span>);</span><br><span class="line"><span class="comment">//通过拷贝vi中的元素来构造从p开始的元素</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">uninitialized_copy</span> (vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), p);</span><br><span class="line"><span class="comment">//将剩余元素初始化为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(g, vi.<span class="built_in">size</span>() , <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用标准库：文本查询程序"><a href="#使用标准库：文本查询程序" class="headerlink" title="使用标准库：文本查询程序"></a>使用标准库：文本查询程序</h2><p>此部分将单独作为一章。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十一章</title>
    <url>/2022/01/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>关联容器</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/f8ba18e3b76e063e.png"></p>
<h2 id="使用关联容器-1"><a href="#使用关联容器-1" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现的次数</span></span><br><span class="line">map&lt;string，<span class="keyword">size_t</span> &gt; word_count; <span class="comment">// string到size_t 的空map</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">	++word_count[word] ;				<span class="comment">//提取word的计数器并将其加1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_ count) <span class="comment">// 对map中的每个元素</span></span><br><span class="line">	<span class="comment">//打印结果</span></span><br><span class="line">	cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs”&lt;&lt; w.second &lt;&lt; ((w.second&gt;1)?”times&quot;</span>:”time<span class="string">&quot;) &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计输入中每个单词出现的次数</span></span><br><span class="line">map&lt;string，<span class="keyword">size_t</span> &gt; word_count; 	<span class="comment">// string 到size_ t的空map .</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;The&quot;</span>, <span class="string">&quot;But&quot;</span>, <span class="string">&quot;And&quot;</span>， <span class="string">&quot;Or&quot;</span>， <span class="string">&quot;An&quot;</span>, <span class="string">&quot;A&quot;</span>,</span><br><span class="line">						<span class="string">&quot;the&quot;</span>，<span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span>， <span class="string">&quot;or&quot;</span>， <span class="string">&quot;an&quot;</span>， <span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">	<span class="comment">//只统计不在exclude中的单词</span></span><br><span class="line">	<span class="keyword">if</span> (exclude. <span class="built_in">find</span> (word) == exclude.<span class="built_in">end</span>() )</span><br><span class="line">	++word_ count [word]; 			<span class="comment">// 获取并递增word的计数器</span></span><br></pre></td></tr></table></figure>

<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string，size_ t&gt; word_ count; <span class="comment">//空容器</span></span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;a&quot;</span>,</span><br><span class="line">						<span class="string">&quot;The&quot;</span>, <span class="string">&quot;But&quot;</span>， <span class="string">&quot;And&quot;</span>， <span class="string">&quot;Or&quot;</span>, <span class="string">&quot;An&quot;</span>， <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//三个元素; authors将姓映射为名</span></span><br><span class="line">map&lt;string，string&gt; authors = &#123; &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">								&#123; <span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">								&#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="初始化multimap或multiset"><a href="#初始化multimap或multiset" class="headerlink" title="初始化multimap或multiset"></a>初始化multimap或multiset</h4><p>multi容器允许多个元素具有相同的关键字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个有20个元素的vector,保存0到9每个整数的两个拷贝</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">	ivec.<span class="function">push_ <span class="title">back</span><span class="params">(i)</span> </span>;</span><br><span class="line">	ivec.<span class="function">push_ <span class="title">back</span><span class="params">(i)</span></span>; 		<span class="comment">// 每个数重复保存一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iset包含来自ivec的不重复的元素; miset包含所有20个元素</span></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span> <span class="params">(ivec. cbegin()，ivec.cend())</span> </span>;</span><br><span class="line"><span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span> <span class="params">(ivec.cbegin()，ivec.cend())</span> </span>;</span><br><span class="line">cout &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">//打印出20</span></span><br><span class="line">cout &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">//打印出10</span></span><br><span class="line">cout &lt;&lt; miset.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">// 打印出 20</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器中的关键字类型必须定义比较元素的方法。</p>
<h4 id="使用关键字类型比较函数"><a href="#使用关键字类型比较函数" class="headerlink" title="使用关键字类型比较函数"></a>使用关键字类型比较函数</h4><p>可以指定一个比较函数来进行比较，需要在容器定义时紧跟着关键字类型给出。</p>
<p>当使用Sales_data类时因为没有&lt;运算符，所以我们需要自己定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span> <span class="params">(<span class="keyword">const</span> Sales_data &amp;<span class="number">1</span>hs， <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后定义容器时传入该函数,需要提供想要使用的操作的指针：</span></span><br><span class="line"><span class="comment">//bookstore中多条记录可以有相同的ISBN</span></span><br><span class="line"><span class="comment">// bookstore中的元素以ISBN的顺序进行排列</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">dec1type</span><span class="params">(compareIsbn)</span>*&gt;</span></span><br><span class="line"><span class="function">	<span class="title">bookstore</span> <span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用decltype指出自定义操作的类型，必须加上*指出给定的函数指针。</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在头文件utility中，一个pair保存两个数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;				<span class="comment">//保存两个string</span></span><br><span class="line">pair&lt;string, size_ t&gt; word_ count;		<span class="comment">//保存一个string和一个size_ t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="keyword">int</span>&gt;&gt; line;			<span class="comment">//保存string和vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用列表初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;string, string&gt; author&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Joyce&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>成员均为public使用first和second进行访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot;occurs&quot;</span> &lt;&lt; w.second&lt;&lt; ( (w.second &gt; <span class="number">1</span>)? ”time s: ”time<span class="string">&quot; ) &lt;&lt; endl ;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.bmp.ovh/imgs/2022/01/7b5d5c1283d78be6.png"></p>
<h4 id="返回pair的函数"><a href="#返回pair的函数" class="headerlink" title="返回pair的函数"></a>返回pair的函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;string，<span class="keyword">int</span>&gt; <span class="title">process</span> <span class="params">(vector&lt;string&gt; &amp;V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理v</span></span><br><span class="line">	<span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;v. <span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>()&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pair&lt;string， <span class="keyword">int</span>&gt;();			 <span class="comment">//隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else中返回的是一个空pair</p>
<p>早期版本中不可以列表初始化返回则必须显示构造或使用make_pair来生成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">	<span class="keyword">return</span> pair&lt;string，<span class="keyword">int</span>&gt; (v.<span class="built_in">back</span>()，v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">	<span class="keyword">return</span> make_ <span class="built_in">pair</span> (V.<span class="built_in">back</span>()，v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<h2 id="关联容器的操作"><a href="#关联容器的操作" class="headerlink" title="关联容器的操作"></a>关联容器的操作</h2><p><img src="https://i.bmp.ovh/imgs/2022/01/9a7c9a3c2375955d.png"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用关联容器得到迭代器得到一个value_type，对于map得到一个pair，first成员中保存的是const关键字，它是不可以更改的，second保存值。而set中value_type与value_type是一样的。</p>
<h4 id="遍历关联容器"><a href="#遍历关联容器" class="headerlink" title="遍历关联容器"></a>遍历关联容器</h4><p>使用迭代器遍历容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得一个指向首元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">cbegin</span>() ;</span><br><span class="line"><span class="comment">//比较当前迭代器和尾后迭代器.</span></span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.<span class="built_in">cend</span>() ) &#123;</span><br><span class="line">	<span class="comment">//解引用迭代器，打印关键字-值对</span></span><br><span class="line">	cout &lt;&lt; map_it-&gt;first &lt;&lt; ”occurs” &lt;&lt; map_it-&gt;second &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; endl;</span><br><span class="line">	++map_it; <span class="comment">// 递增迭代器，移动到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的函数为升序排列。</p>
<h4 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h4><p>通常不对关联容器使用泛型算法，关键字的const特性意味着不可以重排或修改元素，set中的元素时const的，所以只可以使用只读的算法，推荐使用容器内部的find，它会比泛型算法快得多，泛型find使用的是顺序搜索。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用insert添加一个元素或元素范围，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set容器</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;				<span class="comment">// ivec有8个元素</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; set2										<span class="comment">//空集合</span></span><br><span class="line">set2.<span class="built_in">insert</span>(ivec.<span class="built_in">cbegin</span>()，ivec.<span class="built_in">cend</span>());				<span class="comment">//set2有4个元素</span></span><br><span class="line">set2.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;);						<span class="comment">// set2现在有8个元素</span></span><br><span class="line"><span class="comment">//insert可以接受一对迭代器，也可以接受一个初始化列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map容器</span></span><br><span class="line"><span class="comment">//向word_count插入word的4种方法</span></span><br><span class="line">word_count.<span class="built_in">insert</span> (&#123;word, <span class="number">1</span>&#125;) ;</span><br><span class="line">word_count.<span class="built_in">insert</span> (<span class="built_in">make_pair</span>(word, <span class="number">1</span>)) ;</span><br><span class="line">word_count.<span class="built_in">insert</span> (pair&lt;string, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>)) ;</span><br><span class="line">word_count.<span class="built_in">insert</span> (map&lt;string，<span class="keyword">size_t</span>&gt;::<span class="built_in">value_type</span> (word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.bmp.ovh/imgs/2022/01/a8fe3a59d436ac0b.png"></p>
<h4 id="检测insert返回值"><a href="#检测insert返回值" class="headerlink" title="检测insert返回值"></a>检测insert返回值</h4><p>insert返回值依赖容器类型和参数，对于map和set，添加单一元素返回的是一个pair，first指向给定的关键字元素，second是bool值，指出插入成功还是失败（已存在）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现次数的一种更烦琐的方法</span></span><br><span class="line">map&lt;string，<span class="keyword">size_t</span>&gt; word_count; <span class="comment">// 从string到size_t的空map.</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word) &#123;</span><br><span class="line">	<span class="comment">//插入一个元素，关键字等于word, 值为1;</span></span><br><span class="line">	<span class="comment">//若word已在word_ count中，insert什么也不做</span></span><br><span class="line">	<span class="keyword">auto</span> ret = word_count.<span class="built_in">insert</span> (&#123;word, <span class="number">1</span>&#125;) ;</span><br><span class="line">	<span class="keyword">if</span> (!ret.second)				<span class="comment">// word已在word_ count中</span></span><br><span class="line">		++ret.first-&gt;second; 		<span class="comment">//递增计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="展开递增语句"><a href="#展开递增语句" class="headerlink" title="展开递增语句"></a>展开递增语句</h4><p><code>++ret.first-&gt;second;</code>这句话就代表增加插入的那个元素中的second++。</p>
<h4 id="multi容器添加元素"><a href="#multi容器添加元素" class="headerlink" title="multi容器添加元素"></a>multi容器添加元素</h4><p>这种容器可以包含多个相同的关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mul timap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">//插入第一个元素，关键字为Barth， John</span></span><br><span class="line">authors.<span class="built_in">insert</span> (&#123;<span class="string">&quot;Barth，John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//正确:添加第二个元素，关键字也是Barth， John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;) ;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://s2.loli.net/2022/01/22/QuvPl6JZYehS3fg.png" alt="image.png"></p>
<p>erase可以接受一个迭代器或者是一对迭代器来删除一个或一个范围的元素。还可以接受一个key_type，删除所匹配的关键字元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除一个关键字，返回删除的元素数量</span></span><br><span class="line"><span class="keyword">if</span> (word_count.<span class="built_in">erase</span> (removal_word) )</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ok:”&lt;&lt; removal_word &lt;&lt; ”removed\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;oops: ”&lt;&lt; removal_ word &lt;&lt; ”not found! \n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是multi容器，可能删除多个元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cnt = authors.<span class="built_in">erase</span> (<span class="string">&quot;Barth，John&quot;</span>) ;</span><br></pre></td></tr></table></figure>

<p>上面authors中添加了两个相同的元素，则cnt等于2。</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和unordered_map具有下标运算和at函数，set中不可以使用。</p>
<p>map通过下标运算，接受一个索引（即关键字）获取与之关联的值，但不同的是，如果没有此关键字，会创建一个关键字，并将对应的值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map &lt;string， <span class="keyword">size_t</span>&gt; word_count; / / empty map</span><br><span class="line"><span class="comment">//插入一个关键字为Anna的元素，关联值进行值初始化;然后将1赋予它</span></span><br><span class="line">word_count [<span class="string">&quot;Anna&quot;</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在word_ _count中搜索关键字为Anna的元素，未找到。</li>
<li><em>将一个新的关键字-值对插入到word</em> _count中。关键字是-一个const string，保存Anna。值进行值初始化，在本例中意味着值为0。</li>
<li>提取出新插入的元素，并将值1赋予它。</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/22/7R2B1iaJbqvftP4.png" alt="image.png"></p>
<h4 id="使用下标操作的返回值"><a href="#使用下标操作的返回值" class="headerlink" title="使用下标操作的返回值"></a>使用下标操作的返回值</h4><p>通常解引用的一个迭代器的类型与下标运算返回的类型是一样的，但map不同，会得到有个mappped_type对象，且为左值。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>count可以统计元素个数，对于不允许重复元素存在的容器，推荐使用find。</p>
<h4 id="map使用find代替下标操作"><a href="#map使用find代替下标操作" class="headerlink" title="map使用find代替下标操作"></a>map使用find代替下标操作</h4><p>map容器的下标操作如果关键字不存在，则会插入这个新的关键字，所以在只是想知道有没有这个关键字时可以用find代替。</p>
<h4 id="multi容器查找元素"><a href="#multi容器查找元素" class="headerlink" title="multi容器查找元素"></a>multi容器查找元素</h4><p><strong>方法一：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string search_ <span class="title">item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span> </span>;		<span class="comment">//要查找的作者</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors. <span class="built_in">count</span> (search_ item) ;	<span class="comment">//元素的数量</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors. <span class="built_in">find</span> (search_ item) ;		<span class="comment">//此作者的第一本书</span></span><br><span class="line"><span class="comment">//用一个循环查找此作者的所有著作</span></span><br><span class="line"><span class="keyword">while</span> (entries) &#123;</span><br><span class="line">	cout &lt;&lt; iter-&gt;second &lt;&lt; endl ;				<span class="comment">//打印每个题目</span></span><br><span class="line">	++iter;										<span class="comment">//前进到下一本书</span></span><br><span class="line">	--entries;									<span class="comment">//记录已经打印了多少本书</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<p>lower_bound和up_bound分别返回匹配的第一个位置和最后一个位置的后一个位置。不存在则返回可插入位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// authors 和search_ item 的定义，与前面的程序一样</span></span><br><span class="line"><span class="comment">//beg和end表示对应此作者的元素的范围.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors. <span class="built_in">lower_bound</span> (search_item) ,</span><br><span class="line">		  end = authors.<span class="built_in">upper_bound</span> (search_item) ;</span><br><span class="line">		  beg != end; ++beg)</span><br><span class="line">	cout &lt;&lt; beg-&gt;second &lt;&lt; endl; <span class="comment">//打印每个题目</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong></p>
<p>equal_range函数接受关键字，返回pair。若关键字存在则第一个指向第一个与之匹配的位置，第二个是最后一个与之匹配位置的后一个位置。若不存在则返回可插入位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// authors 和search_item的定义， 与前面的程序一样</span></span><br><span class="line"><span class="comment">// pos保存迭代器对，表示与关键字匹配的元素范围</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span> (search_item) ;</span><br><span class="line">	 pos.first != pos.second; ++pos.first)</span><br><span class="line">	cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; <span class="comment">//打印每个题目</span></span><br></pre></td></tr></table></figure>

<h3 id="单词转换map（跳）"><a href="#单词转换map（跳）" class="headerlink" title="单词转换map（跳）"></a>单词转换map（跳）</h3><h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><h4 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h4><p>unordered_map或者unordered_set，他们都有与前面类似的操作，通常可以用一个无序容器替换对应的有序容器，但顺序会与有序容器不同。</p>
<h4 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h4><p>无序容器在储存上为一组桶，无序容器使用一个哈希函数将所有元素映射到桶中，容器将具有一个特定的哈希值的所有元素保存在相同的桶中，访问时先按照哈希值找到对应的桶，再在桶中找对应的元素。因此容器性能依赖哈希函数的质量和桶的数量和大小。</p>
<p>最理想的情况应该是哈希函数将所有元素尽可能的均匀的分配到每个桶中。</p>
<p><img src="https://s2.loli.net/2022/01/27/eTFbRU5lHPOVKfp.png" alt="image.png"></p>
<h4 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h4><p>默认情况下，无序容器使用关键字类型的==运算符来比较元素，还使用一个hash<key_ type> 类型的对象来生成每个元素的哈希值。例如当我们想要将一个int值使用哈希函数，就是hash<int>,</p>
<p>但是我们不能直接定义关键字类型为自定义类类型的无序容器。可以不直接使用哈希模板而是使用自己的hash版本。例如Sale_data用作关键字，我们需要提供函数来代替==运算符和哈希计算函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_ data &amp;sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hash&lt;string&gt;() (sd. <span class="built_in">isbn</span>()) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs， <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SD_multiset = unordered multiset&lt;Sales_data,</span><br><span class="line">					<span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">//参数是桶大小、哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span> </span>;</span><br></pre></td></tr></table></figure>

<p>如果类内具有==运算符，可以只重载哈希函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用FooHash生成哈希值; Foo必须有==运算符</span></span><br><span class="line"><span class="function">unordered_set&lt;Foo, <span class="title">decltype</span> <span class="params">(FooHash)</span>*&gt; <span class="title">fooSet</span> <span class="params">(<span class="number">10</span>，FooHash)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第十章</title>
    <url>/2021/12/17/%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多数算法定义在头文件algorithm，标准库还在numeric中定义了一些。且一般情况不直接操作容器而是需要一个迭代器指定的范围。</p>
<p>如find：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string val = <span class="string">&quot;a value&quot;</span>; <span class="comment">//我们要查找的值</span></span><br><span class="line"><span class="comment">//此调用在list中查找string元素</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(lst. <span class="built_in">cbegin</span>()，lst.<span class="built_in">cend</span>()， val) ;</span><br><span class="line"><span class="comment">//类似的，由于指针就像内置数组上的迭代器一样， 我们可以用find在数组中查找值,这里使用到了begin和end:</span></span><br><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">27</span>， <span class="number">210</span>，<span class="number">12</span>, <span class="number">47</span>， <span class="number">109</span>， <span class="number">83</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">83</span>;</span><br><span class="line"><span class="keyword">int</span>* result = <span class="built_in">find</span> (<span class="built_in">begin</span>(ia), <span class="built_in">end</span>(ia), val);</span><br><span class="line"><span class="comment">//还可以在子序列中查找，如从ia[1]开始，直至(但不包含) ia[4]的范围内查找元素</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(ia + <span class="number">1</span>，ia+<span class="number">4</span>，val);</span><br></pre></td></tr></table></figure>

<h4 id="迭代器算法不依赖容器但依赖元素类型"><a href="#迭代器算法不依赖容器但依赖元素类型" class="headerlink" title="迭代器算法不依赖容器但依赖元素类型"></a>迭代器算法不依赖容器但依赖元素类型</h4><p>例如find用元素类型==运算符，例如还会使用到&lt;运算符等，所以需要在使用时确保元素类型定义了该操作，或者自定义操作。</p>
<p><em>算法永远不会改变容器大小（即不会添加或删除元素）</em></p>
<h2 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a>初识泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>意思是：只会读取输入范围不会改变元素。如：find、count、accumulate：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对vec中的元素求和，和的初值是0</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="built_in">accumulate</span> (vec. <span class="built_in">cbegin</span>()，vec.<span class="built_in">cend</span>() ，<span class="number">0</span>);</span><br><span class="line"><span class="comment">//第三个参数类型决定了函数使用的加法运算符及返回值类型</span></span><br></pre></td></tr></table></figure>

<h4 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h4><p>accumulate将给定的元素范围加到第三个参数上。所以必须保证容器元素类型能够转换成和的元素类型，且和的类型定义了+操作：<code>string sum = accumulate (v.cbegin()，v.cend() ，string(&quot;&quot;)) ;</code></p>
<p>注意这里必须显示的创建一个string，不可以使用字符串字面值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误: const char*.上没有定义+运算符</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span> (v.<span class="built_in">cbegin</span>()，v.<span class="built_in">cend</span>(), <span class="string">&quot;&quot;</span>) ;</span><br></pre></td></tr></table></figure>

<p><em>对于只读算法，最好只采用cbegin和cend</em></p>
<h4 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h4><p>equal用于确定是否保存相同的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// roster2中的元素数目应该至少与rosterl一样多</span></span><br><span class="line"><span class="built_in">equal</span> (roster1 .<span class="built_in">cbegin</span>()，rosterl.<span class="built_in">cend</span>() ，roster2. <span class="built_in">cbegin</span>() ) ;</span><br></pre></td></tr></table></figure>

<p>由于使用的是迭代器，所以不同类型的容器可以比较。而且，元素类型也不必一一样，只要我们能用=来比较两个元素类型即可。例如，在此例中，rosterl 可以是vector<string>，而roster2 是list&lt;const char*&gt;。</p>
<p><em>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</em></p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>-些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。一些算法会自己向输入范围写入元素。这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span> ( ),<span class="number">0</span>);<span class="comment">//将每个元素重置为0</span></span><br><span class="line"><span class="comment">//将容器的一个子序列设置为10</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span> () + vec.<span class="built_in">size</span> ()/<span class="number">2</span>，<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>关键概念：迭代器参数</strong><br>        一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如,第一个序列可能保存于一个vector中,而第二个序列可能保存于一个list.deque、内置数组或其他容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同,但是我们必须能使用一来比较来自两个序列中的元素。<br>        操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equal，接受三个迭代器:前两个表示第一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器:前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。<br>        用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。例如,算法 equal会将其第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果第二个序列是第一个序列的一个子集,则程序会产生一个严重错误———equal会试图访问第二个序列中末尾之后（不存在）的元素。</p>
<h4 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h4><p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//空vector</span></span><br><span class="line"><span class="comment">//使用vec，赋予它不同值</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span> (), vec.<span class="built_in">size</span> ( ),<span class="number">0</span>);<span class="comment">//将所有元素重置为0</span></span><br><span class="line"><span class="comment">//函数fill_n假定写入指定个元素是安全的。即，如下形式的调用</span></span><br><span class="line"><span class="built_in">fill_n</span>(dest, n, val);</span><br><span class="line"><span class="comment">//一定要保证写入后大小不能超过容器大小，因为它不会重新开辟空间</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//空向量</span></span><br><span class="line"><span class="comment">//灾难:修改vec中的10个（不存在）元素fill_n (vec.begin (),10,0);</span></span><br></pre></td></tr></table></figure>

<h4 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h4><p>头文件为iterator，它接受一个引用，返回一个与容器绑定的插入迭代器，当通过此迭代器赋值会调用push_back插入给定元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// 空向量</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);<span class="comment">//通过它赋值会将元素添加到vec中</span></span><br><span class="line">*it = <span class="number">42</span>; <span class="comment">// vec中现在有一个元素，值为42</span></span><br><span class="line"><span class="comment">//我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如:</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//空向量</span></span><br><span class="line"><span class="comment">//正确:back_inserter创建一个插入迭代器，可用来向vec添加元素</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec)，<span class="number">10</span>，<span class="number">0</span>); <span class="comment">//添加10个元素到vec</span></span><br></pre></td></tr></table></figure>

<p>由于每次赋值都会使用push_back，所以可以添加元素。</p>
<h3 id="重排容器元素"><a href="#重排容器元素" class="headerlink" title="重排容器元素"></a>重排容器元素</h3><p>先看一段代码，用于消除重复的元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span> <span class="params">(vector&lt;string&gt; &amp;words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//按字典序排序words，以便查找重复单词</span></span><br><span class="line">	<span class="built_in">sort</span> (words .<span class="built_in">begin</span>()，words.<span class="built_in">end</span>() ) ;</span><br><span class="line">	<span class="comment">//unique 重排输入范围，使得每个单词只出现一次</span></span><br><span class="line">	<span class="comment">//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器</span></span><br><span class="line">	<span class="keyword">auto</span> end_ _unique = <span class="built_in">unique</span> (words .<span class="built_in">begin</span>()，words.<span class="built_in">end</span>()) ;</span><br><span class="line">	<span class="comment">//使用向量操作erase删除重复单词</span></span><br><span class="line">	words. <span class="built_in">erase</span> (end_ _unique, words.<span class="built_in">end</span>()) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先使用sort进行排序，这里使用的是string中的&lt;成员，这样相同的元素就会相邻，然后使用unique算法“删除”重复元素，还记得其实我们并不能真的删除容器中的元素，它只是将将重复元素覆盖，然后返回一个“删除”后容器的end位置，所以最后一句代码用erase真正的删除掉它们。</p>
<p><img src="https://s2.loli.net/2022/01/07/vhb7z2WRIF15B4K.png" alt="image.png"></p>
<p><lable style = "color : red">标准库算法对迭代器而不是容器进行操作。因此，算法不能(直接)添加或删除元素。</lable></p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>很多算法允许我们自定义元素的运算符，如sort中的&lt;。</p>
<h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>如果希望排序是按照单词长度排序，可添加一个参数，称<strong>谓词</strong></p>
<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类: 一元谓词(unary predicate， 意味着它们只接受单一参数)和二元谓词( binary predicate， 意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型，这里就是用它来代替&lt;来比较参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较函数，用来按长度排序单词</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span> <span class="params">(<span class="keyword">const</span> string &amp;s1， <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sl.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按长度由短至长排序words</span></span><br><span class="line"><span class="built_in">sort</span> (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>

<p>如果还希望当长度相等时，按字典排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">elimDups</span> (words); <span class="comment">// 将words按字典序重排，并消除重复单词</span></span><br><span class="line"><span class="comment">//按长度重新排序，长度相同的单词维持字典序</span></span><br><span class="line"><span class="function">stable_ <span class="title">sort</span> <span class="params">(words .begin()，words.end() ，isShorter)</span> </span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : words) <span class="comment">// 无须拷贝字符串</span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt;”<span class="string">&quot;; //打印每个元素，以空格分隔</span></span><br><span class="line"><span class="string">cout &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>求大于等于一个给定长度的单词有多少，框架如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span> <span class="params">(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_ type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">elimDups</span> (words); <span class="comment">// 将words按字典序排序，删除重复单词.</span></span><br><span class="line">	<span class="comment">//按长度排序， 长度相同的单词维持字 典序</span></span><br><span class="line">	<span class="function">stable_ <span class="title">sort</span> <span class="params">(words .begin(), words.end(), isShorter)</span> </span>;</span><br><span class="line">	<span class="comment">//获取一个迭代器，指向第一个满足size()&gt;= sz的元素</span></span><br><span class="line">	<span class="comment">//计算满足size &gt;= sz的元素的数目</span></span><br><span class="line">	<span class="comment">//打印长度大于等于给定值的单词，每个单词后面接一个空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用find_if算法来查找特定大小的元素，第三个参数为谓词，它将对每个元素使用谓词，返回第一个使谓词返回非0值的元素。不存在返回尾迭代器。</p>
<p>我们的想法是编写一个接受string和长度两个参数返回bool值， 表示string长度是否大于给定长度，但find_if值接受一元谓词，所以使用lambda表达式</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>与任何函数类似，一个 lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：<br><code>[ capture list ] (parameter list) -&gt; return type &#123; function body &#125;</code><br>其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空);return type、parameter list和 function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda必须使用尾置返回来指定返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; 		<span class="comment">//打印42</span></span><br></pre></td></tr></table></figure>

<p>如果 lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型,则返回void。</p>
<h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>lambda不能有默认参数，所以实参形参数目必须相等且匹配，编写一个isShorter类型的lambda：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">const</span> string &amp;a, <span class="keyword">const</span> string &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span> ();&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按长度排序，长度相同的单词维持字典序</span></span><br><span class="line"><span class="built_in">stable_sort</span> (words.<span class="built_in">begin</span> ( ), words.<span class="built_in">end</span> () , </span><br><span class="line">             	[](<span class="keyword">const</span> string &amp;a,<span class="keyword">const</span> string &amp;b)</span><br><span class="line">					&#123; <span class="keyword">return</span> a.<span class="built_in">size</span> () &lt; b.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure>

<p>当比较元素长度，就会使用lambda。</p>
<h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><p>在例子中，我们需要捕获用户传进来的边界长度用来查找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[sz] (<span class="keyword">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= SZ; &#125;</span><br></pre></td></tr></table></figure>

<p>捕获了sz，所以我们才可以使用它，没有捕获的不可以使用。</p>
<p><em>一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量,才能在函数体中使用该变量。</em></p>
<h4 id="调用find-if"><a href="#调用find-if" class="headerlink" title="调用find_if"></a>调用find_if</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取一个迭代器，指向第一个满足size () &gt;= sz的元素</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span> () ,</span><br><span class="line">					[sz] (<span class="keyword">const</span> string &amp;a)</span><br><span class="line">						&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;=sz; &#125;);</span><br><span class="line"><span class="keyword">auto</span> count = words.<span class="built_in">end</span>() - wc;  <span class="comment">//它表示size &gt;= sz 元素的数目</span></span><br></pre></td></tr></table></figure>

<h4 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h4><p>我们还可以打印出&gt;给定长度的单词：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印长度大于等于给定值的单词，每个单词后面接一个空格</span></span><br><span class="line">for_each(wc, words.<span class="built_in">end</span> (), [] (<span class="keyword">const</span> string &amp;s ) &#123; cout &lt;&lt; s &lt;&lt;<span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><em>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字</em>，所以可以使用cout。</p>
<h4 id="完成程序"><a href="#完成程序" class="headerlink" title="完成程序"></a>完成程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">elimDups</span> (words);<span class="comment">// 将words按字典序排序，删除重复单词</span></span><br><span class="line">	<span class="comment">//按长度排序，长度相同的单词维持字典序</span></span><br><span class="line">	<span class="built_in">stable_sort</span> (words.<span class="built_in">begin</span> (), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp;a, <span class="keyword">const</span> string &amp;b)</span><br><span class="line">												&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;);</span><br><span class="line">	<span class="comment">//获取一个迭代器，指向第一个满足size () &gt;= sz的元素</span></span><br><span class="line">	<span class="keyword">auto</span> wc = <span class="built_in">find_if</span> (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span> (), [sz] (<span class="keyword">const</span> string &amp;a)</span><br><span class="line">													&#123; <span class="keyword">return</span> a.<span class="built_in">size</span> () &gt;=sz; &#125;);</span><br><span class="line">	<span class="comment">//计算满足size &gt;= sz的元素的数目</span></span><br><span class="line">	<span class="keyword">auto</span> count = words.<span class="built_in">end</span>() - wc;</span><br><span class="line">	cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">make_plural</span>(count, <span class="string">&quot;word&quot;</span>, <span class="string">&quot;s&quot;</span>)</span><br><span class="line">		 &lt;&lt;<span class="string">&quot; of length &quot;</span> &lt;&lt;sz&lt;&lt;<span class="string">&quot; or longer&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//打印长度大于等于给定值的单词，每个单词后面接一个空格</span></span><br><span class="line">	for_each (wc, words.<span class="built_in">end</span>(), [] (<span class="keyword">const</span> string &amp;s) &#123;cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。目前，可以这样理解，它就是一个未命名的类类型的对象，捕获列表里是他的数据成员，使用auto定义一个lambda初始值变量时，就定义了一个从lambda生成的类型的对象。</p>
<h4 id="值捕获与引用捕获"><a href="#值捕获与引用捕获" class="headerlink" title="值捕获与引用捕获"></a>值捕获与引用捕获</h4><p>类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的 lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda创建时拷贝，而不是调用时拷贝:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> v1 </span>=<span class="number">42</span>;		<span class="comment">//局部变量</span></span><br><span class="line"><span class="comment">//将v1拷贝到名为f的可调用对象</span></span><br><span class="line"><span class="keyword">auto</span> f =[v1] &#123; <span class="keyword">return</span> vl; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>(); 		<span class="comment">//j为42;f保存了我们创建它时v1的拷贝</span></span><br></pre></td></tr></table></figure>

<p>采用引用则改变该值会同时改变：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>; 	<span class="comment">//局部变量</span></span><br><span class="line"><span class="comment">//对象2包含v1的引用</span></span><br><span class="line"><span class="keyword">auto</span> f2 =[ &amp;v1] &#123; <span class="keyword">return</span> vl; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line">autoj = <span class="built_in">f2</span>();		<span class="comment">//j为0;f2保存v1的引用，而非拷贝</span></span><br></pre></td></tr></table></figure>

<p><strong>但捕获引用返回引用有一个问题是，必须保证使用lambda时该引用对象存在</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz, </span></span></span><br><span class="line"><span class="params"><span class="function">             ostream &amp;os= cout,<span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//与之前例子一样的重排words的代码</span></span><br><span class="line"><span class="comment">//打印count的语句改为打印到os</span></span><br><span class="line">	for_each (words.<span class="built_in">begin</span> (), words.<span class="built_in">end</span> ( ), [ &amp;os,c] (<span class="keyword">const</span> string &amp;s)&#123; os &lt;&lt; s&lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不能拷贝ostream对象，所以拷贝os的唯一方式就时捕获引用（或指向os的指针）</p>
<p>我们可以从函数返回lambda，但该lambda不能捕获引用，因为局部变量消失会使lambda数据成员不可用。</p>
<p><strong>我们应尽量减少引用或指针捕获</strong></p>
<h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><p>使用=（值捕获）&amp;（引用捕获）告诉编译器接下来我要使用的变量都采用该捕获方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式</span></span><br><span class="line">wc = <span class="built_in">find_if</span> (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), </span><br><span class="line">				[=](<span class="keyword">const</span> string &amp;s) &#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>

<p>也可以一部分值捕获，一部分引用捕获：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os隐式捕获，引用捕获方式;c显式捕获，值捕获方式</span></span><br><span class="line">for_each ( words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [&amp;, c](<span class="keyword">const</span> string &amp;s)&#123; os&lt;&lt; s&lt;&lt; c; &#125;);</span><br><span class="line"><span class="comment">// os显式捕获，引用捕获方式;c隐式捕获，值捕获方式</span></span><br><span class="line">for_each (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [=, &amp;os](<span class="keyword">const</span> string &amp;s)&#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>

<p>混合捕获必须把默认捕获方式写在前面（只能是=或者&amp;），且显示捕获方式必须与默认不同。</p>
<p><img src="https://s2.loli.net/2022/01/08/7BAaoqwuH65Lks4.png" alt="image.png"></p>
<h4 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h4><p>默认情况是如果一个lambda包含除return以外的任何语句，则假定此lambda返回void，则不能返回值，这里使用位置返回类型来返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span> (vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(), </span><br><span class="line">			[](<span class="keyword">int</span> i)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>

<p>transform接受一对迭代器范围，和一个目的地，将由第四个参数调用后放入目的地。</p>
<h3 id="参数绑定bind（跳过）"><a href="#参数绑定bind（跳过）" class="headerlink" title="参数绑定bind（跳过）"></a>参数绑定bind（跳过）</h3><p>对于只在一两个地方用到的简单操作可以使用lambda，而很多地方，且操作更多，我们应该使用函数。</p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><ul>
<li>插入迭代器（insert iterator):这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li>
<li>流迭代器(stream iterator):这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li>
<li>反向迭代器( reverse iterator ):这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器（move iterator):这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>it=t                                在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用c.push_back(t) 、c.push_front(t)或c.insert (t,p)，其中p 为传递给inserter的迭代器位置</p>
<p>*it,++it,it++                  这些操作虽然存在，但不会对it做任何事情。每个操作都返回it插入器有三种类型。</p>
<p>差异在于元素插入的位置:</p>
<ul>
<li><strong>back_inserter</strong>创建一个使用push_back的迭代器。</li>
<li><strong>front inserter</strong>创建一个使用push_front的迭代器。</li>
<li><strong>inserter</strong>创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</li>
</ul>
<p><strong>插入迭代器还是基于容器自身的push操作，所以必须确保有该操作才可以使用对应的插入迭代器。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">//其效果与下面代码一样</span></span><br><span class="line">it = c.<span class="built_in">insert</span>(it, val) ; <span class="comment">// it指向新加入的元素</span></span><br><span class="line">++it; <span class="comment">//递增it使它指向原来的元素</span></span><br></pre></td></tr></table></figure>

<p>front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lst2,lst3; 		<span class="comment">//空list</span></span><br><span class="line"><span class="comment">//拷贝完成之后，lst2包含4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span> (), lst.<span class="built_in">cend</span>(), <span class="built_in">front_inserter</span> (lst2 ) ) ;</span><br><span class="line"><span class="comment">//拷贝完成之后，lst3包含1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span> (lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>( ), <span class="built_in">inserter</span>(lst3,lst3.<span class="built_in">begin</span> () ) );</span><br></pre></td></tr></table></figure>

<h3 id="iostream迭代器（跳过）"><a href="#iostream迭代器（跳过）" class="headerlink" title="iostream迭代器（跳过）"></a>iostream迭代器（跳过）</h3><h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素;递减一个迭代器（–it）会移动到下一个元素。</p>
<p>除了forward_list之外,其他容器都支持反向迭代器。我们可以通过调用rbegin、rend、crbegin 和 crend 成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有 const和非const版本。</p>
<p><img src="https://s2.loli.net/2022/01/08/bPTIpokLXinHvE7.png" alt="image.png"></p>
<p>一些应用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> (vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">//按“正常序”排序vec</span></span><br><span class="line"><span class="comment">//按逆序排序:将最小元素放在vec的末尾</span></span><br><span class="line"><span class="built_in">sort</span> (vec.<span class="built_in">rbegin</span> () , vec.<span class="built_in">rend</span> () );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个逗号分隔的列表中查找第一个元素</span></span><br><span class="line"><span class="keyword">auto</span> comma = <span class="built_in">find</span> (line.<span class="built_in">cbegin</span>(), line.<span class="built_in">cend</span>(), <span class="string">&#x27;,&#x27;</span> );</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span> (line.<span class="built_in">cbegin</span>() , comma) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//在一个逗号分隔的列表中查找最后一个元素</span></span><br><span class="line"><span class="keyword">auto</span> rcomma = <span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(), line.<span class="built_in">crend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="comment">//错误:将逆序输出单词的字符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(line.<span class="built_in">crbegin</span>() , rcomma) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//正确:得到一个正向迭代器，从逗号开始读取字符直到line末尾</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(rcomma.<span class="built_in">base</span>(), line.<span class="built_in">cend</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>base函数将反向迭代器转换为正向迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>算法所要求的迭代器可分为五类：</p>
<p><img src="https://s2.loli.net/2022/01/08/GiylQKPXBUwf1kH.png" alt="image.png"></p>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。</p>
<h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><p>他可以读取序列中的元素，必须支持：</p>
<ul>
<li>用于比较两个迭代器的相等和不相等运算符（ =一、!=)</li>
<li>用于推进迭代器的前置和后置递增运算(++)</li>
<li>用于读取元素的解引用运算符（<code>*</code>);解引用只会出现在赋值运算符的右侧</li>
<li>箭头运算符(-&gt;)，等价于(*it) .member，即，解引用迭代器，并提取对象的成员</li>
</ul>
<p>输入迭代器只用于顺序访问。对于一个输入迭代器，<code>*it++</code>保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此,输入迭代器只能用于单遍扫描算法。算法find和 accumulate要求输入迭代器;而istream_iterator是一种输入迭代器。</p>
<h4 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h4><p>可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持</p>
<ul>
<li>用于推进迭代器的前置和后置递增运算（++)</li>
<li>解引用运算符(*)，只出现在赋值运算符的左侧(向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素)</li>
</ul>
<p>我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器。</p>
<h4 id="前向迭代器"><a href="#前向迭代器" class="headerlink" title="前向迭代器"></a>前向迭代器</h4><p>可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。</p>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4><p>可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符(–)。算法 reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。</p>
<h4 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h4><p>提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能</p>
<ul>
<li>用于比较两个迭代器相对位置的关系运算符(&lt;、&lt;=、&gt;和&gt;=)</li>
<li>迭代器和一个整数值的加减运算(+、+=、-和-=)，计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置</li>
<li>用于两个迭代器上的减法运算符(-)，得到两个迭代器的距离</li>
<li>下标运算符(iter[n] )，与* (iter [n])等价</li>
</ul>
<p>算法sort要求随机访问迭代器。array、deque、string和 vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>alg ( beg, end, other args) ;</p>
<p>alg ( beg, end, dest, other args ) ;</p>
<p>alg (beg, end, beg2, other args) ;</p>
<p>alg(beg, end, beg2, end2, other args) ;</p>
<p>alg为算法名字，beg和end表示范围，dest为目的地，arg为算法。此外还有一些算法接受额外非迭代器参数。</p>
<h4 id="接受单个目标迭代器的算法·"><a href="#接受单个目标迭代器的算法·" class="headerlink" title="接受单个目标迭代器的算法·"></a>接受单个目标迭代器的算法·</h4><p>dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定( assume):按其需要写入数据，不管写入多少个元素都是安全的。</p>
<p><strong>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。</strong></p>
<p>常见情况是dest被绑定到一个插入迭代器或ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间足够的，ostream_iterator会将数据写入到一个输出流，同样不管要写入多少个元素都没有问题。</p>
<h4 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h4><p>接受单独的 beg2或是接受beg2和 end2的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。</p>
<p>如果一个算法接受beg2和 end2，这两个迭代器表示第二个范围。这类算法接受两个完整指定的范围:[beg,end)表示的范围和[ beg2 end2)表示的第二个范围。</p>
<p>只接受单独的 beg2(不接受end2)的算法将beg2作为第二个输入范围中的首元素。此范围的结束位置未指定，这些算法假定从beg2开始的范围与 beg和 end所表示的范围至少一样大。</p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><h4 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique</span> (beg, end);					<span class="comment">//使用==运算符比较元素</span></span><br><span class="line"><span class="built_in">unique</span> (beg, end,comp) ;			<span class="comment">//使用comp比较元素</span></span><br></pre></td></tr></table></figure>

<h4 id="if版本算法"><a href="#if版本算法" class="headerlink" title="_if版本算法"></a>_if版本算法</h4><p>接受元素值的算法有一个不同名的版本，使用谓词代替元素值，接受谓词参数版本需要加_if:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> (beg, end,val) ;					<span class="comment">//查找输入范围中val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span> (beg, end,pred);				<span class="comment">//查找第一个令pred为真的元素</span></span><br></pre></td></tr></table></figure>

<p>他们狗接受三个参数，因此不是重载。</p>
<h4 id="拷贝与非拷贝版本"><a href="#拷贝与非拷贝版本" class="headerlink" title="拷贝与非拷贝版本"></a>拷贝与非拷贝版本</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);					<span class="comment">//反转输入范围中元素的顺序</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);		<span class="comment">//将元素按逆序拷贝到dest</span></span><br><span class="line"><span class="comment">//一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词;</span></span><br><span class="line"><span class="comment">//从v1中删除奇数元素</span></span><br><span class="line"><span class="built_in">remove_if</span>(v1.<span class="built_in">begin</span> (), v1.<span class="built_in">end</span>(), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span>;&#125;);</span><br><span class="line"><span class="comment">//将偶数元素从v1拷贝到v2;v1不变</span></span><br><span class="line"><span class="built_in">remove_copy_if</span>(vl.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(v2), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span>;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>因为如sort等一些通用算法要求随机访问迭代器，而list和forward_list提供的是前向和双向迭代器，所以只能使用他们自己的成员函数算法</p>
<p><img src="https://s2.loli.net/2022/01/10/nyAfgr754sZDp6z.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/10/OkMS3sjpB4qulDQ.png" alt="image.png"></p>
<p>链表还有一些splice算法，这些是链表独有的：</p>
<p><img src="https://s2.loli.net/2022/01/10/T5Bien73wkgCNlG.png" alt="image.png"></p>
<h4 id="特有的操作会改变容器"><a href="#特有的操作会改变容器" class="headerlink" title="特有的操作会改变容器"></a>特有的操作会改变容器</h4><p>多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove的链表版本会删除指定的元素，非链表版本并不会真正删除，而是覆盖，unique的链表版本会删除第二个和后继的重复元素，非链表也是覆盖。</p>
<p>类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列写到一个给定的目的迭代器;两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第九章</title>
    <url>/2021/12/13/%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p>vector                    可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢<br>deque                    双端队列。支持快速随机访问。在头尾位置插入/删除速度很快<br>list                            双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快<br>forward_list            单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快<br>array                        固定大小数组。支持快速随机访问。不能添加或删除元素<br>string                    与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</p>
<h4 id="确定使用那种容器"><a href="#确定使用那种容器" class="headerlink" title="确定使用那种容器"></a>确定使用那种容器</h4><ul>
<li>除非你有很好的理由选择其他容器，否则应使用vector。</li>
<li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素，应使用vector或deque。</li>
<li>如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则<ul>
<li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector 中。</li>
</ul>
</li>
</ul>
<p>如果程序兼具插入和访问，那么取决于哪一种操作更多。</p>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>首先定义时需要确定容器中的元素类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;sales_data&gt;					<span class="comment">//保存Sales_data对象的list</span></span><br><span class="line">deque&lt;<span class="keyword">double</span>&gt;						<span class="comment">//保存double的deque</span></span><br></pre></td></tr></table></figure>

<h4 id="对容器可以保存的元素类型的限制"><a href="#对容器可以保存的元素类型的限制" class="headerlink" title="对容器可以保存的元素类型的限制"></a>对容器可以保存的元素类型的限制</h4><p>顺序几乎可以保存任意类型的元素，但若类型没有默认构造函数，虚特殊处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假定noDefault是一个没有默认构造函数的类型</span></span><br><span class="line"><span class="function">vector&lt;noDefault&gt; <span class="title">v1</span> <span class="params">(<span class="number">10</span>, init)</span></span>;				<span class="comment">//正确:提供了元素初始化器</span></span><br><span class="line"><span class="function">vector&lt;noDefault&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span> </span>;						<span class="comment">//错误:必须提供一个元素初始化器</span></span><br></pre></td></tr></table></figure>

<p><strong>类型别名</strong></p>
<p>iterator                              此容器类型的迭代器类型<br>const_iterator                   可以读取元素，但不能修改元素的迭代器类型<br>size_type                            无符号整数类型，足够保存此种容器类型最大可能容器的大小<br>difference_type                 带符号整数类型，足够保存两个迭代器之间的距离<br>value_type                          元素类型<br>reference                            元素的左值类型;与value_type&amp;含义相同<br>const_reference                 元素的const左值类型(即，const value_type&amp;)</p>
<p><strong>构造函数</strong></p>
<p>c c;                                        默认构造函数，构造空容器（array，参见第301页)<br>c c1(c2);                                构造c2的拷贝c1<br>cc(b,e);                                 构造c，将迭代器b 和e指定的范围内的元素拷贝到c(array不支持）<br>c c{a，b,c…};                        列表初始化c</p>
<p><strong>赋值与swap</strong></p>
<p>c1= c2                                    将c1中的元素替换为c2中元素<br>c1= {a,b,c… }                         将c1中的元素替换为列表中元素（不适用于array)<br>a.swap(b)                              交换a和 b的元素<br>swap(a，b)                           与a.swap(b)等价</p>
<p>**大小 **</p>
<p>c.size ()                                c中元素的数目（不支持forward_list)<br>c.max_size ()                        c可保存的最大元素数目<br>c.empty()                             若c中存储了元素，返回false，否则返回true</p>
<p><strong>添加/删除元素（不适用于array)</strong><br>注:在不同容器中，这些操作的接口都不同</p>
<p>c.insert(args)                        将args 中的元素拷贝进c<br>c.emplace (inits)                使用inits构造c中的一个元素<br>c.erase (args)                        删除args指定的元素<br>c.clear ()                                删除c中的所有元素，返回void</p>
<p><strong>关系运算符</strong></p>
<p>==，!=                                        所有容器都支持相等（不等)运算符<br>&lt;，&lt;=，&gt;，&gt;=                        关系运算符（无序关联容器不支持)</p>
<p><strong>获取迭代器</strong></p>
<p>c.begin () , c.end ()                    返回指向c的首元素和尾元素之后位置的迭代器<br>c.cbegin(), c.cend ()                    返回const iterator</p>
<p><strong>反向容器的额外成员（不支持forward_list)</strong></p>
<p>reverse_iterator                        按逆序寻址元素的迭代器<br>const_reverse_iterator            不能修改元素的逆序迭代器<br>c.rbegin () , c.rend ()                    返回指向c的尾元素和首元素之前位置的迭代器<br>c.crbegin (), c.crend ()                返回const_reverse_iterator</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>一个迭代器范围有一对迭代器表示，通常是begin和end，[begin, end)。</p>
<p>他们应指向同一个容器中的元素或这最后一个容器的下一个位置，且begin&lt;=end</p>
<h4 id="左闭右合的范围"><a href="#左闭右合的范围" class="headerlink" title="左闭右合的范围"></a>左闭右合的范围</h4><ul>
<li>如果begin 与 end相等，则范围为空</li>
<li>如果begin与 end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</li>
<li>我们可以对 begin递增若干次，使得begin==end</li>
</ul>
<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != end)&#123;</span><br><span class="line">	*begin = val; 	<span class="comment">//正确:范围非空，因此begin指向一个元素</span></span><br><span class="line">	++begin;		<span class="comment">//移动迭代器，获取下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>如果需要元素类型，可以使用容器的value_type。如果需要元素类型的一个引用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程中非常有用。为了使用这些类型，我们必须显式使用其类名:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iter是通过list&lt;string&gt;定义的一个迭代器类型</span></span><br><span class="line">list&lt;string&gt;::iterator iter;</span><br><span class="line"><span class="comment">// count是通过vector&lt;int&gt;定义的一个difference_type类型</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::difference_type count;</span><br></pre></td></tr></table></figure>

<h3 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; a =&#123; <span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span> (); 	<span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span> (); <span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span> (); <span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>(); <span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>

<p>C++新版本可以使用auto来定义类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式指定类型</span></span><br><span class="line">list&lt;string&gt; : :iterator it5 = a.<span class="built_in">begin</span> () ;</span><br><span class="line">list&lt;string&gt; : :const_iterator it6 = a.<span class="built_in">begin</span> ();</span><br><span class="line"><span class="comment">//是iterator还是const_iterator依赖于a的类型</span></span><br><span class="line"><span class="keyword">auto</span> it7 = a.<span class="built_in">begin</span>();			<span class="comment">//仅当a是const时， it7是const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it8 = a.<span class="built_in">cbegin</span> (); 		<span class="comment">//it8是const_iterator</span></span><br></pre></td></tr></table></figure>

<p>当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但以c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。</p>
<h3 id="容器的定义和初始化"><a href="#容器的定义和初始化" class="headerlink" title="容器的定义和初始化"></a>容器的定义和初始化</h3><p><img src="https://s2.loli.net/2022/01/03/KFyuMGDPxfva76W.png" alt="image.png"></p>
<h3 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h3><p>拷贝时容器类型及元素类型必须匹配。使用迭代器拷贝不需要容器类型相同，且元素类型只需要可以类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个容器有三个元素，用给定的初始化器进行初始化</span></span><br><span class="line">list&lt;string&gt; authors = ( <span class="string">&quot;Milton&quot;</span>，<span class="string">&quot;Shakespeare&quot;</span>， <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">list&lt;string&gt; <span class="built_in">list2</span>(authors) ;							<span class="comment">//正确:类型匹配</span></span><br><span class="line">deque&lt;string&gt; <span class="built_in">authList</span> (authors); 						<span class="comment">//错误:容器类型不匹配</span></span><br><span class="line">vector&lt;string&gt; <span class="built_in">words</span>(articles); 						<span class="comment">//错误:容器类型必须匹配</span></span><br><span class="line"><span class="comment">//正确:可以将const char*元素转换为string</span></span><br><span class="line">forward_list&lt;string&gt; <span class="built_in">words</span> (articles.<span class="built_in">begin</span> ( ), articles.<span class="built_in">end</span> ( ) );</span><br></pre></td></tr></table></figure>

<p>初始化拷贝容器类型和元素类型都必须相同。</p>
<p>由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。例如，假定迭代器it表示authors中的一个元素:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝元素，直到(但不包括)it指向的元素</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span> <span class="params">(authors.begin () , it)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个容器有三个元素，用给定的初始化器进行初始化</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>，<span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>接受一个容器大小，及初始值来创建容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span> <span class="params">( <span class="number">10</span>,<span class="number">-1</span>)</span></span>;				<span class="comment">// 10个int元素，每个都初始化为-1</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">svec</span> <span class="params">(<span class="number">10</span>，<span class="string">&quot;hi! &quot;</span>)</span></span>;			<span class="comment">// 10个strings;每个都初始化为&quot;hi !&quot;</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span> <span class="params">(<span class="number">10</span>)</span> </span>;			<span class="comment">// 10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">svec</span> <span class="params">(<span class="number">10</span>)</span> </span>;				<span class="comment">// 10个元素，每个都是空string</span></span><br></pre></td></tr></table></figure>

<p>如果元素类型具有没有默认构造函数，则必须提供初始值。</p>
<h4 id="标准库array具有固定的大小"><a href="#标准库array具有固定的大小" class="headerlink" title="标准库array具有固定的大小"></a>标准库array具有固定的大小</h4><p>定义array，必须指定类型和容器大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 42&gt;						<span class="comment">//类型为:保存42个int的数组</span></span><br><span class="line">array&lt;string,10&gt;					<span class="comment">//类型为:保存10个string的数组</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, 10&gt;: :size_type i;		<span class="comment">//数组类型包括元素类型和大小</span></span><br><span class="line">array&lt;<span class="keyword">int</span>&gt; : :size_type j;			<span class="comment">//错误:array&lt;int&gt;不是一个类型</span></span><br></pre></td></tr></table></figure>

<p>与其他容器不同点在于，默认构造的array是非空的，因为指定大小后，其中的元素都被默认初始化了。其次使用列表初始化元素数目必须小于等于容器大小，剩余部分用0填充：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 10&gt; ia1;									<span class="comment">//10个默认初始化的int</span></span><br><span class="line">array&lt;<span class="keyword">int</span>,10&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;			<span class="comment">//列表初始化</span></span><br><span class="line">array&lt;<span class="keyword">int</span>,10&gt; ia3 = &#123;<span class="number">42</span>&#125;;							<span class="comment">// ia3[0]为42，剩余元素为О</span></span><br></pre></td></tr></table></figure>

<p>与内置数组不同，array可以进行拷贝赋值操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> digs [<span class="number">10</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cpy [<span class="number">10</span>] = digs;								<span class="comment">//错误:内置数组不支持拷贝或赋值</span></span><br><span class="line">array&lt;<span class="keyword">int</span>,10&gt; digits = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>，10&gt; copy = digits; 						<span class="comment">//正确:只要数组类型匹配即合法</span></span><br></pre></td></tr></table></figure>

<p>但初始值类型，元素类型，大小都必须相同。</p>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c1 =c2;						<span class="comment">//将c1的内容替换为c2中元素的拷贝</span></span><br><span class="line">c1 =&#123; a,b,c&#125;; 				<span class="comment">//赋值后，c1大小为3</span></span><br></pre></td></tr></table></figure>

<p>与内置数组不同，array类型允许赋值，但对象类型需要相等：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>,10&gt; al = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>,10&gt; a2 = &#123; <span class="number">0</span> &#125;; 			<span class="comment">//所有元素值均为0</span></span><br><span class="line">al = a2;							<span class="comment">//替换a1中的元素</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;;							<span class="comment">//错误:不能将一个花括号列表赋予数组</span></span><br></pre></td></tr></table></figure>

<p>c1=c2                                    将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型<br>c={a,b,c…}                            将cl中元素替换为初始化列表中元素的拷贝（array不适用)<br>swap（c1,c2）                    交换c1和 c2中的元素。c1和 c2必须具有相同的类型。swap通常<br>c1.swap （c2）                    比从c2向c1拷贝元素快得多<br>assign                                    操作不适用于关联容器和array<br>seq.assign (b,e)                    将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素<br>seq.assign (il)                        将seq中的元素替换为初始化列表i1中的元素<br>seq.assign （n,t）                将seq中的元素替换为n个值为t的元素</p>
<p><em>注意：赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效(容器类型为array和string的情况除外)。</em></p>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>在顺序容器（除array外）中可以assign成员赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;oldstyle;</span><br><span class="line">names = oldstyle; 							<span class="comment">//错误:容器类型不匹配</span></span><br><span class="line"><span class="comment">//正确:可以将const char*转换为string</span></span><br><span class="line">names.<span class="built_in">assign</span> (oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>() );</span><br></pre></td></tr></table></figure>

<p>由于其旧元素被替换,因此传递给assign的迭代器不能指向调用assign的容器。</p>
<p>第二种用法接受整型值和一个元素值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等价于slist1.clear ();</span></span><br><span class="line"><span class="comment">//后跟slist1.insert(slist1.begin (),10，&quot;Hiya ! &quot;);</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">slist1</span> <span class="params">(<span class="number">1</span>)</span></span>;				<span class="comment">// 1个元素，为空string</span></span><br><span class="line">slist1.<span class="built_in">assign</span> (<span class="number">10</span>,<span class="string">&quot;Hiya ! &quot;</span>);			<span class="comment">// 10个元素，每个都是“Hiya !”</span></span><br></pre></td></tr></table></figure>

<h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span> <span class="params">(<span class="number">10</span>)</span></span>; 		<span class="comment">// 10个元素的vector</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span> <span class="params">(<span class="number">24</span>)</span></span>; 		<span class="comment">// 24个元素的vector</span></span><br><span class="line"><span class="built_in">swap</span> (svec1, svec2 );</span><br></pre></td></tr></table></figure>

<p>除arraay，swap操作不对任何元素进行拷贝、删除、和插入，所以可以在常熟时间内完成，它只是交换了容器内部的数据结构（人话就是交换了头指针）。所以迭代器、引用、指针并不会失效，且所指向的元素也不会变，原本指向s1[1]的迭代器与s2交换后会指向s2[1]。但string调用swap会使迭代器、引用、指针失效。</p>
<p>array容器中使用swap会真正交换元素，所以时间会取决于元素数量，此外指针、引用、迭代器绑定的s1[1]现在还使s1[1]，</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>与大小相关的操作，size、empty、和max_size：返回容器所能容纳的最大元素数目。</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>除了无需关联容器外都支持关系运算符，但容器中的元素类型必须一样。比较容器实际上是逐对比较：</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等;否则两个容器不等。</li>
<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = &#123; <span class="number">1</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">7</span>,<span class="number">9</span>，<span class="number">12</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = &#123; <span class="number">1</span>,<span class="number">3</span>，<span class="number">9</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = &#123; <span class="number">1</span>,<span class="number">3</span>，<span class="number">5</span>,<span class="number">7</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4 = &#123; <span class="number">1</span>,<span class="number">3</span>，<span class="number">5</span>，<span class="number">7</span>，<span class="number">9</span>，<span class="number">12</span> &#125;;</span><br><span class="line">vl &lt; v2 			<span class="comment">// true; v1和v2在元素[2]处不同: v1[2]小于等于v2[2]</span></span><br><span class="line">vl &lt; v3				<span class="comment">// false;所有元素都相等，但v3中元素数目更少</span></span><br><span class="line">vl == v4 			<span class="comment">// true;每个元素都相等，且v1和v4大小相同</span></span><br><span class="line">vl == v2 			<span class="comment">// false; v2元素数目比v1少</span></span><br></pre></td></tr></table></figure>

<h4 id="容器的关系运算符使用元素的关系运算符"><a href="#容器的关系运算符使用元素的关系运算符" class="headerlink" title="容器的关系运算符使用元素的关系运算符"></a>容器的关系运算符使用元素的关系运算符</h4><p>容器的相等运算符实际上是使用元素的==运算符实现比较的,而其他关系运算符是使用元素的&lt;运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。例如,我们在第7章中定义sales_data类型并未定义==-和&lt;运算。</p>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p>接下来介绍顺序容器的特有操作：</p>
<h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p><img src="https://s2.loli.net/2022/01/04/qDcn1vAxsJ7LuCM.png" alt="image.png"></p>
<p>当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string 的尾部之外的任何位置,或是一个deque的首尾之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。</p>
<h4 id="使用push-back"><a href="#使用push-back" class="headerlink" title="使用push_back"></a>使用push_back</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从标准输入读取数据，将每个单词放到容器末尾string word;</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">	container.<span class="function">push <span class="title">back</span> <span class="params">(word)</span></span>;</span><br></pre></td></tr></table></figure>

<p>tip：当我们用对象初始化、或插入到容器时，实际上会先拷贝这个对象生成临时对象，再初始化或插入它。</p>
<h4 id="在特定的位置添加元素"><a href="#在特定的位置添加元素" class="headerlink" title="在特定的位置添加元素"></a>在特定的位置添加元素</h4><p>insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector.deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。</p>
<p><code>slist.insert(iter，&quot;Hello! &quot;);//将&quot;Hello ! &quot;添加到iter之前的位置</code></p>
<p>有些容器（如vector）不支持push_front但可以使用insert来插入到开始的位置。</p>
<p><code>svec.insert (svec.end(), 10,&quot;Anna&quot; ); //将10个Anna插入到尾部 </code></p>
<p>同时还有接受迭代器的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v = &#123; <span class="string">&quot;quasi&quot;</span>,<span class="string">&quot;simba&quot;</span>,<span class="string">&quot;frollo&quot;</span>, <span class="string">&quot;scar&quot;</span>&#125;;		</span><br><span class="line"><span class="comment">//将v的最后两个元素添加到slist的开始位置</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span> (), v.<span class="built_in">end</span> () - <span class="number">2</span>, v.<span class="built_in">end</span>() ) ;</span><br><span class="line">slist.<span class="built_in">insert</span> (slist.<span class="built_in">end</span>(),&#123; <span class="string">&quot;these&quot;</span>，<span class="string">&quot;words&quot;</span>,<span class="string">&quot;will&quot;</span>，<span class="string">&quot;go&quot;</span>, <span class="string">&quot;at&quot;</span> , <span class="string">&quot;the&quot;</span>, <span class="string">&quot;end&quot;</span> ) );</span><br><span class="line"><span class="comment">//运行时错误:迭代器表示要拷贝的范围，不能指向与目的位置相同的容器</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span> (), slist.<span class="built_in">begin</span> (), slist.<span class="built_in">end</span> () ) ;</span><br></pre></td></tr></table></figure>

<p>不可以将一对指向自己的迭代器传入insert。</p>
<h4 id="insert返回值"><a href="#insert返回值" class="headerlink" title="insert返回值"></a>insert返回值</h4><p>通过使用insert的返回值，可以在容器中一个特定位置反复插入元素:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.<span class="built_in">begin</span> ();</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">	iter = lst.<span class="built_in">insert</span> (iter, word);			 <span class="comment">//等价于调用push_front</span></span><br></pre></td></tr></table></figure>

<p>insert返回的是第一个新加入元素的迭代器，如果不插入（即只有第一个参数），就返回传入的第一个参数。</p>
<h4 id="使用emplace"><a href="#使用emplace" class="headerlink" title="使用emplace"></a>使用emplace</h4><p>新标准引入了三个新成员——emplace_front、emplace和 emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back,允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在c的末尾构造一个sales_data对象</span></span><br><span class="line"><span class="comment">//使用三个参数的sales_data构造函数</span></span><br><span class="line">c.<span class="built_in">emplace_back</span> ( <span class="string">&quot;978-0590353403&quot;</span>,<span class="number">25</span>,<span class="number">15.99</span>);</span><br><span class="line"><span class="comment">//错误:没有接受三个参数的push_back 版本</span></span><br><span class="line">c.<span class="built_in">push_back</span> (<span class="string">&quot;978-0590353403&quot;</span>,<span class="number">25</span>,<span class="number">15.99</span>);	</span><br><span class="line"><span class="comment">//正确:创建一个临时的Sales_data对象传递给push back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>，<span class="number">25</span>,<span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>

<p>它与push或insert的区别在于它可以直接调用元素类型的构造函数在容器中直接创建，而push需要创建临时的对象，然后压入容器，但传入参数必须匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iter指向c中一个元素，其中保存了sales data元素</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(); <span class="comment">//使用Sales_data的默认构造函数</span></span><br><span class="line">c.<span class="built_in">emplace</span>(iter,<span class="string">&quot;999-999999999&quot;</span>);<span class="comment">//使用sales_data (string)</span></span><br><span class="line"><span class="comment">//使用sales_data的接受一个ISBN、一个 count和一个price的构造函数</span></span><br><span class="line">c.<span class="built_in">emplace_front</span> ( <span class="string">&quot;978-0590353403&quot;</span>，<span class="number">25</span>，<span class="number">15.99</span>) ;</span><br></pre></td></tr></table></figure>

<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在解引用一个迭代器或调用front或back之前检查是否有元素</span></span><br><span class="line"><span class="keyword">if</span> ( !c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	<span class="comment">// val和val2是c中第一个元素值的拷贝</span></span><br><span class="line">	<span class="keyword">auto</span> val = *c.<span class="built_in">begin</span> () , val2 =c.<span class="built_in">front</span> ();</span><br><span class="line">	<span class="comment">// val3和val4是c中最后一个元素值的拷贝</span></span><br><span class="line">	<span class="keyword">auto</span> last = c.<span class="built_in">end</span> () ;</span><br><span class="line">	<span class="keyword">auto</span> val3 = *(--last); 				<span class="comment">//不能递减forward_ list迭代器</span></span><br><span class="line">	<span class="keyword">auto</span> val4 = c.<span class="built_in">back</span> ();				<span class="comment">//forward_list不支持</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.bmp.ovh/imgs/2022/01/9dab196d3337ea4c.png"></p>
<h4 id="访问成员函数返回引用"><a href="#访问成员函数返回引用" class="headerlink" title="访问成员函数返回引用"></a>访问成员函数返回引用</h4><p>const容器返回const引用，如果使用auto保存返回值，并希望改变元素的值，必须定义为引用类型：</p>
<p><code>auto &amp;v = c.back();</code></p>
<h4 id="下标操作和安全的随机访问"><a href="#下标操作和安全的随机访问" class="headerlink" title="下标操作和安全的随机访问"></a>下标操作和安全的随机访问</h4><p>为保证使用下标访问不会越界，可以使用at，它会在下标越界时抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; svec;					<span class="comment">//空vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>] ;						<span class="comment">//运行时错误: svec中没有元素!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>) ;					<span class="comment">//抛出一个out_ of_ range异常</span></span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://s2.loli.net/2022/01/05/zESjes4XYWbaGAU.png" alt="image.png"></p>
<h4 id="pop函数"><a href="#pop函数" class="headerlink" title="pop函数"></a>pop函数</h4><p>这些操作返回void，如果需要弹出元素的值，就必须在执行弹出前保存它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!ilist. <span class="built_in">empty</span>()) &#123;</span><br><span class="line">	<span class="built_in">process</span> (ilist. <span class="built_in">front</span>()) ; 		<span class="comment">//对ilist的首元素进行一些处理</span></span><br><span class="line">	ilist.<span class="function">pop_ <span class="title">front</span><span class="params">()</span> </span>;			<span class="comment">//完成处理后删除首元素.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊的forward-list"><a href="#特殊的forward-list" class="headerlink" title="特殊的forward_list"></a>特殊的forward_list</h3><p>因为单向链表删除或者添加一个元素会改变前一个元素，但单向链表没办法访问前驱，所以我们可以添加或者删除给定元素之后的元素，</p>
<p><img src="https://s2.loli.net/2022/01/05/seFWG3P6RDQacIH.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forward_ list&lt;<span class="keyword">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> prev = flst.before_ <span class="built_in">begin</span>() ;				<span class="comment">//表示flst的“首前元素’</span></span><br><span class="line"><span class="keyword">auto</span> curr = flst.<span class="built_in">begin</span>() ;						<span class="comment">//表示flst中的第一个元素</span></span><br><span class="line"><span class="keyword">while</span> (curr != flst.<span class="built_in">end</span>()) &#123;					<span class="comment">//仍有元素要处理</span></span><br><span class="line"><span class="keyword">if</span>(*curr % <span class="number">2</span>)									<span class="comment">//若元素为奇数</span></span><br><span class="line">	curr = flst.erase_ <span class="built_in">after</span> (prev) ;			<span class="comment">//删除它并移动curr</span></span><br><span class="line"><span class="keyword">else</span> &#123;		</span><br><span class="line">	prev = curr;								<span class="comment">//移动迭代器curr,指向下	一个元素，prev指向</span></span><br><span class="line">	++curr ;									<span class="comment">// curr 之前的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p><img src="https://s2.loli.net/2022/01/05/JM9wUthlFSPW2Dd.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>， <span class="number">42</span>)</span> </span>;					<span class="comment">// 10个int:每个的值都是42</span></span><br><span class="line">ilist. <span class="built_in">resize</span>(<span class="number">15</span>) ;							<span class="comment">//将5个值为0的元素添加到ilist的末尾.</span></span><br><span class="line">ilist. <span class="built_in">resize</span>(<span class="number">25</span>，<span class="number">-1</span>) ;						<span class="comment">//将10个值为-1的元素添加到ilist的末尾</span></span><br><span class="line">ilist. <span class="built_in">resize</span>(<span class="number">5</span>) ;							<span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector、string和deque尤为重要。</p>
<h4 id="编写改变容器的循环程序"><a href="#编写改变容器的循环程序" class="headerlink" title="编写改变容器的循环程序"></a>编写改变容器的循环程序</h4><p>添加/删除vector、string 或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//傻瓜循环，删除偶数元素，复制每个奇数元素</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = vi.<span class="built_in">begin</span>(); <span class="comment">//调用begin而不是cbegin,因为我们要改变vi</span></span><br><span class="line"><span class="keyword">while</span> (iter != vi.<span class="built_in">end</span>()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (*iter % <span class="number">2</span>) &#123;</span><br><span class="line">		iter = vi.<span class="built_in">insert</span>(iter, *iter);	 		<span class="comment">//复制当前元素</span></span><br><span class="line">		iter += <span class="number">2</span>; <span class="comment">//向前移动迭代器，跳过当前元素以及插入到它之前的元素</span></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		iter = vi.<span class="built_in">erase</span> (iter) ;				<span class="comment">//删除偶数元素</span></span><br><span class="line">		<span class="comment">//不应向前移动迭代器，iter 指向我们删除的元素之后的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要保存end返回的迭代器"><a href="#不要保存end返回的迭代器" class="headerlink" title="不要保存end返回的迭代器"></a>不要保存end返回的迭代器</h4><p>因为插入删除操作会使end迭代器失效。</p>
<h2 id="vector对象如何增长"><a href="#vector对象如何增长" class="headerlink" title="vector对象如何增长"></a>vector对象如何增长</h2><p>vector和string在添加元素时如果大小其容量，会开辟一块比预定容量更大的地方。</p>
<h4 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h4><p><img src="https://s2.loli.net/2022/01/05/WVmEnM7oGTHrAFh.png" alt="image.png"></p>
<p>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间，不过只有当需要的内存超过当前容量时，才会改变容量。一旦调用，会至少分配与需求一样大或更大的空间。</p>
<h4 id="capacity和size"><a href="#capacity和size" class="headerlink" title="capacity和size"></a>capacity和size</h4><p><img src="https://s2.loli.net/2022/01/05/Dztf3cgMVAWZoHY.png" alt="image.png"></p>
<p>每个 vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是:只有当迫不得已时才可以分配新的内存空间。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="https://s2.loli.net/2022/01/05/oGYKtCiTkrZdh23.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">&quot;Hello world!!! &quot;</span>;		<span class="comment">//以空字符结束的数组</span></span><br><span class="line"><span class="keyword">char</span> noNull[]=&#123;<span class="string">&#x27;H’, &#x27;</span>i<span class="number">&#x27;</span>&#125;;				<span class="comment">//不是以空字符结束</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(cp)</span></span>;							<span class="comment">// 拷贝cp中的字符直到遇到空字符;s1 == &quot;Helloworld!!!&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(noNull,<span class="number">2</span>)</span></span>;					<span class="comment">//从noNull拷贝两个字符;s2 == &quot;Hi&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s3</span> <span class="params">(noNull)</span></span>;						<span class="comment">//未定义:noNull不是以空字符结束</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(cp + <span class="number">6</span>，<span class="number">5</span>)</span></span>;					<span class="comment">//从cp [ 6]开始拷贝5个字符;s4 ==&quot;world&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(s1,<span class="number">6</span>，<span class="number">5</span>)</span> </span>;						<span class="comment">//从s1 [ 6]开始拷贝5个字符;s5 == &quot;world&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(s1,<span class="number">6</span>)</span></span>;						<span class="comment">//从s1[ 6]开始拷贝，直至s1末尾;s6== &quot;world! ! !&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s1,<span class="number">6</span>,<span class="number">20</span>)</span></span>;						<span class="comment">//正确，只拷贝到s1末尾;s7 == &quot;world! ! ! &quot;</span></span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(s1,<span class="number">16</span>)</span></span>;						<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>

<h4 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s.<span class="built_in">substr</span> (<span class="number">0</span>,<span class="number">5</span>);			<span class="comment">// s2 = hello</span></span><br><span class="line">string s3 = s.<span class="built_in">substr</span> (<span class="number">6</span>);			<span class="comment">// s3 = world</span></span><br><span class="line">string s4 = s.<span class="built_in">substr</span> (<span class="number">6</span>,<span class="number">11</span>);		<span class="comment">// s3 = world</span></span><br><span class="line">string s5 = s.<span class="built_in">substr</span> (<span class="number">12</span>);			<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>

<p>返回一个string，包含s中从pos 开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size () - pos，即拷贝从pos开始的所有字符，开始位置超过大小，会抛出一个异常，结束位置超出大小，会默认拷贝string的末尾。</p>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><p>除了接受迭代器的insert和 erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="number">5</span>，<span class="string">&#x27;!&#x27;</span>);				<span class="comment">//在s末尾插入5个感叹号</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>()- <span class="number">5</span>，<span class="number">5</span>);					<span class="comment">//从s删除最后5个字符</span></span><br></pre></td></tr></table></figure>

<p>标准库string类型还提供了接受C风格字符数组的insert和 assign版本。例如，我们可以将以空字符结尾的字符数组insert 到或assign给一个string：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">&quot;stately, plump Buck&quot;</span>;</span><br><span class="line">s.<span class="built_in">assign</span>(cp,<span class="number">7</span>);						<span class="comment">// s == &quot;Stately&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span> (s.<span class="built_in">size</span>(), cp + <span class="number">7</span>); 		<span class="comment">// s == &quot;Stately, plump Buck&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以指定将来自其他string或子字符串的字符插入到当前string中或赋予当前string:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;some string&quot;</span>, s2 = <span class="string">&quot;some other string&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span> (<span class="number">0</span>, s2); 				<span class="comment">//在s中位置0之前插入s2的拷贝</span></span><br><span class="line"><span class="comment">//在s [0]之前插入s2中s2[0]开始的s2.size()个字符</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>,s2，<span class="number">0</span>, s2.<span class="built_in">size</span> ());</span><br></pre></td></tr></table></figure>

<h4 id="append和replace函数"><a href="#append和replace函数" class="headerlink" title="append和replace函数"></a>append和replace函数</h4><p>append操作是在string末尾进行插入操作的一种简写形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>,s2 </span>= s;				<span class="comment">//将s 和s2初始化为&quot;C++ Primer&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span> (s.<span class="built_in">size</span>(),<span class="string">&quot; 4th Ed.&quot;</span>);				<span class="comment">//s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span> );						<span class="comment">//等价方法:将”4th Ed.&quot;追加到s2;s == s2</span></span><br></pre></td></tr></table></figure>

<p>replace操作是调用erase和insert的一种简写形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将&quot;4th&quot;替换为&quot;5th&quot;的等价方法</span></span><br><span class="line">s.<span class="built_in">erase</span> (<span class="number">11</span>，<span class="number">3</span>);								<span class="comment">// s == &quot;C++ Primer Ed . &quot;</span></span><br><span class="line">s.<span class="built_in">insert</span> (<span class="number">11</span>，<span class="string">&quot;5th&quot;</span> ) ;						<span class="comment">// s == &quot;C++ Primer 5th Ed . &quot;</span></span><br><span class="line"><span class="comment">//从位置11开始，删除3个字符并插入&quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>,<span class="number">3</span>,<span class="string">&quot;5th&quot;</span>);						<span class="comment">//等价方法:s == s2</span></span><br></pre></td></tr></table></figure>

<p>此例中调用replace时，插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长或更短的string：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(<span class="number">11</span>,<span class="number">3</span>，<span class="string">&quot;Fifth&quot;</span>);					<span class="comment">// s == &quot;C++ Primer Fifth Ed.&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/05/qoMRSHQDpfwEIbx.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/05/9ptseuHrRPWhkQE.png" alt="image.png"></p>
<h4 id="改变string的多种重载函数"><a href="#改变string的多种重载函数" class="headerlink" title="改变string的多种重载函数"></a>改变string的多种重载函数</h4><p>assign和 append函数无须指定要替换string中哪个部分: assign总是替换string中的所有内容，append总是将新字符追加到string末尾。<br>replace函数提供了两种指定删除元素范围的方式。可以通过一个位置和一个长度来指定范围，也可以通过一个迭代器范围来指定。insert函数允许我们用两种方式指定插入点:用一个下标或一个迭代器。在两种情况下，新元素都会插入到给定下标（或迭代器）之前的位置。<br>可以用好几种方式来指定要添加到string 中的字符。新字符可以来自于另一个string，来自于一个字符指针（指向的字符数组)，来自于一个花括号包围的字符列表，或者是一个字符和一个计数值。当字符来自于一个string或一个字符指针时，我们可以传递一个额外的参数来控制是拷贝部分还是全部字符。</p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p>搜索操作：成功返回一个无符号的string::size_type值，失败返回npos（cont string::size_type）的static成员（他们应该是同一种类型，但变量名字不同），因此不建议使用int储存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">name</span> <span class="params">(<span class="string">&quot;AnnaBelle&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> posl = name.<span class="built_in">find</span> ( <span class="string">&quot;Anna&quot;</span>); <span class="comment">// pos1 ==o</span></span><br><span class="line"><span class="function">string <span class="title">lowercase</span> <span class="params">( <span class="string">&quot;annabelle&quot;</span> )</span></span>;</span><br><span class="line">pos1 = lowercase.<span class="built_in">find</span> ( <span class="string">&quot;Anna&quot;</span>); <span class="comment">// posl ==npos</span></span><br></pre></td></tr></table></figure>

<p>find操作对大小写有区分A与a会区分开来</p>
<p><img src="https://s2.loli.net/2022/01/06/VsEzD1wLRlknOHC.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/06/lRdCGfg7n1Qtx5Z.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">numbers</span> <span class="params">( <span class="string">&quot;0123456789&quot;</span>)</span>, <span class="title">name</span> <span class="params">( <span class="string">&quot;r2d2&quot;</span>)</span> </span>;</span><br><span class="line"><span class="comment">//返回1，即，name中第一个数字的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos = name . <span class="built_in">find_first_of</span> (numbers) ;</span><br><span class="line"><span class="function">string <span class="title">dept</span> <span class="params">( <span class="string">&quot;03714p3&quot;</span>)</span></span>;				</span><br><span class="line"><span class="comment">//返回5——字符&#x27;p&#x27;的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos = dept.find_ <span class="built_in">first_not_of</span> (numbers) ;</span><br></pre></td></tr></table></figure>

<h4 id="指定可选位置"><a href="#指定可选位置" class="headerlink" title="指定可选位置"></a>指定可选位置</h4><p>find函数第二个参数为从哪里开始，默认为0，使用它可以在字符串中循环搜索子字符串的所有位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string : : size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//每步循环查找name中下一个数</span></span><br><span class="line"><span class="keyword">while</span> ((pos = name.<span class="built_in">find_first_of</span> (numbers, pos)) != string::npos) &#123;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;found number at index : &quot;</span> &lt;&lt; pos &lt;&lt;<span class="string">&quot; element is &quot;</span> &lt;&lt;name [pos] &lt;&lt; endl;</span><br><span class="line">	++pos; <span class="comment">//移动到下一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">river</span> <span class="params">( <span class="string">&quot;Mississippi&quot;</span> )</span></span>;</span><br><span class="line"><span class="keyword">auto</span> first_pos = river.<span class="built_in">find</span> ( <span class="string">&quot;is&quot;</span>); <span class="comment">//返回1</span></span><br><span class="line"><span class="keyword">auto</span> last_pos - river.<span class="built_in">rfind</span> ( <span class="string">&quot;is&quot;</span>); <span class="comment">//返回4</span></span><br></pre></td></tr></table></figure>

<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p>string类型提供的与C标准库 的strcmp函数相似的函数，根据s等于、大小、小于返回0、整数、负数。</p>
<p><img src="https://s2.loli.net/2022/01/06/UOMwx7VGFYivyQZ.png" alt="image.png"></p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>一些函数以可实现string与数值的转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">string s = <span class="built_in">to_string</span>(i); 			<span class="comment">//将整数i转换为字符表示形式</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="built_in">stod</span> (s) ;				<span class="comment">//将字符串s转换为浮点数</span></span><br></pre></td></tr></table></figure>

<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符:string s2 = “pi = 3.14” ;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换s中以数字开始的第一个子串，结果d = 3.14</span></span><br><span class="line">d = <span class="built_in">stod</span>(s2.<span class="built_in">substr</span>(s2.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>这里将字符串种第一个出现数字的地方的子串传入函数，直到遇到不可能是数值的字符，然后将其转换。参数中第一个非空白符号必须是+、0、数字或是是小数点，且可以包含e、E、x、X等其他进制需要的字母。</p>
<p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常(参见5.6节,第173页)。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of range异常。</p>
<p><img src="https://s2.loli.net/2022/01/06/lV9SMO86bwkrU3t.png" alt="image.png"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list外)，并使其操作起来像一个stack一样。</p>
<p><img src="https://s2.loli.net/2022/01/06/DGh3m28PF9JMHBo.png" alt="image.png"></p>
<h4 id="定义一个适配器"><a href="#定义一个适配器" class="headerlink" title="定义一个适配器"></a>定义一个适配器</h4><p>首先我们可以用一个容器初始化另一个容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deq = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">stack&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span> <span class="params">(deq)</span></span>; <span class="comment">//从deq考贝元素到stk</span></span><br></pre></td></tr></table></figure>

<p>我们还可以尖括号内重载构造函数，就可以创建一个适配器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在vector上实现的空栈</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">//str_stk2在vector上实现，初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span> (svec) ;</span><br></pre></td></tr></table></figure>

<p>所有适配器都要求有添加和删除以及访问尾元素能力，所以不能用array、forward_list构造。</p>
<h4 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h4><p><img src="https://s2.loli.net/2022/01/06/Bcsm8PfhJG9RkeV.png" alt="image.png"></p>
<p>栈默认基于deque实现，所以可以省略第二个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; intstack; <span class="comment">//空栈</span></span><br><span class="line"><span class="comment">//填满栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)</span><br><span class="line">	intStack.<span class="built_in">push</span> (ix);				<span class="comment">// intStack保存0到9十个数</span></span><br><span class="line"><span class="keyword">while</span> ( !intstack.<span class="built_in">empty</span>()) &#123;		<span class="comment">// intStack中有值就继续循环</span></span><br><span class="line">	<span class="keyword">int</span> value = intStack.<span class="built_in">top</span> ( ) ;</span><br><span class="line">	<span class="comment">//使用栈顶值的代码</span></span><br><span class="line">	intStack.<span class="built_in">pop</span>() ;				 <span class="comment">//弹出栈顶元素，继续循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然是基于deque实现，但我们不能使用底层容器的操作，所以只可以用push，而不可以使用push_back。</p>
<h4 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h4><p><img src="https://s2.loli.net/2022/01/06/hUFVraqMufPLTQd.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/06/XtO2ciYCGe3zTFd.png" alt="image.png"></p>
<p>priority_queue 允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。默认情况下，标准库在元素类型上使用&lt;运算符来确定相对优先级。后面会学习如何重载这个默认设置。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>最全最详细的hexo博客搭建教程</title>
    <url>/2021/12/10/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><strong>因为网上很多叫教程都是缺一点东西，导致只能自己去看报错解决，花了一些时间，所以为了大家不继续踩坑，我将全部的过程都写了下来，如果还是不能成功欢迎在评论区留下你的问题。</strong></p>
<h2 id="下载环境"><a href="#下载环境" class="headerlink" title="下载环境"></a>下载环境</h2><p>下载下面两个软件，安装时直接一直跳过就好</p>
<ul>
<li><p>Node.js下载:<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<p>选择长期维护版</p>
<p>安装教程: <a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">https://www.cnblogs.com/liuqiyun/p/8133904.html</a></p>
</li>
<li><p>Git下载:<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<span id="more"></span>

<p><img src="https://s2.loli.net/2021/12/12/ysxOWvEPJ6GB9Qa.png" alt="image.png"></p>
<p>蛋装教程，<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p>
</li>
</ul>
<p>win+r打开运行窗口输入cmd</p>
<p>在窗口下载Hexo ：输入： npm install hexo-cli -g  </p>
<p>之后回车，每个空格都不能漏掉！</p>
<p><img src="https://s2.loli.net/2021/12/12/GhDAEYmnRQyrc8T.png" alt="image.png"></p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>接着在刚才的cmd窗口输入以下三个命令，一个一个的输入</p>
<p>node -v</p>
<p>npm -v</p>
<p>git –version(注意这里是两个减号)</p>
<p>hexo -v</p>
<p>只要出来的是版本号就代表安装成功了</p>
<p><img src="https://s2.loli.net/2021/12/12/OkwVzTdurtLgWsi.png" alt="image.png"></p>
<h2 id="注册github账号"><a href="#注册github账号" class="headerlink" title="注册github账号"></a>注册github账号</h2><p>注册一个github账号，可以自行百度如何注册，因为账号名字就是以后的网址，所以起的好的一些</p>
<p>接着点new，建立一个仓库，</p>
<p><img src="https://s2.loli.net/2021/12/12/ASVpGWXZ6HFaTzB.png" alt="image.png"></p>
<p>仓库名= 用户名.github.io,公共，底下无所谓</p>
<p><img src="https://s2.loli.net/2021/12/12/OqJh6Z5tHnVzfx3.png" alt="image.png"></p>
<p>在任何一个文件夹内右键，点击GIit Bash Here</p>
<p>输入：ssh-keygen -t rsa -C “邮件地址”</p>
<p>注意这里粘贴不是ctrl+v，可以右键粘贴，之后连续敲四次回车，间隔一点时间。</p>
<p>成功之后大概是这样：</p>
<p><img src="https://s2.loli.net/2021/12/12/MtlkbuqE9BrvFpD.png" alt="image.png"></p>
<p>C:\ Users \ Administrator \ .ssh 在这个路径下找到.ssh,找不到就在c盘搜一下。</p>
<p>用记事本打开id_rsa.pub，复制全部内容。</p>
<p>打开github网站，点击右上角自己的头像旁边的小箭头，点击seting，之后如下</p>
<p><img src="https://s2.loli.net/2021/12/12/ArjYKODFPVh2exb.png" alt="image.png"></p>
<p>名称随便输一个，在下面粘贴刚才.ssh找到的内容。</p>
<p>在GIit Bash Here窗口中测试ssh是否绑定成功，输入：ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a></p>
<p>输入yes</p>
<p>出现hi  。。。就成功了。</p>
<h2 id="生成本地博客"><a href="#生成本地博客" class="headerlink" title="生成本地博客"></a>生成本地博客</h2><p>在电脑的任意一个自己喜欢的位置创建自己的bolg文件夹。</p>
<p>进入这个文件夹，在里面右键打开GIit Bash Here，安装hexo。输入：hexo init<br>这里等待时间会比较长，但是出现 start blogging with Hexo!就代表成功了</p>
<p>接着要记住下面这两条命令，后面很常用。</p>
<p>hexo g #生成网站静态文件到默认设置的 public 文件夹。<br>hexo s#启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<p>依次输入它们，接着就可以通过这个上面的网址访问本地的博客。</p>
<h2 id="发布博客到互联网"><a href="#发布博客到互联网" class="headerlink" title="发布博客到互联网"></a>发布博客到互联网</h2><p>在github找到自己的仓库打开，在左上角，依次点击复制你的SSH。</p>
<p><img src="https://s2.loli.net/2021/12/12/sezBMXH63wDpOPG.png" alt="image.png"></p>
<p>在自己的博客文件夹中找到_config.yml文件，打开。拉到最后找到deploy。删掉原来的deploy后面的东西输入下面的代码：</p>
<p>deploy:<br>  type: git<br>  repo: 这里是你刚刚复制的东西。<br>  branch: main</p>
<p><strong>注意：后有一个空格，且一定要是英文符号</strong></p>
<p>依然在自己的博客文件夹GIit Bash Here窗口安装hexo-deployer-git自动部署发布工具，输入：npm install hexo-deployer-git –save</p>
<p>之后绑定你的邮箱和账号，输入：git config user.name “username” 和 git config user.email “email”</p>
<p>用户名和邮箱都是注册github提到的。</p>
<h1 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h1><p>hexo -g </p>
<p>hexo -d</p>
<p>将你的仓库名复制粘贴到浏览器就可以啦！别忘了留下你的网站哦~</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第五章</title>
    <url>/2021/12/10/%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p><strong>空语句</strong></p>
<p>当某个地方语法上需要，逻辑上不需要，则会使用，且应该加注释标明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重复读入数据直至到达文件末尾或某次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp;s != sought)</span><br><span class="line">	; <span class="comment">//空语句</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>复合语句</strong></p>
<p>指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块(block)。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的（最内层）块的结尾为止，通常在语法上需要一条语句，但逻辑上需要多条语句的使用。</p>
<p><em>所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句:</em></p>
<hr>
<h2 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h2><p>可以在if、switch、while和 for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了。</p>
<hr>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if else语句的形式是</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	statement2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>悬垂else</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误:实际的执行过程并非像缩进格式显示的那样; else 分支匹配的是内层if语句</span></span><br><span class="line"><span class="keyword">if</span> (grade % <span class="number">10</span> &gt;= <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">if</span>(grade % <span class="number">10</span> &gt;<span class="number">7</span>)</span><br><span class="line">		lettergrade += <span class="string">&#x27;+&#x27;</span>; <span class="comment">//末尾是8或者9的成绩添加一个加号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	lettergrade += <span class="string">&#x27;-&#x27;</span>;<span class="number">1</span>/末尾是<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span>或者<span class="number">7</span>的成绩添加一个减号!</span><br></pre></td></tr></table></figure>

<p>这里程序将else与内层if匹配，导致错误，加上花括号可避免此问题。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (ch)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">		++aCnt;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">		++eCnt;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>break 跳转出switch，case必须是整形常量表达式，一个switch内case不能相同。</p>
<p><strong>内部控制流</strong></p>
<p>有时候故意省略break语句，使得程序连续执行多个标签。如：也许我们想统计的是所有元音字母出现的总次数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> voweICnt =o;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (ch)&#123;</span><br><span class="line">	<span class="comment">//出现了a、e、 i、o或u中的任意一个都会将vowelCnt的值加1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> :</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> :</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span> :</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span> :</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span> :<span class="comment">//也可以不换行，写成case &#x27;a&#x27; : case &#x27;e&#x27; : case &#x27;i&#x27; : case &#x27;o&#x27; : case &#x27;u&#x27; :</span></span><br><span class="line">		++Vowelcnt;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><label stype = "color:red">一般情况不要漏写break，不写需加注释说明。</label></p>
<p><strong>default标签</strong></p>
<p>如果没有任何一个case 标签能匹配上 switch 表达式的值，程序将执行紧跟在default 标签(default label）后面的语句。例如，可以增加一个计数值来统计非元音字母的数量，只要在 default分支内不断递增名为otherCnt的变量就可以了。</p>
<p><strong>内部变量定义</strong></p>
<p>如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:&#123;</span><br><span class="line">	<span class="comment">//正确:声明语句位于语句块内部</span></span><br><span class="line">	string file_name = <span class="built_in">get_file_name</span> () ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">if</span> (file_name . <span class="built_in">empty</span>())<span class="comment">//错误:file_name不在作用域之内</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>当不确定循环多少次时或循环结束后访问循环控制变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//重复读入数据，直至到达文件末尾或者遇到其他输入问题</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">	v.<span class="built_in">push_back</span> (i);</span><br><span class="line"><span class="comment">//寻找第一个负值元素</span></span><br><span class="line"><span class="keyword">auto</span> beg = v.<span class="built_in">begin</span> ( );</span><br><span class="line"><span class="keyword">while</span> (beg != v.<span class="built_in">end</span> () &amp;&amp; *beg &gt;= <span class="number">0</span>)</span><br><span class="line">	++beg;</span><br><span class="line"><span class="keyword">if</span> (beg == v.<span class="built_in">end</span>( ))</span><br><span class="line">	<span class="comment">//此时我们知道v中的所有元素都大于等于0</span></span><br></pre></td></tr></table></figure>

<h3 id="传统for语句"><a href="#传统for语句" class="headerlink" title="传统for语句"></a>传统for语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-statemen; condition; expression)</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>

<p><label stype = "color:red">init-statemen指挥执行一次，牢记for语句头中定义的对象只在for循环体内可见。</label></p>
<p><strong>for语句头中的多重定义</strong></p>
<p>init-statemen可以定义多个变量，但只能定义一种类型。</p>
<p><strong>for语句头省略</strong></p>
<p>for语句头能省略掉init-statement、condition和 expression中的任何一个(或者全部)，但分号必须保留。</p>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>

<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><p>do while语句( do while statement）和 while语句非常相似，唯一的区别是，do while语句先执行循环体后检查··条件。不管条件的值如何，我们都至少执行一次循环。do while语句的语法形式如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">	statement</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(condition)</span> </span>;</span><br></pre></td></tr></table></figure>

<p>do while语句应该在括号包围起来的条件后面用一个分号表示语句结束。</p>
<p><label stype = "color:red">因为对于do while来说先执行语句或者块，后判断条件，所以不允许在条件部分定义变量。</label></p>
<hr>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break语句(break statement）负责终止离它最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始继续执行。</p>
<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue语句（continue statement）终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在 for、while和 do while循环的内部，或者嵌套在此类循环里的语句或块的内部。和 break语句不同的是，只有当switch语句嵌套在迭代语句内部时，才能在 switch里使用continue，它会使程序直接跳出switch，并重新执行switch外的循环。</p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</p>
<hr>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sales_item item1, item2;</span><br><span class="line">cin &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line"><span class="comment">//首先检查item1和item2是否表示同一种书籍</span></span><br><span class="line"><span class="keyword">if</span> (item1.<span class="built_in">isbn</span> () == item2 .<span class="built_in">isbn</span> () ) &#123;</span><br><span class="line">	cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表示成功</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> -l; <span class="comment">//表示失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先检查两条数据是否是关于同一种书籍的</span></span><br><span class="line"><span class="keyword">if</span> (item1.<span class="built_in">isbn</span> () != item2 .<span class="built_in">isbn</span> ( ))</span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">runtime_error</span> ( <span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line">	<span class="comment">//如果程序执行到了这里，表示两个ISBN是相同的</span></span><br><span class="line">cout &lt;&lt; item1 + item2 &lt;&lt; endl ;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	program-statements</span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> (exception-declaration)&#123;</span><br><span class="line">	handler-statements</span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> (exception-declaration) &#123;</span><br><span class="line">	handler-statements</span><br><span class="line">&#125; <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>try语句块的一开始是关键字try，随后紧跟着一个块，跟在try 块之后的是一个或多个catch子句。catch子句包括三部分:关键字catch、括号内一个(可能未命名的）对象的声明（称作<strong>异常声明，exception declaration</strong>）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch 一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p>
</li>
<li><p>try语句块中的program-statements组成程序的正常逻辑，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常，try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。</p>
</li>
</ul>
<p><strong>编写处理的代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//执行添加两个Sales_item对象的代码	</span></span><br><span class="line">		<span class="comment">//如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">		&#125; <span class="built_in"><span class="keyword">catch</span></span> (runtime_error err) &#123;</span><br><span class="line">			<span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">			cout &lt;&lt; err.<span class="built_in">what</span> () </span><br><span class="line">				 &lt;&lt; <span class="string">&quot;\nTry Again? Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">char</span> c ;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">        	<span class="keyword">if</span>(!cin || c== <span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果输入书籍不同，则会输出两句话：</p>
<p>Data must refer to same ISBN</p>
<p>Try Again? Enter y or n</p>
<p><strong>函数在寻找处理代码的过程中退出</strong>（*****）<br>在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的 catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。</p>
<p>如果最终还是没能找到任何匹配的 catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<p>处理复杂异常超出了本书的范围。</p>
<hr>
<h3 id="标准异常（-）"><a href="#标准异常（-）" class="headerlink" title="标准异常（*）"></a>标准异常（*）</h3><p>表5.1:<stdexcept>定义的异常类</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">exception</td>
<td align="center">最常见的问题</td>
</tr>
<tr>
<td align="center">runtime_error</td>
<td align="center">只有在运行时才能检测出的问题</td>
</tr>
<tr>
<td align="center">range_error</td>
<td align="center">运行时错误:生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td align="center">overflow_error</td>
<td align="center">运行时错误:计算上溢</td>
</tr>
<tr>
<td align="center">underflow_error</td>
<td align="center">运行时错误:计算下溢</td>
</tr>
<tr>
<td align="center">logic_error</td>
<td align="center">程序逻辑错误</td>
</tr>
<tr>
<td align="center">domain_error</td>
<td align="center">逻辑错误:参数对应的结果值不存在</td>
</tr>
<tr>
<td align="center">invalid_argument</td>
<td align="center">逻辑错误:无效参数</td>
</tr>
<tr>
<td align="center">length_error</td>
<td align="center">逻辑错误:试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td align="center">out_of_range</td>
<td align="center">逻辑错误:使用一个超出有效范围的值</td>
</tr>
</tbody></table>
<p>我们只能以默认初始化的方式初始化 exception,bad_alloc和 bad _cast对象，不允许为这些对象提供初始值。</p>
<p>其他异常类型的行为则恰好相反:应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第六章</title>
    <url>/2021/12/10/%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>包括返回类型、函数名字、0到多个形参组成的列表及函数体。</p>
<p>调用运算符来执行函数。函数的调用完成两项工作:一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数(calling function)的执行被暂时中断，被调函数（called function)开始执行。</p>
<p><strong>形参和实参</strong></p>
<p>形参和实参数量类型顺序必须一一对应。</p>
<span id="more"></span>

<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>形参和函数内部定义变量统称<strong>局部变量</strong>。同时局部变量还会隐藏在外层作用域中。函数体之外的对象存在于程序的整个执行过程中。局部变量的生命周期依赖定义的方式。</p>
<p><strong>自动对象</strong></p>
<p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。</p>
<p><strong>局部静态对象</strong></p>
<p>可以将局部变量定义成static类型从而获得这样的对象。局部静态对象(local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>
<p>如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。</p>
<p>因为函数的声明不包含函数体，所以也就无须形参的名字。在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字可以帮助使用者更好地理解函数的功能。</p>
<p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作<strong>函数原型</strong>。通常把它放在头文件中。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>一个项目由若干个源文件共同实现，而每个源文件(<strong>.cpp</strong>)单独编译成目标文件(<strong>.obj</strong>)，最后将所有目标文件连接起来形成单一的可执行文件(<strong>.exe</strong>)的过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">---------------test.h-------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//这里声明一个函数f</span></span><br><span class="line">---------------test.cpp--------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>”test.h”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">…<span class="comment">//do something</span></span><br><span class="line">&#125;  <span class="comment">//这里实现出test.h中声明的f函数</span></span><br><span class="line">---------------main.cpp--------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>”test.h”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(); <span class="comment">//调用f，f具有外部连接类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序在编译器内部的过程为：</p>
<ul>
<li>在编译mian.cpp的时候，编译器并不知道f的实现，所以当碰到对f的调用时只是给出一个<strong>指示</strong>，指示连接器为它寻找f的实现体，所以main.obj中没有关于f实现的二进制代码。</li>
<li>在编译test.cpp的时候，编译器找到了f的实现，所以在test.obj里有f实现的二进制代码。</li>
<li>连接时，连接器在test.obj中找到f实现的<strong>二进制地址</strong>，然后将main.obj中未解决的f地址替换成该二进制地址。</li>
</ul>
<p>作者：凉拌姨妈好吃<br>链接：<a href="https://www.jianshu.com/p/9ca511da30f4">https://www.jianshu.com/p/9ca511da30f4</a><br>来源：简书</p>
<hr>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>形参初始化的机理与变量初始化一样。形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上;否则，将实参的值拷贝后赋给形参。</p>
<ul>
<li>当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。和其他引用一样，引用形参也是它绑定的对象的别名;也就是说，引用形参是它对应的实参的别名。</li>
<li>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。</li>
</ul>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p><code>ret *= val--; //将val的值减1</code></p>
<p>尽管fact函数改变了val的值,但是这个改动不会影响传入fact的实参。调用fact (i)不会改变i的值。</p>
<p><strong>形参指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n= <span class="number">0</span>,i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;n, *q = &amp;i; 				<span class="comment">//p指向n;q指向i</span></span><br><span class="line">*p = <span class="number">42</span>;							<span class="comment">// n的值改变;p不变</span></span><br><span class="line">p =q;								<span class="comment">// p现在指向了i;但是i和n的值都不变</span></span><br></pre></td></tr></table></figure>

<p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值:</p>
<p><em>C++中建议使用引用代替指针</em></p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>引用参数可以改变引用对象的值。</p>
<p><strong>使用引用避免拷贝</strong></p>
<p>拷贝大的类类型对象或者容器对象比较低效，甚全有的类类型（包括IO类型在内)根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如string类型。若想避免改动可以加上const</p>
<p><strong>使用引用形参返回额外的信息</strong></p>
<p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。</p>
<p>举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数，该如何定义函数使得它能够既返回位置也返回出现次数呢?</p>
<ul>
<li>定义一个新的数据类型，让它包含位置和数量两个成员。</li>
<li>还有另一种更简单的方法，我们可以给函数传入一个额外的引用实参，令其保存字符出现的次数:</li>
</ul>
<h3 id="caonst形参和实参"><a href="#caonst形参和实参" class="headerlink" title="caonst形参和实参"></a>caonst形参和实参</h3><p>和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。</p>
<p><code>void fcn ( const int i)&#123;/* fcn能够读取i，但是不能向i写值*/&#125;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;<span class="comment">/* fcn能够读取i，但是不能向i写值*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">/* ...*/</span> &#125;<span class="comment">//错误:重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure>

<p>虽然函数可以重载，但是上面由于忽略了const，所以时一模一样的。</p>
<p><strong>指针或引用 形参与const</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该函数接受一个int对象的引用，然后将对象的值置为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span> <span class="params">(<span class="keyword">int</span> &amp;i)</span><span class="comment">//i是传给reset函数的对象的另一个名字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i =<span class="number">0</span>;								<span class="comment">//改变了i所引对象的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;				<span class="comment">//正确:但是cp不能改变i（参见2.4.2节，第56页)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;				<span class="comment">//正确:但是r不能改变i（参见2.4.1节，第55 页)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>; 			<span class="comment">//正确:（参见2.4.1节，第55页)</span></span><br><span class="line"><span class="keyword">int</span> *p = cp;					<span class="comment">//错误:p的类型和cp 的类型不匹配（参见2.4.2节，第56页)</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = r;					<span class="comment">//错误:r3的类型和r的类型不匹配（参见2.4.1节，第55页)</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 =<span class="number">42</span>;					<span class="comment">//错误:不能用字面值初始化一个非常量引用(参见2.3.1节，第45页)</span></span><br></pre></td></tr></table></figure>

<p>将同样的初始化规则应用到参数传递上可得如下形式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line">string : :size_type ctr =<span class="number">0</span> ;<span class="built_in">reset</span> (&amp;i) ;		<span class="comment">//调用形参类型是int*的reset函数</span></span><br><span class="line"><span class="built_in">reset</span> ( &amp;ci) ;									<span class="comment">//错误:不能用指向const int对象的指针初始化int*</span></span><br><span class="line"><span class="built_in">reset</span> (i);										<span class="comment">//调用形参类型是int&amp;的reset函数</span></span><br><span class="line"><span class="built_in">reset</span> (ci);										<span class="comment">//错误:不能把普通引用绑定到const对象ci上</span></span><br><span class="line"><span class="built_in">reset</span> (<span class="number">42</span>);										<span class="comment">//错误:不能把普通应用绑定到字面值上</span></span><br><span class="line"><span class="built_in">reset</span> (ctr) ;									<span class="comment">//错误:类型不匹配，ctr是无符号类型</span></span><br><span class="line"><span class="comment">//正确:find_char的第一个形参是对常量的引用</span></span><br><span class="line"><span class="built_in">find_char</span>( <span class="string">&quot;Hello world ! &quot;</span> , <span class="string">&#x27;o&#x27;</span>, ctr) ;</span><br></pre></td></tr></table></figure>

<p>调用reset只能使用int类型。不能使用字面值、结果为int的表达式。</p>
<p><strong>尽量使用常量引用</strong></p>
<p>则尽可能在不需要改变的形参前加const。</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式://尽管形式不同，但这三个 print函数是等价的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [] )</span></span>; <span class="comment">//可以看出来，函数的意图是作用于一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [<span class="number">10</span>] )</span></span>;<span class="comment">//这里的维度表示我们期望数组含有多少元素，实际不一定</span></span><br></pre></td></tr></table></figure>

<p>因为被转化为指针所以需要一个额外参数记录数组长度。</p>
<p><strong>使用标准库规范</strong></p>
<p>也可以使用标准库里的begin指针</p>
<h3 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a>main：处理命令行选项</h3><p>main()函数的参数可以是不为空，main()函数中的参数有两个，一个是argc表示数组中元素的个数，一个是char *argv[],表示的是指向一个字符串数组的指针，所以也可以写成char **argv。有参的main()函数可写为main(int argc,char *argv[])。</p>
<p>当实参传给main()函数时，argv的第一个元素是指向程序的名字或者是一个空字符串，接下来就是将实参传递给形参。最后一个元素是保证是0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = “test”;</span><br><span class="line">argv[<span class="number">1</span>]= ”-d”;</span><br><span class="line">argv[<span class="number">2</span>]= ”-o”;</span><br><span class="line">argv[<span class="number">3</span>]= ”ofile”;</span><br><span class="line">argv[<span class="number">4</span>]= ”data0”;</span><br><span class="line">argv[<span class="number">5</span>]= ”<span class="number">0</span>”;</span><br></pre></td></tr></table></figure>

<p>这个数组的长度是5，因为argv[]实参是从1开始，argv[0]元素是程序的名字，非用户输入。</p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p><strong>initializer_list形参</strong></p>
<p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。它的操作与vector相似，不同的时这个的元素永远时常量</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>可以使用return退出函数，也可以return 返回一个void的函数。</p>
<h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><p>该函数必须return一个与函数返回值类型相同的类型，也可以返回一个能隐式转换成返回值类型的类型。</p>
<p><strong>值是如何被返回</strong></p>
<p>返回的值是用于初始化调用的一个临时变量。</p>
<p>如果使用引用作为返回值，则返回的知识一个别名，并不会拷贝对象。</p>
<p><strong>不要返回局部对象的引用和指针</strong></p>
<p><strong>引用返回左值</strong></p>
<p>调用一个返回引用的函数得到左值，其他为右值，常量引用不能赋值。</p>
<p><strong>列表初始化返回值</strong></p>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化，否则，返回的值由函数的返回类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">// expected 和actual是string对象</span></span><br><span class="line">	<span class="keyword">if</span> (expected . <span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;f&#125;;							<span class="comment">//返回一个空vector对象</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (expected -= actual)</span><br><span class="line">		<span class="keyword">return</span> &#123; <span class="string">&quot;functionX&quot;</span> ,<span class="string">&quot;okay&quot;</span> &#125;;		<span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &#123; <span class="string">&quot;functionx&quot;</span> ,expected,actual &#125; ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主函数main的返回值</strong></p>
<p>之前介绍过，如果函数的返回类型不是void，那么它必须返回一个值。但是这条规则有个例外:我们允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。</p>
<p><strong>递归</strong></p>
<p>指针函数调用自身。main函数不能嗲用自己</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>因不能拷贝数组，所以可以返回一个数组指针</p>
<p><strong>声明返回数组指针的函数</strong></p>
<p><code>Tvpe ( * function (parameter list) )[dimensionl</code></p>
<p><code>int(* func(int i)) [10];</code><br>可以按照以下的顺序来逐层理解该声明的含义:</p>
<ul>
<li><p><code>func(int i)</code>表示调用func函数时需要一个int类型的实参。</p>
</li>
<li><p><code>(*func(int i))</code>意味着我们可以对函数调用的结果执行解引用操作。</p>
</li>
<li><p><code>(*func(int i) ) [10]</code>表示解引用func的调用将得到一个大小是10的数组。</p>
</li>
<li><p><code>int(*func(int i) ) [10]</code>表示数组中的元素是int类型。</p>
</li>
</ul>
<p><strong>使用位置返回类型</strong></p>
<p>由于这里即使复杂度提升也没有很明显的提升，所以可以使用下面的方法</p>
<p><strong>使用decltye</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] =&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>，<span class="number">7</span>,<span class="number">9</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> even [] = &#123; o ,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span> &#125; ;</span><br><span class="line"><span class="comment">//返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span> (odd) *<span class="built_in">arrPtr</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (i % <span class="number">2</span>)? &amp;odd : &amp;even;		<span class="comment">//返回一个指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何要返回指针务必加一个<code>*</code>。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。中我们定义了几个名为print 的函数，main函数不能重载。</p>
<p><strong>定义重载函数</strong></p>
<p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。在上面的代码中，虽然每个函数都只接受一个参数，但是参数的类型不同。<br>不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的。</p>
<p><strong>判断两个形参的类型是否相异</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每对声明的是同一个函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(<span class="keyword">const</span> Account &amp;acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;			<span class="comment">//省略了形参的名字</span></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(<span class="keyword">const</span> Telno&amp;)</span></span>;			<span class="comment">//Telno和Phone 的类型相同</span></span><br></pre></td></tr></table></figure>

<p><strong>重载和const形参</strong></p>
<p>因为顶层const不影响函数的对象，所以顶层const和无const形参无法区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(Phone)</span> </span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;			<span class="comment">//重复声明了Record lookup(Phone)</span></span><br></pre></td></tr></table></figure>

<p><strong>const_cast和重载</strong></p>
<p>可以使用该函数去掉或者加上const，再返回去。</p>
<p><strong>调用重载的函数</strong></p>
<p>现在我们需要掌握的是，当调用重载函数时有三种可能的结果:</p>
<ul>
<li>编译器找到一个与实参最佳匹配(best match）的函数，并生成调用该函数的代码。</li>
<li>找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配（no match）的错误信息。</li>
<li>有多于一个函数可以匹配,但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用( ambiguous call)。</li>
</ul>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>重载对作用域的一般性质并没有什么改变:如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string read o) ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> string &amp;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">double</span>)</span></span>;<span class="number">1</span>/重载print函数<span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">bool</span></span>(read= <span class="literal">false</span>; 			<span class="comment">//新作用域:隐藏了外层的read</span></span><br><span class="line">	string s = <span class="built_in">read</span> ( ); 		<span class="comment">//错误:read是一个布尔值，而非函数</span></span><br><span class="line">	<span class="comment">//不好的习惯:通常来说，在局部作用域中声明函数不是一个好的选择</span></span><br><span class="line">	<span class="keyword">void</span> print <span class="keyword">int</span>);			<span class="comment">//新作用域:隐藏了之前的print</span></span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;value: &quot;</span>);			<span class="comment">//错误:print (const string &amp;)被隐藏掉了</span></span><br><span class="line">	<span class="built_in">print</span>(ival);				<span class="comment">//正确:当前print (int)可见</span></span><br><span class="line">	<span class="built_in">print</span> (<span class="number">3.14</span>);				<span class="comment">//正确:调用print(int) ; print (double)被隐藏掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊用于语言特性"><a href="#特殊用于语言特性" class="headerlink" title="特殊用于语言特性"></a>特殊用于语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>在声明函数时可以给形参赋予一个默认值，默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string: :size_type sz;				<span class="comment">//关于typedef参见2.5.1节(第60页)</span></span><br><span class="line"><span class="function">string <span class="title">screen</span> <span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>,<span class="keyword">char</span> backgrnd = <span class="string">&#x27; &#x27;</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用默认实参调用函数</strong></p>
<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参‘靠右侧位置)，调用函数时，传入的实参是从左向右依次传入函数形参中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string window;</span><br><span class="line">window = <span class="built_in">screen</span> () ;					<span class="comment">//等价于screen (24,80,&#x27;&#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span> (<span class="number">66</span>);					<span class="comment">//等价于screen (66,80,&#x27;</span></span><br><span class="line">window= <span class="built_in">screen</span> (<span class="number">66</span>，<span class="number">256</span>);				<span class="comment">//screen (66,256,&#x27; &#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span> (<span class="number">66</span>，<span class="number">256</span>,<span class="string">&#x27;#’);			//screen (66,256,&#x27;</span>#<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>默认实参声明</strong></p>
<p>对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参,换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p>
<p><em>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</em></p>
<p><strong>默认实参初始值</strong></p>
<p>局部变量不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wd、def和ht的声明必须出现在函数之外</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span> </span>;</span><br><span class="line">string window = <span class="built_in">screen</span> ();<span class="comment">//调用 screen (ht ( ) , 80,&#x27; &#x27;)</span></span><br></pre></td></tr></table></figure>


<p>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	def =<span class="string">&#x27;*’;				//改变默认实参的值</span></span><br><span class="line"><span class="string">	sz wd=100 ;				//隐藏了外层定义的wd，但是没有改变默认值</span></span><br><span class="line"><span class="string">	window = screen ();		//调用screen(ht (), 80, &#x27;</span>*’ )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>把规模较小的操作定义成函数有很多好处，主要包括:</p>
<ul>
<li>阅读和理解shorterString函数的调用要比读懂等价的条件表达式容易得多。</li>
<li>使用函数可以确保行为的统一，每次相关操作都能保证按照同样的方式进行。</li>
<li>如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所有出现的地方再逐一修改更容易。</li>
<li>函数可以被其他应用重复利用，省去了程序员重新编写的代价。</li>
</ul>
<p>然而，使用shorterstring 函数也存在一个潜在的缺点:</p>
<ul>
<li>调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作:调用前要先保存寄存器，并在返回时恢复;可能需要拷贝实参;程序转向一个新的位置继续执行。</li>
</ul>
<p><strong>内联函数可避免函数调用的开销</strong></p>
<p>将函数指定为内联函数(inline)，通常就是将它在每个调用点上“内联地”展开。假设我们把shorterstring 函数定义成内联函数，则如下调用</p>
<p><code>cout &lt;&lt; shorterstring(s1, s2) &lt;&lt;endl;</code></p>
<p>将在编译过程中展开成类似于下面的形式<br><code>cout&lt;&lt;( (s1.size() &lt; s2.size() ? s1 : s2)&lt;&lt;endl;</code></p>
<p>从而消除了shorterString函数的运行时开销。</p>
<p>在shorterstring函数的返回类型前面加上关键字inline,这样就可以将它声明成内联函数了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内联版本:寻找两个string对象中较短的那个</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> string &amp;<span class="title">shorterstring</span><span class="params">(<span class="keyword">const</span> string &amp;s1,<span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span> () &lt;= s2.<span class="built_in">size</span> () ? sl : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联说明知识向编译器发生的一个请求，编译器可以选择忽略。</p>
<p><strong>constexpr函数</strong></p>
<p>是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = <span class="built_in">new_sz</span>();					<span class="comment">//正确:foo是一个常量表达式</span></span><br></pre></td></tr></table></figure>

<p>执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p>
<p>我们允许constexpr函数的返回值并非一个常量:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果arg是常量表达式，则scale (arg)也是常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">new_sz</span> () * cnt; &#125;</span><br></pre></td></tr></table></figure>

<p>当scale的实参是常量表达式时，它的返回值也是常量表达式;反之则不然:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];					<span class="comment">//正确:scale (2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;							<span class="comment">//i不是常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a2</span><span class="params">(scale(i) ];					<span class="comment">//错误:scale(i)不是常量表达式</span></span></span></span><br></pre></td></tr></table></figure>

<p>如果非常亮表达式调用scale函数，当scale函数用在需要常量表达式时，会报错。</p>
<p><label style="color:red">constexpr函数不一定返回常量表达式</label></p>
<h4 id="与const的比较"><a href="#与const的比较" class="headerlink" title="与const的比较"></a>与const的比较</h4><p>const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。</p>
<p>constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。</p>
<p><strong>把内联函数和constexpr函数放在头文件内</strong></p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能:assert和 NDEBUG。</p>
<p><strong>assert预处理宏</strong></p>
<p><code>assert ( expr);</code></p>
<p>首先对expr求值，如果表达式为假（即 0)，assert输出信息并终止程序的执行。如果表达式为真（即非0)，assert什么也不做。头文件为cassert。</p>
<p>assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时,程序可以包含一条如下所示的语句:<br><code>assert(word . size() &gt; threshold);</code></p>
<p><strong>NDEBUG预处理变量</strong></p>
<p>assert 的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG,则assert什么也不做。默认状态下没有定义NDEBUG,此时assert将执行运行时检查。</p>
<p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。</p>
<p>此外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码;如果定义了NDEBUG，这些代码将被忽略掉:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">	<span class="comment">// __func__是编译器定义的一个局部静态变量，用于存放函数的名字</span></span><br><span class="line">	cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: array size is &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>调试函数名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>_ _FILE_ _</code></td>
<td>存放文件名的字符串字面值</td>
</tr>
<tr>
<td><code>_ _func_ _</code></td>
<td>存放调试函数的名字</td>
</tr>
<tr>
<td><code>_ _LINE_ _</code></td>
<td>存放当前行号的整型字面值</td>
</tr>
<tr>
<td><code>_ _TIME_ _</code></td>
<td>存放文件编译时间的字符串字面值</td>
</tr>
<tr>
<td><code>_ _DATE_ _</code></td>
<td>存放文件编译日期的字符串字面值</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (word.<span class="built_in">size</span> () &lt; threshold)</span><br><span class="line">	cerr &lt;&lt;<span class="string">&quot;Error: &quot;</span>&lt;&lt;__F工LE_-</span><br><span class="line">		&lt;&lt;<span class="string">&quot; : in function &quot;</span> &lt;&lt; __func__</span><br><span class="line">		&lt;&lt; <span class="string">&quot; at line &quot;</span> &lt;&lt;__LINE__&lt;&lt;endl</span><br><span class="line">		&lt;&lt;<span class="string">&quot; compiled on &quot;</span> &lt;&lt; __DATE__</span><br><span class="line">		&lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt;__TIME__&lt;&lt;endl</span><br><span class="line">		&lt;&lt;<span class="string">&quot;word read was \&quot;&quot;</span>&lt;&lt; word</span><br><span class="line">		&lt;&lt;<span class="string">&quot;\&quot;: Length too short&quot;</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>则可得到下面的错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Error : wdebug.cc : in function main at line <span class="number">27</span></span><br><span class="line">			compiled on Jul <span class="number">11</span> <span class="number">2012</span> at <span class="number">20</span>:<span class="number">50</span>:<span class="number">03</span></span><br><span class="line">			word read was <span class="string">&quot;foo&quot;</span> : Length too <span class="keyword">short</span></span><br></pre></td></tr></table></figure>

<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span> = <span class="number">3.14</span>)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">5.6</span>);								<span class="comment">//调用void f(double,double)</span></span><br></pre></td></tr></table></figure>

<p><strong>确定候选函数和可行函数</strong></p>
<ul>
<li>匹配第一步调用对应的重载函数集，集合中函数称为<strong>候选函数</strong>。具有两个特征，1：函数名相同。2：声明在调用点可见。上面的例子中，四个均为候选函数。</li>
<li>第二部考察实参，从候选函数选出能被这组实参调用的函数，成为可行函数，也有两个特征，1：形参，实参数量相等，2：类型对应相等，或者能够互相转化。</li>
</ul>
<p>则这里只有函数2和4可以调用，但如果找不到可行函数，会报错。</p>
<p><label style="color:red">如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。</label></p>
<p><strong>寻找最佳匹配</strong></p>
<p>基本思想：实参类型与形参类型越接近，它们匹配得越好。所以例子中硬调用双double的函数。</p>
<p><strong>多个形参的函数匹配</strong></p>
<p>若调用为<code>(42，2.56)</code>，则第一个参数与f(int,int)匹配，第二参数与f(double, double)匹配。这样会报错，因为二义性调用。调用重载避免强制类型转换。</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><ol>
<li><p>精确匹配，包括以下情况:</p>
<ul>
<li><p>·实参类型和形参类型相同。</p>
</li>
<li><p>实参从数组类型或函数类型转换成对应的指针类型。</p>
</li>
<li><p>向实参添加顶层const或者从实参中删除顶层const。</p>
</li>
</ul>
</li>
<li><p>通过const转换实现的匹配。</p>
</li>
<li><p> 通过类型提升实现的匹配。</p>
</li>
<li><p>通过算术类型转换（参见4.11.1节，第142页)或指针转换实现的匹配。</p>
</li>
<li><p>通过类类型转换实现的匹配（参见14.9节，第514页，将详细介绍这种转换)。</p>
</li>
</ol>
<p><strong>需要类型提升和算术类型转换的匹配</strong></p>
<p>分析函数调用前，我们应该知道小整型一般都会提升到int类型或更大的整数类型。</p>
<p>假设有两个函数，一个接受int、另一个接受short，则只有当调用提供的是short类型的值时才会选择short版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int类型;此时使用short版本反而会导致类型转换，如char。</p>
<p>所有转换级别一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span> <span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span> <span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">3.14</span>);									<span class="comment">//错误:二义性调用</span></span><br></pre></td></tr></table></figure>

<p><strong>函数匹配和const实参</strong></p>
<p>如果重载函数的区别在于它们的引用类型的形参是否引用了const,或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。指针类型也同样如此</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(Account&amp;)</span></span>;				<span class="comment">//函数的参数是Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span> <span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;			<span class="comment">//函数的参数是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"><span class="built_in">lookup</span> (a) ;							<span class="comment">//调用lookup (const Account&amp;)</span></span><br><span class="line"><span class="built_in">lookup</span>(b);								<span class="comment">//调用lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span> <span class="params">(<span class="keyword">const</span> string &amp;,<span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">//该函数的类型是bool (const string&amp;,const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替</span></span><br><span class="line"><span class="comment">//换函数名即可:</span></span><br><span class="line"><span class="comment">//pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型</span></span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf) (<span class="keyword">const</span> string &amp;,<span class="keyword">const</span> string &amp;);<span class="comment">//未初始化</span></span><br></pre></td></tr></table></figure>

<p>*pf两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数:</p>
<p><strong>使用函数指针</strong></p>
<p>初始化与使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pf = <span class="literal">nullptr</span>;								<span class="comment">//不指向任何函数</span></span><br><span class="line">pf = lengthCompare;							<span class="comment">//pf指向名为lengthCompare的函数</span></span><br><span class="line">pf = &amp;lengthCompare;						<span class="comment">//等价的赋值语句:取地址符是可选的</span></span><br><span class="line"><span class="comment">//此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针:</span></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span> ( <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>) ;			<span class="comment">//调用lengthCompare函数</span></span><br><span class="line"><span class="keyword">bool</span> b2 =(*pf) ( <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span> ) ;		<span class="comment">//一个等价的调用</span></span><br><span class="line"><span class="keyword">bool</span> b3 = <span class="built_in">lengthCompare</span> (<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);<span class="comment">//另一个等价的调用</span></span><br></pre></td></tr></table></figure>

<p>函数指针不存在转换规则，必须精确匹配，否则报错。</p>
<p><strong>函数指针形参</strong></p>
<p>函数形参可以时指向函数的形参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个形参是函数类型，它会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span> <span class="params">(<span class="keyword">const</span> string &amp;s1,<span class="keyword">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">bool</span> pf (<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明:显式地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1,<span class="keyword">const</span> string &amp;s2，</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span> </span>;</span><br></pre></td></tr></table></figure>

<p>使用函数也会自动转换成指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动将函数lengthCompare转换成指向该函数的指针</span></span><br><span class="line"><span class="built_in">useBigger</span> (s1, s2,lengthCompare);</span><br></pre></td></tr></table></figure>

<p>简化方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span> <span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span> <span class="params">(lengthCompare)</span> Func2</span>;					<span class="comment">//等价的类型</span></span><br><span class="line"><span class="comment">// FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span> <span class="params">(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span> <span class="params">(lengthCompare)</span> *FuncP2</span>;				<span class="comment">//等价的类型</span></span><br></pre></td></tr></table></figure>

<p>注意这里typedef的用法，它这里定义了Func表示一类返回值为bool，形参为（/**/）的函数。</p>
<p><strong>返回指向函数的指针</strong></p>
<p>起类型别名将函数返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">int</span>* , <span class="keyword">int</span>);					<span class="comment">// F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in"><span class="keyword">int</span></span> (* ) (<span class="keyword">int</span>*, <span class="keyword">int</span>) ;			<span class="comment">//PF是指针类型</span></span><br></pre></td></tr></table></figure>

<p>函数类型需要强制进行转化为函数指针类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;						<span class="comment">//正确:PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="built_in">Ff1</span> (<span class="keyword">int</span>) ;						<span class="comment">//错误:F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span> <span class="params">(<span class="keyword">int</span>)</span> </span>;					<span class="comment">//正确:显式地指定返回类型是指向函数的指针</span></span><br></pre></td></tr></table></figure>

<p>也可直接声明，但要麻烦得多：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">f1</span> (<span class="keyword">int</span>) ) (<span class="keyword">int</span>*, <span class="keyword">int</span>) ;</span><br><span class="line"><span class="comment">//使用尾置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span> <span class="params">(<span class="keyword">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span> <span class="params">(<span class="keyword">int</span>* , <span class="keyword">int</span>)</span> </span>;</span><br></pre></td></tr></table></figure>

<p><strong>auto和decltype</strong></p>
<p>decltype(函数名)，可以返回对应的函数类型，加<code>*</code>可以转化为函数指针。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第七章</title>
    <url>/2021/12/10/%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<p>​        <strong>写在前面</strong>：由于我的失误操作，导致第七章被第六章的内容覆盖，怀着悲痛的心情准备写第二遍，不过也应该可以比第一遍写的更好，在此提醒大家，不要随意切换文件并点击系统弹出来的保存，并即使做好备份。这是一个十分悲痛的教训，望大家注意。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是数据<strong>抽象（data abstraction）</strong>和<strong>封装（encapsulation)<strong>。数据抽象是一种依赖于</strong>接口(interface）</strong>和**实现(implementation)**分离的编程（以及设计〉技术。类的接口包括用户所能执行的操作;类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>sales_data的接口应该包含以下操作:</p>
<ul>
<li>一个isbn 成员函数，用于返回对象的ISBN编号</li>
<li>一个combine成员函数，用于将一个sales_data对象加到另一个对象上</li>
<li>一个名为add 的函数，执行两个sales data对象的加法</li>
<li>一个read函数，将数据从istream读入到sales_data对象中。</li>
<li>一个print函数，将sales data对象的值输出到ostream</li>
</ul>
<h4 id="使用改进的Sales-data类"><a href="#使用改进的Sales-data类" class="headerlink" title="使用改进的Sales_data类"></a>使用改进的Sales_data类</h4><p>在考虑如何实现我们的类之前，首先来看看应该如何使用上面这些接口函数。举个例子，我们使用这些函数编写1.6节（第21页）书店程序的另外一个版本，其中不再使用sales_item对象，而是使用sales_data对象:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sales_data total ;								<span class="comment">//保存当前求和结果的变量</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span> (cin, total))&#123;							<span class="comment">//读入第一笔交易</span></span><br><span class="line">	sales_data trans;							<span class="comment">//保存下一条交易数据的变量</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">read</span> (cin,trans))&#123;					<span class="comment">//读入剩余的交易</span></span><br><span class="line">		<span class="keyword">if</span> (total .<span class="built_in">isbn</span> ( ) == trans.<span class="built_in">isbn</span> ( ))	<span class="comment">//检查 isbn</span></span><br><span class="line">			total.<span class="built_in">combine</span> (trans);				<span class="comment">//更新变量total当前的值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span> (cout, total) &lt;&lt; endl;		<span class="comment">//输出结果</span></span><br><span class="line">            total = trans;						<span class="comment">//处理下一本书</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span> (cout, total) &lt;&lt; endl ;			<span class="comment">//输出最后一条交易</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;											<span class="comment">//没有输入任何信息</span></span><br><span class="line">	cerr &lt;&lt;<span class="string">&quot;No data?! &quot;</span> &lt;&lt; endl ;				<span class="comment">//通知用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义改进的Sales-data类"><a href="#定义改进的Sales-data类" class="headerlink" title="定义改进的Sales_data类"></a>定义改进的Sales_data类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line">	<span class="comment">//新成员:关于sales_data对象的操作</span></span><br><span class="line">	std: :<span class="function">string <span class="title">isbn</span> <span class="params">( )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data&amp; <span class="title">combine</span> <span class="params">(<span class="keyword">const</span> sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">avg_price</span> <span class="params">( )</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">//数据成员和2.6.1节（第64页）相比没有改变</span></span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sales_data的非成员接口函数</span></span><br><span class="line"><span class="function">sales_data <span class="title">add</span> <span class="params">(<span class="keyword">const</span> Sales_data&amp;,<span class="keyword">const</span> Sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std: :ostream&amp;,<span class="keyword">const</span> sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std: :istream&amp;,Sales_data&amp;)</span> </span>;</span><br></pre></td></tr></table></figure>

<h4 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h4><p>所有成员必须声明在类内部，但是成员函数体可以在类外定义。</p>
<p>在isbn函数中是如何bookNo所依赖的对象的呢？</p>
<h4 id="引入this"><a href="#引入this" class="headerlink" title="引入this"></a>引入this</h4><p>调用为：<code>total .isbn ()</code>这样的调用实际上是隐式地指向调用该函数的对象成员，这里返回的就是total.bookNo。</p>
<p>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this，如</p>
<p><code>total .isbn ()</code>则编译器负责把total的地址传递给isbn的隐式形参this，可以等价地认为编译器将该调用重写成了如下的形式:<code>//伪代码，用于说明调用成员函数的实际执行过程Sales_data : :isbn (&amp;total)</code></p>
<h4 id="引入const成员函数"><a href="#引入const成员函数" class="headerlink" title="引入const成员函数"></a>引入const成员函数</h4><p>const修饰的成员函数，实际修饰该成员函数隐藏的this指针，表明在该成员函数中不能对类的任何成员进行修改。</p>
<p>且const对象只能调用const函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Display1</span><span class="params">()</span><span class="keyword">const</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Date d1;</span><br><span class="line">	d1.<span class="built_in">Display1</span>();<span class="comment">//d1为const成员，不可修改</span></span><br><span class="line">	Date d2;</span><br><span class="line">	d2.<span class="built_in">Display</span>();<span class="comment">//d1没有要求，可改可不改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>类本身就是一个作用域，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<p>因为编译器是首先编译成员的声明，其次才是成员函数体。</p>
<h4 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h4><p>我们可以在类的外部定义成员函数，这样做的作用可以保持类内代码看起来更加清晰简洁。</p>
<p>但在外部定义必须在类内提前声明，且与类外函数保持一致。不同之处在于需要加上类名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> sales_data: :<span class="built_in">avg_price</span> () <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (units_sold)</span><br><span class="line">		<span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义返回this对象的函数"><a href="#定义返回this对象的函数" class="headerlink" title="定义返回this对象的函数"></a>定义返回this对象的函数</h4><p>我们可以把自己这个对象返回，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data&amp; Sales_data : :<span class="built_in">combine</span> (<span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">	units_sold += rhs.units_sold; <span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数可以把自己一些数据和参数的数据相加，然后以引用的形式返回。</p>
<h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><p>类的作者常常需要定义一些辅助函数，比如 add、read和 print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。</p>
<h4 id="类中的输入与输出"><a href="#类中的输入与输出" class="headerlink" title="类中的输入与输出"></a>类中的输入与输出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入的交易信息包括ISBN、售出总数和售出价格</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_ data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">	is &gt;&gt; item. bookNo &gt;&gt; item.units_ sold &gt;&gt; price;</span><br><span class="line">	item. revenue = price * item.units_ sold;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os，<span class="keyword">const</span> Sales_ data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_ sold &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">		&lt;&lt; item.revenue &lt;&lt;” ”&lt;&lt; item.<span class="function">avg_ <span class="title">price</span><span class="params">()</span> </span>;</span><br><span class="line">	<span class="keyword">return</span> OS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read函数由于将流中数据读到给定对象，print函数将给定对象打印到流中。</p>
<p>由于与流数据有交互，所以需要将IO类的引用作为参数。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来，控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>当没有定义任何构造函数时，创建对象则会执行合成的默认的构造函数：</p>
<p>●如果存在类内的初始值(参见2.6.1节，第64页)，用它来初始化成员。<br>●否则，默认初始化(参见2.2.1节，第40页)该成员。</p>
<p>但合成的默认构造知识和简单的类，复杂的类容易出错，所以尽量自己去定义默认构造函数。</p>
<h4 id="定义的构造函数"><a href="#定义的构造函数" class="headerlink" title="定义的构造函数"></a>定义的构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_</span> <span class="title">data</span> &#123;</span></span><br><span class="line">	<span class="comment">//新增的构造函数</span></span><br><span class="line">	<span class="function">Sales_ <span class="title">data</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="function">Sales_ <span class="title">data</span><span class="params">(<span class="keyword">const</span> std: :string &amp;s)</span> : bookNo(s) &#123;</span>&#125;</span><br><span class="line">	<span class="function">Sales_ <span class="title">data</span> <span class="params">(<span class="keyword">const</span> std: :string &amp;s，<span class="keyword">unsigned</span> n, <span class="keyword">double</span> p)</span> :</span></span><br><span class="line"><span class="function">				bookNo(s)，units_ sold(n), revenue (p*n) &#123;</span> &#125;</span><br><span class="line">	<span class="function">Sales_ <span class="title">data</span><span class="params">(std: :istream &amp;)</span> </span>;</span><br><span class="line">	<span class="comment">//之前已有的其他成员</span></span><br><span class="line">	std: :<span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">	<span class="function">Sales_ data&amp; <span class="title">combine</span> <span class="params">(<span class="keyword">const</span> Sales_ data&amp;)</span> </span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> avg_ <span class="title">price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	std: :string bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_ sold = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p><code>Sales_ data() = default;</code>这是一个默认的构造函数，他的作用和合成的默认构造函数一样。</p>
<p><em>上面的默认构造函数之所以对Sales data有效，是因为我们为内置类型的数据成员提供了初始值。如果你的编译器不支持类内初始值，那么你的默认构造函数就应该使用构造函数初始值列表(马上就会介绍)来初始化类的每个成员。</em></p>
<h4 id="构造函数初始值"><a href="#构造函数初始值" class="headerlink" title="构造函数初始值"></a>构造函数初始值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_ <span class="title">data</span><span class="params">(<span class="keyword">const</span> std: :string &amp;s)</span> : bookNo(s) &#123;</span> &#125;</span><br><span class="line"><span class="function">Sales_ <span class="title">data</span> <span class="params">(<span class="keyword">const</span> std: :string &amp;s，<span class="keyword">unsigned</span> n, <span class="keyword">double</span> p)</span> :</span></span><br><span class="line"><span class="function">			bookNo(s)，units_ sold(n), revenue (p*n) &#123;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>使用初始值列表为一个或几个数据成员赋值，且构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>
<h4 id="在类外定义构造函数"><a href="#在类外定义构造函数" class="headerlink" title="在类外定义构造函数"></a>在类外定义构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_ data::Sales_ <span class="title">data</span><span class="params">(std::istream &amp;is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(is，*<span class="keyword">this</span>); <span class="comment">// read 函数的作用是从is中读取一条交易信息然后</span></span><br><span class="line">					 <span class="comment">//存入this对象中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先它没有返回类型，且必须指定类名，由于这里的初始值列表为空，所以初始化任务交给函数体，没没有被构造函数赋值的成员将执行默认初始化。如string为空string，int为0。</p>
<p>函数read的第二个形参为该对象的引用。</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>一般来说编译器会默认的合成拷贝、赋值和析构，例如赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">total = trans; <span class="comment">//处理下一本书的信息.</span></span><br><span class="line"><span class="comment">// 它的行为与下面的代码相同</span></span><br><span class="line"><span class="comment">// Sales_ data的默认赋值操作等价于:</span></span><br><span class="line">total .bookNo = trans . bookNo;</span><br><span class="line">total.units_ sold = trans.units sold;</span><br><span class="line">total. revenue = trans. revenue;</span><br></pre></td></tr></table></figure>

<h4 id="不可依赖合成版本"><a href="#不可依赖合成版本" class="headerlink" title="不可依赖合成版本"></a>不可依赖合成版本</h4><p>编译器默认生成的函数常常会出现一些问题，所以后面会了解到如何自定义这些函数。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>可以使用访问说明符加强类的封装性：</p>
<ul>
<li><p>定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</p>
</li>
<li><p>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了( 即隐藏了)类的实现细节。</p>
</li>
</ul>
<p>说明符数量不限，且作用域到下一个访问说明符为止。出于统一编程风格的考虑，当我们希望定义的类的所有成员是public的时，使用struct； 反之，如果希望成员是private的，使用class。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>若要想某些函数可以访问类内私有成员，我们可以将他声明为友元，只需要增加一条以friend关键字开始的函数声明语句即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="comment">//为sales_data的非成员函数所做的友元声明</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> sales_data <span class="title">add</span> <span class="params">(<span class="keyword">const</span> sales_data&amp;,<span class="keyword">const</span> sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">friend</span> std: :<span class="function">istream &amp;<span class="title">read</span><span class="params">(std: :istream&amp;，sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">friend</span> std: :<span class="function">ostream &amp;<span class="title">print</span><span class="params">(std: :ostream&amp;,<span class="keyword">const</span> sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="comment">//其他成员及访问说明符与之前一致</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">sales_data</span> (<span class="keyword">const</span> std: :string &amp;s, <span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">	<span class="built_in">bookNo</span> (s) , <span class="built_in">units_sold</span>(n) , <span class="built_in">revenue</span> (p*n)&#123; &#125;</span><br><span class="line">	<span class="built_in">sales_data</span> (<span class="keyword">const</span> std: :string &amp;s): <span class="built_in">bookNo</span>(s)&#123; &#125;</span><br><span class="line">	<span class="built_in">sales_data</span>(std: :istream&amp;) ;</span><br><span class="line">	std: :<span class="function">string <span class="title">isbn</span> <span class="params">( )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">	<span class="function">sales_data &amp;<span class="title">combine</span> <span class="params">(<span class="keyword">const</span> sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std: :string bookNo ;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="comment">// sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">sales_data <span class="title">add</span> <span class="params">(<span class="keyword">const</span> sales_data&amp;, <span class="keyword">const</span> sales_data&amp;)</span></span>;</span><br><span class="line">std: :<span class="function">istream &amp;<span class="title">read</span><span class="params">(std: :istream&amp;, sales_data&amp; )</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std: :ostream&amp;,<span class="keyword">const</span> Sales_data&amp; )</span></span>;</span><br></pre></td></tr></table></figure>

<p>友元必须在类内声明，最好写在开头和劫为的尾置。</p>
<h4 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h4><ul>
<li>确保用户代码不会无意间破坏封装对象的状态。</li>
<li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li>
</ul>
<h4 id="友元的声明"><a href="#友元的声明" class="headerlink" title="友元的声明"></a>友元的声明</h4><p>友元声明相当于给这个函数开通了权限，函数还是需要声明和定义。</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std: :string : :size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pos cursor = <span class="number">0</span>;</span><br><span class="line">	pos height = <span class="number">0</span>, width = <span class="number">0</span> ;std: : string contents ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个窗口类，其中使用typedef来重命名，其作用等同于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//使用类型别名等价地声明一个类型名字</span></span><br><span class="line">	<span class="keyword">using</span> pos = std::string::size_type;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Screen类成员函数"><a href="#Screen类成员函数" class="headerlink" title="Screen类成员函数"></a>Screen类成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">	<span class="built_in">Screen</span>() = <span class="keyword">default</span>; <span class="comment">//因为Screen有另一个构造函数，</span></span><br><span class="line">						<span class="comment">//所以本函数是必需的</span></span><br><span class="line">	<span class="comment">//cursor被其类内初始值初始化为0</span></span><br><span class="line">	<span class="built_in">screen</span>(pos ht, pos wd,<span class="keyword">char</span> c) : <span class="built_in">height</span> (ht), <span class="built_in">width</span> (wd)，<span class="built_in">contents</span> (ht * wd, c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get</span> <span class="params">()</span> <span class="keyword">const</span>							<span class="comment">//读取光标处的字符</span></span></span><br><span class="line"><span class="function">		</span>&#123; <span class="keyword">return</span> contents [cursor] ; &#125;			<span class="comment">//隐式内联</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span> <span class="params">(pos ht, pos wd)</span><span class="keyword">const</span> </span>;		<span class="comment">//显式内联</span></span><br><span class="line">	<span class="function">screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;					<span class="comment">//能在之后被设为内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pos cursor = <span class="number">0</span>;</span><br><span class="line">	pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">	std::string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里第二个构造函数只接受了三个参数，所以另一个成员采用类内初始值的方式初始化。</p>
<h4 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h4><p>类内的函数是固定为内联函数的，当类外函数需要作为类内成员时，可以加上inline声明成内联函数。</p>
<p>其可以在类内声明（不推荐，因为类内函数就是内联函数），也可以在类外声明，但最好只在类外声明。</p>
<h4 id="重载成员函数"><a href="#重载成员函数" class="headerlink" title="重载成员函数"></a>重载成员函数</h4><p>成员函数与非成员函数都可以被重载，使用时根据参数数量来决定用哪种函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">screen myscreen;</span><br><span class="line"><span class="keyword">char</span> ch = myscreen. <span class="built_in">get</span> ( ) ;				<span class="comment">//调用screen : :get ()</span></span><br><span class="line">ch = myscreen.<span class="built_in">get</span> (<span class="number">0</span> , <span class="number">0</span>);					<span class="comment">//调用screen: :get (pos, pos)</span></span><br></pre></td></tr></table></figure>

<h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p>如何希望一个变量无论什么情况都可以被改变。可以在变量声明时加入mutable关键字。即使他是const对象的成员，或通过const函数赋值，都可以被改变。</p>
<h4 id="类数据成员初始值"><a href="#类数据成员初始值" class="headerlink" title="类数据成员初始值"></a>类数据成员初始值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">window_mgr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//这个window _mgr追踪的Screen</span></span><br><span class="line">	<span class="comment">//默认情况下，一个window_mgr包含一个标准尺寸的空白Screen</span></span><br><span class="line">	std::vector&lt;screen&gt; screens&#123; <span class="built_in">screen</span> (<span class="number">24</span>，<span class="number">80</span>, <span class="string">&#x27; &#x27;</span> )&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当初始化类类型成员，可以使用列表初始化的方式，类内初始值必须以=或者{}表示。</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Screen &amp;<span class="title">set</span> <span class="params">(<span class="keyword">char</span>)</span> </span>;</span><br><span class="line">	<span class="function">Screen &amp;<span class="title">set</span> <span class="params">(pos, pos, <span class="keyword">char</span>)</span> </span>;</span><br><span class="line">	<span class="comment">//其他成员和之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span> <span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	contents [cursor] = C;			<span class="comment">//设置当前光标所在位置的新值</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;					<span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	contents[r*width + col] = ch;	<span class="comment">//设置给定位置的新值</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;					<span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set函数返回值是调用set的对象的引用，可以作为左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把光标移动到一个指定的位置，然后设置该位置的字符值</span></span><br><span class="line">myscreen.<span class="built_in">move</span> ( <span class="number">4</span>,<span class="number">0</span> ) .<span class="built_in">set</span> (<span class="string">&#x27;#’);</span></span><br><span class="line"><span class="string">//上述语句等价于</span></span><br><span class="line"><span class="string">myScreen.move ( 4,0);</span></span><br><span class="line"><span class="string">myscreen.set(&#x27;</span>#’);</span><br></pre></td></tr></table></figure>

<p>若返回值不是引用，则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果move返回Screen而非screen&amp;</span></span><br><span class="line">screen temp = myscreen . <span class="built_in">move</span> ( <span class="number">4</span> ,o) ;			<span class="comment">//对返回值进行烤贝</span></span><br><span class="line">temp.<span class="built_in">set</span> (<span class="string">&#x27;#’);									//不会改变myscreen的 contents</span></span><br></pre></td></tr></table></figure>

<h4 id="const成员函数返回-this"><a href="#const成员函数返回-this" class="headerlink" title="const成员函数返回*this"></a>const成员函数返回*this</h4><p>若为前面的类定义一个display操作，因为打印不需要改变类中的成员，所以令display为一个const成员，所以*this是一个const对象。返回值是一个const对象的引用，所以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">screen myScreen;</span><br><span class="line"><span class="comment">//如果display返回常量引用，则调用set将引发错误</span></span><br><span class="line">myScreen.<span class="built_in">display</span> (cout).<span class="built_in">set</span> (<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h4><p>一个函数可以重载为const和非const，分别用在常量对象，和非常量对象的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//根据对象是否是const重载了display函数</span></span><br><span class="line">	<span class="function">screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span>&#123; <span class="built_in">do_display</span>(os) ; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="keyword">const</span></span>&#123; <span class="built_in">do_display</span> (os) ; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//该函数负责显示Screen的内容</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(std: :ostream &amp;os)</span><span class="keyword">const</span> </span>&#123;os &lt;c contents; &#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中do_display是一个公共代码，他的好处为：</p>
<ul>
<li>一个基本的愿望是避免在多处使用同样的代码。</li>
<li>我们预期随着类的规模发展，display函数有可能变得更加复杂。</li>
<li>我们很可能在开发过程中给do_display函数添加某些调试信息，而这些信息将在代码的最终产品版本中去掉。显然,只在 do_display一处添加或删除这些信息要更容易一些。</li>
<li>这个额外的函数调用不会增加任何开销。因为我们在类内部定义了do_display,所以它隐式地被声明成内联函数。</li>
</ul>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每一个类都是唯一的，即使他们的成员完全一样，所以他们也不可以互相赋值。</p>
<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>类的声明可以只声明不定义，也被称为<strong>向前声明</strong>，在未定义前他是一个<strong>不完全类型</strong>，不完全类型只能在非常有限的情景下使用:</p>
<ul>
<li>可以定义指向这种类型的指针或引用，</li>
<li>可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</li>
</ul>
<p><em>创建它的对象之前他必须被定义过！</em></p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><h4 id="类之间的友元"><a href="#类之间的友元" class="headerlink" title="类之间的友元"></a>类之间的友元</h4><p>如果想在A类的成员函数内可以控制另一个B类的成员，可以将A类在B类中声明称友元，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">    <span class="comment">//其他内容...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则A类的所有成员函数都可以访问B类的私有成员。</p>
<p>注意：友元关系没有传递性，若A中声明了友元C类，C只可以访问A，而不能访问B。</p>
<h4 id="成员函数作为友元"><a href="#成员函数作为友元" class="headerlink" title="成员函数作为友元"></a>成员函数作为友元</h4><p>若不需要将整个类作为友元，则可以只为一个函数声明友元，且必须明确属于哪个类。且应注意一定的顺序：</p>
<ul>
<li>定义A类，并声明其中的需要改变B类成员的函数（简称C函数吧），但不要定义。</li>
<li>定义B类，声明友元函数C。</li>
<li>最后定义C函数。</li>
</ul>
<h4 id="函数重载和友元"><a href="#函数重载和友元" class="headerlink" title="函数重载和友元"></a>函数重载和友元</h4><p>若一个函数名存在多个重载，则友元函数需要声明多个，且他们是一一对应的。</p>
<h4 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h4><p>友元声明不是必须在类或者函数之后，但无论如何一定要在类外声明一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="comment">/*友元函数可以定义在类的内部*/</span>&#125;</span><br><span class="line">	<span class="built_in">X</span>()&#123; <span class="built_in">f</span>(); &#125;<span class="comment">//错误:f还没有被声明</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> x: :<span class="built_in">g</span>() &#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;		<span class="comment">//错误:f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>;							<span class="comment">//声明那个定义在中的函数</span></span><br><span class="line"><span class="keyword">void</span> x : :<span class="built_in">h</span>() &#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;		<span class="comment">//正确:现在f的声明在作用域中了</span></span><br></pre></td></tr></table></figure>

<p>根本还是因为友元只是开通了某个人进入这个地方的权限，而这个人需要被承认是一个人。才能使用该权限。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>类有自己的作用域，在类外必须由对象、引用或指针使用成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">screen::pos ht = <span class="number">24</span>, wd = <span class="number">80</span> ;			<span class="comment">//使用screen定义的pos类型</span></span><br><span class="line"><span class="function">screen <span class="title">scr</span> <span class="params">(ht, wd, <span class="string">&#x27; &#x27;</span>)</span> </span>;</span><br><span class="line">Screen *p = &amp;scr;</span><br><span class="line"><span class="keyword">char</span> c = scr.<span class="built_in">get</span> () ;						<span class="comment">//访问scr对象的get成员</span></span><br><span class="line">c = p-&gt;<span class="built_in">get</span> () ;								<span class="comment">//访问p所指对象的get成员</span></span><br></pre></td></tr></table></figure>

<p>类外的成员函数，因为在类外，所以并不知道类内的成员，所以必须加上类名，包括返回值如果是类内的成员也必须加上类名。</p>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>名字查找的大致过程为：</p>
<ul>
<li>首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到，继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明，则程序报错。</li>
</ul>
<p>对于定义在类内部的成员函数：</p>
<ul>
<li>首先，编译成员的声明。</li>
<li>直到类全部可见后才编译函数体。</li>
</ul>
<h4 id="类成员声明的名字查找"><a href="#类成员声明的名字查找" class="headerlink" title="类成员声明的名字查找"></a>类成员声明的名字查找</h4><p>声明过程中使用的名字必须在使用前确保可见，如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在类外中继续查找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Money <span class="title">balance</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;<span class="comment">//这里的返回值为类外定义的double,</span></span><br><span class="line">    			<span class="comment">//bal在函数体内，所以整个类可见后才处理，所以这里返回的是类内的bal。</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Money bal;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="类型名要特殊处理"><a href="#类型名要特殊处理" class="headerlink" title="类型名要特殊处理"></a>类型名要特殊处理</h4><p>类内可以重新为一个类型定义名字，但如果已经使用过了，就不能在定义它了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Money <span class="title">balance</span><span class="params">( )</span> </span>&#123; <span class="keyword">return</span> bal; &#125;		<span class="comment">//使用外层作用域的Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">double</span> Money;					<span class="comment">//错误:不能重新定义Money</span></span><br><span class="line">	Money bal;								<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数使用名字解析</p>
<ul>
<li>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。</li>
<li>如果在成员函数内没有找到,则在类内继续查找,这时类的所有成员都可以被考虑。</li>
<li>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。</li>
</ul>
<p>如果成员函数参数名字与类成员名字冲突，那么使用类内的成员最好写成类名::的形式，更加清楚。当然，更好的办法是另起一个名字。</p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>定义变量时最好立即对其进行初始化，如没有初始化，则会执行默认初始化。</p>
<h4 id="初始值有时必不可少"><a href="#初始值有时必不可少" class="headerlink" title="初始值有时必不可少"></a>初始值有时必不可少</h4><p>有时遇到无法默认初始化的类型、常量或者引用，则必须添加初始值。</p>
<h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><p>初始化顺序不是按参数的顺序，而是按照在类内声明的顺序。</p>
<p><em>建议：构造函数初始化顺序与成员声明最好一致，且不用成员去初始化成员</em></p>
<h4 id="默认实参和构造函数"><a href="#默认实参和构造函数" class="headerlink" title="默认实参和构造函数"></a>默认实参和构造函数</h4><p>如果一个构造函数为所有参数都提供了默认实参,则它实际上也定义了默认构造函数。</p>
<p>如果你希望用户给出一个非0实参的同时给处其他的实参，则建议不要给他形参添加默认值。例如图书管理程序，用户提供一本书的名字时，你需要他同时提供书的价格、序列号等，就不应该给形参设置默认值，这样用户就必须输入图书全部信息。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">	<span class="built_in">Sales_data</span>(std::string s, <span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price):</span><br><span class="line">			<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span> (cnt*price)&#123; &#125;</span><br><span class="line">	<span class="comment">//其余构造函数全都委托给另一个构造函数</span></span><br><span class="line">	<span class="built_in">sales_data</span>() : <span class="built_in">sales_data</span> (<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">sales_data</span> (std::string s) : <span class="built_in">sales_data</span>(s， <span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">sales_data</span> (std::istream &amp;is) : <span class="built_in">sales_data</span>()&#123; <span class="built_in">read</span> (is,*<span class="keyword">this</span>) ; &#125;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它也有成员初始值列表和一个函数体，参数列表须与委托的构造函数匹配。最后一个构造函数委托的是默认构造函数，默认构造执行后，执行read（）函数。</p>
<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在 sales data类中，受委托的构造函数体恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。</p>
<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>默认初始化在以下情况发生</p>
<ul>
<li>当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。</li>
<li>当一个类本身含有类类型的成员且使用合成的默认构造函数时。</li>
<li>当类类型的成员没有在构造函数初始值列表中显式地初始化时。</li>
</ul>
<p>值初始化在以下情况发生</p>
<ul>
<li>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。</li>
<li>当我们不使用初始值定义一个局部静态变量时。</li>
<li>当我们通过书写形如T( )的表达式显式地请求值初始化时，其中T是类型名(vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化)。类必须包含一个默认构造函数以便在上述情况下使用，其中的大多数情况非常容易判断。</li>
</ul>
<h4 id="一个常犯的错误"><a href="#一个常犯的错误" class="headerlink" title="一个常犯的错误"></a>一个常犯的错误</h4><p>对于C++的新手程序员来说有一种常犯的错误，它们试图以如下的形式声明-一<br>个用默认构造函数初始化的对象:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_ data <span class="title">obj</span><span class="params">()</span> </span>;				<span class="comment">//错误:声明了一个函数而非对象</span></span><br><span class="line">Sales_ data obj2;				<span class="comment">//正确: obj2是一个对象而非函数</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数接受一个实参，那么实际上也定义了隐式转换的机制，例如：A类中有一个构造函数只接受一个string类型的参数，那么在需要A类的地方，我们可以由string去代替，编译器会自动的将string转换为A。</p>
<h4 id="只允许一步类类型的转换"><a href="#只允许一步类类型的转换" class="headerlink" title="只允许一步类类型的转换"></a>只允许一步类类型的转换</h4><p>如果直接把一个常量字符串用在A类的地方，需要先转换成string，再转换为A，所以是错误的。可以先显示的转化为string，如：<code>string(&quot;999&quot;)</code>，再放到需要A的地方。</p>
<p>这种转换取决于用户对使用它的看法，并不总是有效。</p>
<h4 id="抑制构造函数隐式转换"><a href="#抑制构造函数隐式转换" class="headerlink" title="抑制构造函数隐式转换"></a>抑制构造函数隐式转换</h4><p>在构造函数前加上explicit用来阻止隐式转换的发生，它只对有一个参数的函数有效：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span> <span class="params">(<span class="keyword">const</span> std::string &amp;s)</span> : bookNo(s) &#123;</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span> <span class="params">(std::istream&amp;)</span> </span>;</span><br><span class="line">	<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="explicit构造只用于直接初始化"><a href="#explicit构造只用于直接初始化" class="headerlink" title="explicit构造只用于直接初始化"></a>explicit构造只用于直接初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;999&quot;</span>;</span><br><span class="line"><span class="function">Sales_ _data <span class="title">item1</span> <span class="params">(null_book)</span> </span>; <span class="comment">// 正确:直接初始化</span></span><br><span class="line"><span class="comment">//错误:不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br><span class="line">Sales_ data item2 = null_book;</span><br></pre></td></tr></table></figure>

<p>使用该关键字后不可用于拷贝。</p>
<h4 id="显示转换构造函数"><a href="#显示转换构造函数" class="headerlink" title="显示转换构造函数"></a>显示转换构造函数</h4><p>explicit函数会阻止隐式的转换，但是我们依然可以用该函数显示的进行转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确:实参是一个显式构造的Sales_ data对象</span></span><br><span class="line">item. <span class="built_in">combine</span> (Sales_ <span class="built_in">data</span> (null_ book)) ;</span><br><span class="line"><span class="comment">//正确: static_ cast可以使用explicit的构造函数</span></span><br><span class="line">item. <span class="built_in">combine</span> (static_ cast&lt;Sales_ data&gt;(cin)) ;</span><br></pre></td></tr></table></figure>

<h4 id="标准库显式的构造函数的类："><a href="#标准库显式的构造函数的类：" class="headerlink" title="标准库显式的构造函数的类："></a>标准库显式的构造函数的类：</h4><p>我们用过的-.些标准库中的类含有单参数的构造函数:</p>
<ul>
<li>接受一个单参数的const char*的string构造函数不是explicit的。</li>
<li>接受一个容量参数的vector构造函数(参见3.3.1节，第87页)是explicit的。</li>
</ul>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>满足下列条件，可以说它是一个聚合类：</p>
<ul>
<li>所有成员都是public的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类，也没有virtual函数。</li>
</ul>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	string S;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>聚合类的显示初始化方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// val1. ival= 0; val1.s = string ( &quot;Anna&quot; )</span></span><br><span class="line">Datavall= &#123; <span class="number">0</span>, <span class="string">&quot;Anna&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>显示初始化的缺点：</p>
<ul>
<li>要求类的所有成员都是public的。</li>
<li>将正确初始化每个对象的每个成员的重任交给了类的用户(而非类的作者)。因为用户很容易忘掉某个初始值，或者提供–个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。</li>
<li>添加或删除-一个成员之后，所有的初始化语句都需要更新。</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>数据成员都是字面值类型的聚合类就是字面值常量类。不是聚合但符合下列要求也是：</p>
<ol>
<li><p>数据成员都必须是字面值类型。</p>
</li>
<li><p>类必须至少含有一个constexpr构造函数。</p>
</li>
<li><p>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</p>
</li>
<li><p>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</p>
</li>
</ol>
<p>对于条件的理解：</p>
<p>满足条件1，就可以在编译阶段求值，这一点和聚合类一样。</p>
<p>满足条件2，就可以创建这个类的constexpr类型的对象。</p>
<p>满足条件3，就可以保证即使有类内初始化，也可以在编译阶段解决。</p>
<p>满足条件4，就可以保证析构函数没有不能预期的操作。</p>
<h4 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h4><p>构造函数不能是const的，但字面值常量类的构造函数可以是constexpr的，且必须至少有一个constexpr构造函数。</p>
<p>constexpr构造函数函数体一般来说是空的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span> <span class="params">(<span class="keyword">bool</span> b = <span class="literal">true</span>)</span> : hw(b)， io(b)， other(b) &#123;</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span> <span class="params">(<span class="keyword">bool</span> h，<span class="keyword">bool</span> i, <span class="keyword">bool</span> o)</span> : hw(h)，io(i), other(o) &#123;</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hw || io || other; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> set_ <span class="title">io</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; io = b; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> set_ <span class="title">hw</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> set_ <span class="title">other</span> <span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">bool</span> hw;					<span class="comment">//硬件错误，而非IO错误</span></span><br><span class="line">	<span class="keyword">bool</span> io;					<span class="comment">// I0错误</span></span><br><span class="line">	<span class="keyword">bool</span> other;					<span class="comment">//其他错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样声明以后，就可以在使用constexpr表达式或者constexpr函数的地方使用字面值常量类了。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第八章</title>
    <url>/2021/12/10/%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>以往用到的IO库设施：</p>
<ul>
<li><p>istream(输入流)类型，提供输入操作。</p>
</li>
<li><p>ostre am(输出流)类型，提供输出操作。</p>
</li>
<li><p>cin, 一个istream对象，从标准输入读取数据。</p>
</li>
<li><p>cout，一个ostream对象，向标准输出写入数据。</p>
</li>
<li><p>cerr，一个ostream对象，通常用于输出程序错误消息，写入到标准错误。</p>
</li>
<li><p><code>&gt;&gt;</code>运算符，用来从一个istream对象读取输入数据。</p>
</li>
<li><p><code>&lt;&lt;</code>运算符，用来向一个ostream对象写入输出数据。</p>
</li>
<li><p>getline函数，从一个给定的istream读取一行数据，存入一个给定的string对象中。</p>
</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><table>
<thead>
<tr>
<th>头文件</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td>iostream</td>
<td align="left">istream, wistream从流读取数据<br/>ostream, wost ream向流写入数据<br/>iostream，wiostream读写流</td>
</tr>
<tr>
<td>fstream</td>
<td align="left">ifstream, wifstream 从文件读取数据<br/>ofstream, wofstream 向文件写入数据<br/>fstream，wfstream读写文件</td>
</tr>
<tr>
<td>sstream</td>
<td align="left">istringstream, wistringstream 从string读取数据.<br/>ostringstream, wostringstream 向string写入数据<br/>stringstream, wstringstream 读写string</td>
</tr>
</tbody></table>
<p>为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t 类型的数据。宽字符版本的类型和函数的名字以一个w开始。例如，wcin、wcout和wcerr是分别对应cin、cout和cerr的宽字符版对象。宽字符版本的类型和对象与其对应的普通char版本的类型定义在同一个头文件中。例如，头文件fstream定义了ifstream 和wifstream类型。</p>
<h4 id="IO类型间的关系"><a href="#IO类型间的关系" class="headerlink" title="IO类型间的关系"></a>IO类型间的关系</h4><p>设备类型和字符大小不会影响我们执行的IO操作，例如使用&gt;&gt;读取数据，我们不需要管是从控制台还是磁盘文件、还是string读取，同样也不需要管字符存入的是char还是wchar_t。这一点实际上是通过类的继承机制实现的。类型ifstream和istringstream都继承自istream. 因此，我们可以像使用istream对象-样来使用ifstream和istringstream对象。</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream out1， out2;</span><br><span class="line">out1 = out2;								<span class="comment">//错误:不能对流对象賦值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span> <span class="params">(ofstream)</span> </span>;					<span class="comment">//错误:不能初始化ofstream参数</span></span><br><span class="line">out2 = <span class="built_in">print</span> (out2) ;						<span class="comment">//错误:不能拷贝流对象</span></span><br></pre></td></tr></table></figure>

<p>由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p>一个流发生错误，后续的IO操作都会失败，所以因通过代码检查它是否处于良好状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)&#123;</span><br><span class="line">	<span class="comment">//如果能够进来，代表流状态良好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p>上面的操作只知道有没有错误，但不知道是什么错误，所以IO库定义了一个与机器无关的iostate类型：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>badbit</td>
<td>系统级错误，如不可恢复的读写错误。</td>
</tr>
<tr>
<td>failbit</td>
<td>期望读取的数值却读出一个字符等错误，这种问题可以修正，且流还可以使用。<br>到达文件结束位置会被置位。</td>
</tr>
<tr>
<td>eofbit</td>
<td>到达文件结束位置，其会被置位。</td>
</tr>
<tr>
<td>goodbit</td>
<td>值为0表示流未发生错误，如果上面任何一个被置位，则检测流状态的条件会失败</td>
</tr>
</tbody></table>
<p>标准库还定义了一组函数来查询这些标志位的状态。操作 good在所有错误位均未置位的情况下返回true，而 bad、fail和 eof则在对应错误位被置位时返回true。此外，在 badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于!fail()。而eof和 bad操作只能表示特定的错误。</p>
<h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><p>流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员(参见6.4节,第206页):它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。<br>clear不接受参数的版本清除(复位)所有错误标志位。执行clear()后,调用good会返回true。我们可以这样使用这些成员:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记住cin的当前状态</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();			<span class="comment">//记住cin的当前状态</span></span><br><span class="line">cin.<span class="built_in">clear</span>();							<span class="comment">//使cin有效</span></span><br><span class="line"><span class="built_in">process_input</span> (cin) ;					<span class="comment">//使用cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state) ;				<span class="comment">//将cin置为原有状态</span></span><br></pre></td></tr></table></figure>

<p>带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。例如，下面的代码将failbit和 badbit复位，但保持eofbit不变://复位failbit和badbit，保持其他标志位不变cin.clear(cin.rdstate () &amp; ~cin.failbit &amp; ~cin.badbit);</p>
<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码</p>
<p><code>os &lt;&lt; &quot;please enter a value: &quot;;</code></p>
<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。</p>
<p>导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多;</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如 endl（参见1.2节，第6页）来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和 cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</li>
</ul>
<h4 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt;<span class="string">&quot;hi! &quot;</span> &lt;&lt;endl;			<span class="comment">//输出hi和一个换行，然后刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi ! &quot;</span> &lt;&lt; flush;		<span class="comment">//输出hi，然后刷新缓冲区，不附加任何额外字符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi ! &quot;</span> &lt;&lt;ends;			<span class="comment">//输出hi和一个空字符，然后刷新缓冲区</span></span><br></pre></td></tr></table></figure>

<h4 id="unitbuf操纵符"><a href="#unitbuf操纵符" class="headerlink" title="unitbuf操纵符"></a>unitbuf操纵符</h4><p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次 flush 操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;					<span class="comment">//所有输出操作后都会立即刷新缓冲区	</span></span><br><span class="line"><span class="comment">//任何输出都立即刷新，无缓冲</span></span><br><span class="line">cout &lt;&lt;nounitbuf ;					<span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>

<p><em>如果程序异常终止,输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。<br>当调试一个已经崩溃的程序时,需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。</em></p>
<h4 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h4><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和 cin关联在一起，因此下面语句导致cout的缓冲区被刷新。<br><code>cin &gt;&gt; ival;</code><br>tie可以将自己和一个输出流绑定起来，并且返回与自己关联的对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span> ( &amp;cout) ;						<span class="comment">//仅仅是用来展示:标准库将cin和cout关联在一起</span></span><br><span class="line"><span class="comment">// old_tie指向当前关联到cin的流（如果有的话)</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); 	<span class="comment">//cin 不再与其他流关联</span></span><br><span class="line"><span class="comment">//将cin 与cerr关联;这不是一个好主意，因为cin应该关联到cout</span></span><br><span class="line">cin.<span class="built_in">tie</span> ( &amp;cerr);						<span class="comment">//读取cin会刷新cerr而不是cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie) ;						<span class="comment">//重建cin和 cout间的正常关联</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了tie。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>头文件 fstream定义了三个类型来支持文件IO:ifstream从一个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。</p>
<p>fstream中定义的类型还增加了一些新的成员管理与流关联的文件</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fstream fstrm;</td>
<td>创建一个未绑定的文件流。fstream是头文件fstream 中定义的一个类型</td>
</tr>
<tr>
<td align="left">fstream fstrm (s);</td>
<td>创建一个fstream，并打开名为s的文件。s可以是string类型，或者是<br>一个指向C风格字符串的指针。这些构造函数都是explicit的。默认的<br>文件模式mode依赖于fstream的类型</td>
</tr>
<tr>
<td align="left">fstream fstrm <br>(s,mode) ;</td>
<td>与前一个构造函数类似，但按指定mode打开文件</td>
</tr>
<tr>
<td align="left">fstrm.open (s)</td>
<td>打开名为s 的文件，并将文件与 fstrm绑定。s可以是一个string或一个指向<br>C风格字符串的指针。默认的文件mode依赖于fstream的类型。返回void</td>
</tr>
<tr>
<td align="left">fstrm.close ()</td>
<td>关闭与fstrm绑定的文件。返回void</td>
</tr>
<tr>
<td align="left">fstrm.is_open ()</td>
<td>返回一个bool值,指出与fstrm关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody></table>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>向读写一个文件时，需要先定义一个文件流对象，如果提供了一个文件名，则会自动调用open：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span> <span class="params">(ifile)</span></span>;						<span class="comment">//构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out;								<span class="comment">//输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure>

<p>输入流in，初始化为从文件读取数据，输出流out，未关联。</p>
<h4 id="用fstream代替iostream-amp"><a href="#用fstream代替iostream-amp" class="headerlink" title="用fstream代替iostream&amp;"></a>用fstream代替iostream&amp;</h4><p>根据在要求使用基类对象的地方，我们可以使用继承类型的对象来替代。所以在调用一个具有iostream的参数时，可以用fstream来调用。</p>
<h4 id="成员函数open和close"><a href="#成员函数open和close" class="headerlink" title="成员函数open和close"></a>成员函数open和close</h4>]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第四章</title>
    <url>/2021/12/09/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>一元运算符</strong>作用于一个运算对象，二元运算符作用于两个运算对象，三元对运算对象没有限制。</p>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符（ overloadedoperator)**。IO库的&gt;&gt;和&lt;&lt;运算符以及string对象、vector对象和迭代器使用的运算</p>
<p><strong>左值和右值</strong></p>
<span id="more"></span>

<ul>
<li>当一个对象被用作右值的时候，用的是对象的值（内容);</li>
<li>当对象被用作左值的时候,用的是对象的身份（在内存中的位置)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">decltype</span>(*p) d1;<span class="comment">//d1为引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;p) d2;<span class="comment">//d2为指针的指针</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; ++i &lt;&lt; endl; <span class="comment">//未定义的</span></span><br></pre></td></tr></table></figure>

<p>这里可能先++i再求值，结果为1 1，也可能求值，再++i，结果为0 1，所以避免出现此种代码。</p>
<p>只有&amp;&amp;、||、？：、，四种运算符有明确的求值顺序。</p>
<p>形如<code>f() + g() * h() + j()</code>，因为求值的顺序与优先级和结合律无关，所以如果函数内部改变了一些关联的参数，则无法预计</p>
<hr>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul>
<li>一元运算符大于二元运算符</li>
<li>%不允许运算对象为浮点类型</li>
<li>C++11规定无论正负一律向0取整</li>
</ul>
<hr>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">异或</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">短路或</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">短路与</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">非</td>
</tr>
</tbody></table>
<p>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值(short-circuit evaluation）</strong>。<br><strong>逻辑非运算符</strong></p>
<p>在对象前加！表示取反，如<code>!s.empty()</code>。</p>
<p><strong>关系运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哎哟!这个条件居然拿i&lt;j的布尔值结果和k比较!</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;j&lt;k)<span class="comment">//若k 大于1则为真!</span></span><br><span class="line"><span class="comment">//正确:当i小于j并且j小于k时条件为真</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j &amp;&amp; j&lt;k)&#123;<span class="comment">/* ...* / &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算的结果是它的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</p>
<p>C++11允许使用花括号赋值</p>
<p>如<code>vector&lt;int&gt; v = &#123;0,5,3,4,8&#125;;</code></p>
<p><strong>赋值运算满足右结合律</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值运算符满足右结合律，这一点与其他二元运算符不太一样:</span></span><br><span class="line"><span class="keyword">int</span> ival,jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;		<span class="comment">//正确:都被赋值为0</span></span><br><span class="line"><span class="keyword">int</span> ival, *pval;		<span class="comment">// ival的类型是int; pval是指向int的指针</span></span><br><span class="line">ival = pval = <span class="number">0</span> ;		<span class="comment">//错误:不能把指针的值赋给int</span></span><br><span class="line">string sl,s2;</span><br><span class="line">sl = s2 = <span class="string">&quot;OK&quot;</span> ;		<span class="comment">//字符串字面值&quot;OK&quot;转换成string对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一种形式烦琐、容易出错的写法</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">get_value</span> () ;		<span class="comment">//得到第一个值</span></span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">42</span>)&#123;</span><br><span class="line">	<span class="comment">//其他处理·</span></span><br><span class="line">	i = <span class="built_in">get_value</span> ( );		<span class="comment">//得到剩下的值</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="comment">//更好的写法:条件部分表达得更加清晰</span></span><br><span class="line"><span class="keyword">while</span> ((i = <span class="built_in">get_value</span>())!= <span class="number">42</span>)&#123;	<span class="comment">//其他处理…..</span></span><br></pre></td></tr></table></figure>

<p><label stype = "color: red">切勿混淆”==”与“=”</label></p>
<hr>
<h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>++和–是加一减一一种简介的书写，若非必须，建议养成写前置版本的习惯。因为后置版本会造成性能浪费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span> ();</span><br><span class="line"><span class="comment">//输出元素直至遇到第一个负值为止</span></span><br><span class="line"><span class="keyword">while</span> (pbeg != v.<span class="built_in">end</span> () &amp;&amp; *beg &gt;= <span class="number">0</span> )</span><br><span class="line">	cout&lt;&lt; *pbeg++ &lt;&lt; endl;<span class="comment">//输出当前值并将pbeg向前移动一个元素</span></span><br></pre></td></tr></table></figure>

<p><code>*pbeg++</code>等价于<code>*(pbeg++)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该循环的行为是未定义的!</span></span><br><span class="line"><span class="keyword">while</span> (beg != s.<span class="built_in">end</span> () &amp; &amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">	*beg = <span class="built_in">toupper</span> ( *beg++); <span class="comment">//错误:该赋值语句未定义</span></span><br></pre></td></tr></table></figure>

<p>如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。</p>
<hr>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>ptr-&gt;mem等价于(*ptr).mem；</p>
<p>因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没加括号，代码的含义就大不相同了。</p>
<hr>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>cond ? expr1 : expr2;</p>
<p>此运算符只对expr1和expr2中的一个求值。</p>
<p><strong>嵌套运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span></span><br><span class="line">						  : (grade &lt; <span class="number">60</span>)?<span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span> ;</span><br></pre></td></tr></table></figure>

<p>条件运算符是满足右结合性质，意味着从右向左顺序组合，但嵌套最好不要超过两层。</p>
<p><em>解释一下左（右）结合律，举个例子，假设<del>是一个运算符，又有表达式a</del>b<del>c，如果</del>是左结合的，那么该表达式被解析为(a<del>b)</del>c，如果<del>是右结合的，那么该表达式将被解析为a</del>(b~c)。比如上表中三目运算符?:是从右向左结合的</em></p>
<p><strong>优先级</strong></p>
<p>该运算符优先级非常低，所以长表达式嵌套时最好加上括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; ( (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span> );	<span class="comment">// 输出pass或者fail</span></span><br><span class="line">cout &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;		<span class="comment">//输出1或者0!</span></span><br><span class="line">cout &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;		<span class="comment">//错误:试图比较cout和60</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp; 			位与</span><br><span class="line">| 			位或</span><br><span class="line">^ 			位异或</span><br><span class="line">~ 			取反</span><br><span class="line">&gt;&gt; 			向右移</span><br><span class="line">&gt;&gt;&gt; 		无符号右移</span><br><span class="line">&lt;&lt; 			向左移</span><br></pre></td></tr></table></figure>

<p>关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型，小整型在使用位运算符时会自动提升至大整型。</p>
<p><strong>移位运算符</strong></p>
<p>左移运算符(&lt;&lt;)在右侧插入值为0的二进制位。右移运算符(&gt;&gt;)的行为则依赖于其左侧运算对象的类型:如果该运算对象是无符号类型,在左侧插入值为0的二进制位;如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。</p>
<p><strong>位求反运算符</strong></p>
<p>位求反运算符(~）将运算对象逐位求反后生成一个新值，将1置为0、将0置为1。char类型的运算对象首先提升成int类型，提升时运算对象原来的位保持不变，往高位添加0即可。因此在本例中，首先将bits提升成int类型，增加24个高位0，随后将提升后的值逐位求反。</p>
<p><strong>使用位运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> quiz1 =<span class="number">0</span>;							<span class="comment">//我们把这个值当成是位的集合来使用</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="number">1UL</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1UL</span> &lt;&lt; <span class="number">27</span>										<span class="comment">//生成一个值，该值只有第27位为1</span></span><br><span class="line">quiz1 |= <span class="number">1UL</span>&lt;&lt; <span class="number">27</span>;								<span class="comment">//等价于quiz1 = quiz1 | 1UL&lt;&lt; 27;</span></span><br></pre></td></tr></table></figure>

<p>设quiz1当成位的集合，每一个位标识该位学生是否及格，则使用该代码可以表示第27位学生及格了。</p>
<p>若第27位学生没有及格使用一个第27位是0，其他位都是1的数,使用&amp;位于运算即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">quizl &amp;= ^(<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>);</span><br><span class="line"><span class="keyword">bool</span> status = quiz1 &amp;(<span class="number">1UL</span>&lt;&lt;<span class="number">27</span>);						<span class="comment">//学生27是否通过了测验?</span></span><br></pre></td></tr></table></figure>

<p>最后代码可判断第27位是否通过检测。</p>
<p><strong>位移运算符（IO预算符）满足左结合律</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; <span class="string">&quot; there&quot;</span> &lt;&lt;endl; </span><br><span class="line"><span class="comment">//的执行过程实际上等同于</span></span><br><span class="line">((cout&lt;&lt;<span class="string">&quot;hi&quot;</span>) &lt;&lt;<span class="string">&quot; there&quot;</span> ) &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="number">42</span> + <span class="number">10</span>;				<span class="comment">//正确:+的优先级更高，因此输出求和结果</span></span><br><span class="line">cout &lt;&lt; (<span class="number">10</span> &lt; <span class="number">42</span>);				<span class="comment">//正确:括号使运算对象按照我们的期望组合在一起，输出1</span></span><br><span class="line">cout &lt;&lt; <span class="number">10</span> &lt; <span class="number">42</span>;				<span class="comment">//错误:试图比较cout和42!</span></span><br></pre></td></tr></table></figure>

<p>移位运算符的优先级不高不低，介于中间:比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。因此在一次使用多个运算符时，有必要在适当的地方加上括号使其满足我们的要求。</p>
<hr>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式:<code>sizeof (type);sizeof expr;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span> (Sales_data) ;							<span class="comment">//存储sales_data类型的对象所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;									<span class="comment">//data的类型的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p;										<span class="comment">//指针所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;										<span class="comment">// p所指类型的空间大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue;							<span class="comment">//sales_data的revenue成员对应类型的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> sales_data: :revenue;					<span class="comment">//另一种获取revenue大小的方式</span></span><br></pre></td></tr></table></figure>

<p>这些例子中最有趣的一个是<code>sizeof  *p</code>。首先，因为 sizeof满足右结合律并且与<code>*</code>运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，它等价于<code>sizeof (*p)</code>。其次，因为sizeof不会实际求运算对象的值,所以即使p是一个无效(即未初始化）的指针也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。·对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小,指针不需有效。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小,等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
<hr>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>如果两种类型可以**相互转换( conversion)**，那么它们就是关联的。<br>举个例子，考虑下面这条表达式，它的目的是将ival初始化为6：</p>
<p><code>int ival = 3.541 + 3;//编译器可能会警告该运算损失了精度</code></p>
<p>代码中，首先为了不损失精度，3转为double类型，与3.541相加，得到double类型结果，但无法复制给int类型，最后再次转会int进行初始化。</p>
<p>上述的类型转换是自动执行的，无须程序员的介入，有时甚至不需要程序员了解。因此，它们被称作<strong>隐式转换（implicit conversion）</strong>。</p>
<p>何时发生隐式转换：</p>
<ul>
<li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li>
<li>在条件中，非布尔值转换成布尔类型。<br>初始化过程中，初始值转换成变量的类型;在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li>
<li>如第6章将**要介绍的，函数调用时也会发生类型转换。</li>
</ul>
<hr>
<h2 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h2><p>其中运算符的运算对象将转换成最宽的类型。例如，如果一个运算对象的类型是 longdouble，那么不论另外一个运算对象的类型是什么都会转换成long double。还有一种更普遍的情况，当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型。</p>
<p><strong>整型提升</strong></p>
<ul>
<li><p>对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在 int 里，它们就会提升成int 类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。</p>
</li>
<li><p>较大的char类型( wchar_t.char16_t、char32_t)提升成int.unsigned int、long、unsigned long、long long和 unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。</p>
</li>
</ul>
<p><strong>无符号与带符号转换</strong>（*****）</p>
<p>若类型分别位无符号和带符号，则</p>
<ul>
<li>无符号&gt;=带符号，带符号转为无符号。</li>
<li>相反，如果无符号类型所有值都能存在带符号类型中，则无符号转带符号，如不行带符号转无符号</li>
</ul>
<hr>
<h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><p><strong>数组转指针</strong></p>
<p>在大多数组表达式中，数组自动的转为指针，如：<code>int ia[10];    int* ip = ia;</code></p>
<p>但是当数组被用作 decltype关键字的参数，或者作为取地址符（ &amp;)、sizeof 及typeid等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组<code>int (&amp;arrRef)[10] = arr</code>;，上述转换也不会发生。</p>
<p><strong>指针的转换</strong></p>
<p>指针的转换:C++还规定了几种其他的指针转换方式，包括常量整数值О或者字面值nullptr能转换成任意指针类型;指向任意非常量的指针能转换成<code>void*</code>;指向任意对象的指针能转换成<code>const void*</code>。15.2.2节(第530页）将要介绍，在有继承关系的类型间还有另外一种指针转换的方式。</p>
<p><strong>转换布尔类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *cp = <span class="built_in">get_string</span> ();</span><br><span class="line"><span class="keyword">if</span> (cp)<span class="comment">/* ...* / 					//如果指针cp 不是0，条件为真</span></span><br><span class="line"><span class="comment">while ( *cp)/* ...*/</span>				<span class="comment">//如果*cp不是空字符，条件为真</span></span><br></pre></td></tr></table></figure>

<p><strong>转换成常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i;				<span class="comment">//非常量转换成const int的引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;				<span class="comment">//非常量的地址转换成const的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = j, *q= p;				<span class="comment">//错误:不允许const转换成非常量</span></span><br></pre></td></tr></table></figure>

<p><strong>类类型定义的转换</strong>：</p>
<p>类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。在7.5.4节（第263页)中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s, t = <span class="string">&quot;a value&quot;</span> ;					<span class="comment">//字符串字面值转换成string类型</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)							<span class="comment">//while的条件部分把cin转换成布尔值</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">double</span> slope = i/j;</span><br></pre></td></tr></table></figure>

<p>就要使用某种方法将i和/或j显式地转换成double,这种方法称作**强制类型转换(cast)**。</p>
<p><strong>命名的强制类型转换</strong></p>
<p><code>cast-name&lt;type&gt;(expression);</code></p>
<p>其中，type是转换的目标类型而expression是要转换的值。如果 type是引用类型，则结果是左值。cast-name是<strong>static_cast . dynamic_cast . const_cast和reinterpret_cast</strong>中的一种。dynamic_cast支持运行时类型识别。</p>
<p><strong>static_cast</strong></p>
<p>任何具有明确定义的类型转换,只要不包含底层const,都可以使用static_cast。例如，通过将一个运算对象强制转换成double类型就能使表达式执行浮点数除法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/ i ;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d;							<span class="comment">//正确:任何非常量对象的地址都能存入void*</span></span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);	<span class="comment">//正确:将void*转换回初始的指针类型</span></span><br></pre></td></tr></table></figure>

<p><strong>const_cast</strong></p>
<p>const_cast只能改变运算对象的底层const，称其为去掉const性质：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc); 			<span class="comment">//正确:但是通过p 写值是未定义的行为</span></span><br></pre></td></tr></table></figure>

<p>它能且只能改变常量属性，如对象是常量，再使用它执行写操作会产生未定义后果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp;				</span><br><span class="line"><span class="keyword">char</span> *q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);				<span class="comment">//错误:static_cast不能转换掉const性质</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;string&gt;(cp);						<span class="comment">//正确:字符串字面值转换成string类型const_cast&lt;string&gt; (cp) ;							//错误:const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure>

<p><strong>reinterpret_cast</strong>(*****)<br>通常为运算对象的位模式提供较低层次上的重新解释。</p>
<p><label stype = "color:red">避免强制类型转换，特别是最后一种。</label></p>
<p><strong>旧式强制类型转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> (expr ) ;								<span class="comment">//函数形式的强制类型转换</span></span><br><span class="line">(type) expr ;								<span class="comment">//c语言风格的强制类型转换</span></span><br><span class="line"><span class="keyword">char</span> *pc = (<span class="keyword">char</span>*) ip; 						<span class="comment">//ip是指向整数的指针,</span></span><br></pre></td></tr></table></figure>

<p>根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast、static_cast或reinterpret_cast相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成const_cast和static_cast也合法，则其行为与对应的命名转换一致。如果替换后不合法,则旧式强制类型转换执行与reinterpret_cast类似的功能，与reinterpret_cast效果一样。</p>
<hr>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>​        C++语言提供了一套丰富的运算符，并定义了这些运算符作用于内置类型的运算对象时所执行的操作。此外，C++语言还支持运算符重载的机制，允许我们自己定义运算符作用于类类型时的含义。第14章将介绍如何定义作用于用户类型的运算符。</p>
<p>​        对于含有超过一个运算符的表达式，要想理解其含义关键要理解优先级、结合律和求值顺序。每个运算符都有其对应的优先级和结合律，优先级规定了复合表达式中运算符组合的方式，结合律则说明当运算符的优先级一样时应该如何组合。</p>
<p>​        大多数运算符并不明确规定运算对象的求值顺序:编译器有权自由选择先对左侧运算对象求值还是先对右侧运算对象求值。一般来说，运算对象的求值顺序对表达式的最终结果没有影响。但是，如果两个运算对象指向同一个对象而且其中一个改变了对象的值，就会导致程序出现不易发现的严重缺陷。</p>
<p>​        最后一点，运算对象经常从原始类型自动转换成某种关联的类型。例如，表达式中的小整型会自动提升成大整型。不论内置类型还是类类型都涉及类型转换的问题。如果需要，我们还可以显式地进行强制类型转换。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第三章</title>
    <url>/2021/12/08/C++%20Primer%20%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><p>​        第2章介绍的内置类型是由C++语言直接定义的。这些类型，比如数字和字符，体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，它们尚未直接实现到计算机硬件中。<br>​        本章将介绍两种最重要的标准库类型: string 和 vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型，和其他内置类型一样，<strong>数组的实现与硬件密切相关</strong>。因此相较于标准库类型string和 vector，数组在灵活性上稍显不足。</p>
<span id="more"></span>

<h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>有了 using声明就无须专门的前缀（形如std :）也能使用所需的名字。声明如下：<br><code>using namespace::name ;</code><br>例如：<code>using std::cin; using std::cout;</code></p>
<p>头文件不应包含using声明，以免产生名字的冲突。</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>使用前需包含</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>

<h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string sl;<span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line">string s2 = s1;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s1)</span></span>;<span class="comment">//与上面相同</span></span><br><span class="line">string s4 = <span class="string">&quot;hiya&quot;</span>;<span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>;<span class="comment">//与上相同</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span> )</span></span>;<span class="comment">//s4的内容是cccccccccc</span></span><br><span class="line">string s7 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);<span class="comment">//与上相同</span></span><br></pre></td></tr></table></figure>

<p><strong>直接初始化与拷贝初始化</strong></p>
<p>区分：使用等号的都是拷贝初始化，其余是直接初始化。</p>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><strong>读写string对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="function">nt <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	string s;<span class="comment">//空字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cin &gt;&gt; s;<span class="comment">//将string 对象读入s，遇到空白停止</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cout &lt;&lt; s &lt;&lt;endl;<span class="comment">//输出s</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>输入过程中自动忽略开头空白，直到下一处空白，如：“   Hello World!  ”则只会输出”Hello”，输出结果没有任何空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string sl, s2;</span><br><span class="line">cin &gt;&gt; sl &gt;&gt; s2; <span class="comment">//把第一个输入读到s1中，第二个输入读到s2中</span></span><br><span class="line">cout&lt;&lt; s1 &lt;&lt; s2 &lt;&lt;endl;<span class="comment">//输出两个string对象</span></span><br></pre></td></tr></table></figure>

<p>这样输入上面的语句则会输出”HelloWorld!”。</p>
<p><strong>读取未知数量的string对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	string word;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; word)&#123;<span class="comment">//反复读取，直至到达文件末尾</span></span><br><span class="line">		cout &lt;&lt; word &lt;&lt; endl;<span class="comment">//逐个输出单词，每个单词后面紧跟一个换行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遇到文件结束符或非法输入就结束了</p>
<p><strong>getline读取一整行</strong></p>
<p>​    <strong>getline函数</strong>的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去（注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">    <span class="comment">//每次读入一整行，直至到达文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,line) )</span><br><span class="line">		cout&lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>string的empty和size操作</strong></p>
<ul>
<li><p>empty函数根据string对象是否为空返回对应的布尔值。</p>
</li>
<li><p>size函数返回string对象的长度，其类型为string::size_type类型，它是一个无符号类型的值，所以尽量避免size()和int混用。</p>
</li>
</ul>
<p><strong>比较string对象</strong></p>
<ul>
<li>两个string对象长度相同，所包含字符必须一模一样才算相等。</li>
<li>长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。</li>
<li>如果两个string 对象在某些对应的位置上不一致，则string对象比较的结果<br>其实是string对象中第一对相异字符比较的结果。</li>
</ul>
<p><strong>为string对象赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">st1</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span>, st2</span>;</span><br><span class="line">st1 = st2;</span><br></pre></td></tr></table></figure>

<p><strong>两个string对象相加</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello, &quot;</span>, s2 = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">string s3 = s1 + s2; <span class="comment">// s3 = &quot;hello, world\n&quot;</span></span><br><span class="line">s1 += s2; <span class="comment">//与上面等价</span></span><br></pre></td></tr></table></figure>

<p><strong>字面值和string对象相加</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span> + s2; <span class="comment">//可以，依次运算中至少保证有一个string对象</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span><span class="comment">//错误，不允许两个字面值直接相加</span></span><br></pre></td></tr></table></figure>



<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>函数名称                                   返回值<br>isalnum()        如果参数是字母数字，即字母或者数字，函数返回true</p>
<p>isalpha()         如果参数是字母，函数返回true</p>
<p>iscntrl()           如果参数是控制字符，函数返回true</p>
<p>isdigit()           如果参数是数字（0－9），函数返回true<br>isgraph()        如果参数是除空格之外的打印字符，函数返回true</p>
<p>islower()         如果参数是小写字母，函数返回true</p>
<p>isprint()          如果参数是打印字符（包括空格），函数返回true</p>
<p>ispunct()        如果参数是标点符号，函数返回true</p>
<p>isspace()        如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回true</p>
<p>isupper()        如果参数是大写字母，函数返回true</p>
<p>isxdigit()         如果参数是十六进制数字，即0－9、a－f、A－F，函数返回true</p>
<p>tolower()        如果参数是大写字符，返回其小写，否则返回该参数</p>
<p>toupper()       如果参数是小写字符，返回其大写，否则返回该参数</p>
<p>C++版本的标准库头文件为形如cname，而C头文件形如name.h，这里建议使用C++版本。</p>
<p><strong>for处理每个字符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span> <span class="params">( <span class="string">&quot;some string&quot;</span> )</span></span>;</span><br><span class="line"><span class="comment">//每行输出str中的一个字符。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)  <span class="comment">//对于str中的每个字符</span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl; <span class="comment">//输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>如果需要改变str中的字符，则在c前面加上&amp;。</p>
<p><strong>处理部分字符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index =<span class="number">0</span>;index != s.<span class="built_in">size</span> ( ) &amp;&amp; !<span class="built_in">isspace</span>(s [index]); ++index)</span><br><span class="line">	s[index] = <span class="built_in">toupper</span>(s[index]);<span class="comment">//将当前字符改成大写形式</span></span><br></pre></td></tr></table></figure>

<p>这里主要注意一点，index必须大于等于0，小于size()。</p>
<h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>

<p>vector是一个<strong>类模板</strong>，模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化（instantiation)**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<p>例如<code>vector&lt;int&gt; ivec; vector&lt;Sales_item&gt; Sales_vec;</code></p>
<p><label style = "color::red">vector模板不是类型，包含元素类型的vector才是，如<code>vector&lt;int&gt;</code>,且不可以包含引用</label></p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v1				v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span> <span class="params">(v1)</span>			v2中包含有v1所有元素的副本</span></span><br><span class="line"><span class="function">vector&lt;T&gt; v2 </span>= v1			等价于<span class="built_in">v2</span>(v1)，v2中包含有v1所有元素的副本</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span> <span class="params">(n,val)</span>		v3包含了n个重复的元素，每个元素的值都是val</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span> <span class="params">(n)</span>			v4包含了n个重复地执行了值初始化的对象</span></span><br><span class="line"><span class="function">vector&lt;T&gt; v5</span>&#123;a,b,c...&#125;  	v5包含了初始值个数的元素，每个元素被赋予相应的初始值</span><br><span class="line">vector&lt;T&gt; v5 =&#123;a,b,c...&#125; 	等价于v5&#123;a,b,c...&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造（类型必须相同）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;				<span class="comment">//初始状态为空</span></span><br><span class="line"><span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec2</span> <span class="params">(ivec)</span></span>;		<span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec3 = ivec;		<span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(ivec2)</span></span>;		<span class="comment">//错误: svec的元素是string对象，不是int</span></span><br></pre></td></tr></table></figure>

<p><strong>列表初始化vector对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; articles = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span> , <span class="string">&quot;the&quot;</span> &#125;;</span><br><span class="line">vector&lt;string&gt; v1 &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125; ; 	<span class="comment">//列表初始化</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v2</span><span class="params">( <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>)</span> </span>; 		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>值初始化</strong></p>
<p>使用<code>vector&lt;T&gt; v(n);</code>需注意 T 支不支持默认初始化。</p>
<p><code>vector&lt;int&gt; vi = 10;//错误:必须使用直接初始化的形式指定向量大小</code></p>
<p>注意区分花括号和圆括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span> </span>;		<span class="comment">// v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;; 		<span class="comment">// v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>，<span class="number">1</span>)</span></span>;		<span class="comment">// v3有10个元素，每个的值都是1</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4 &#123;<span class="number">10</span>,<span class="number">1</span>&#125;; 		 <span class="comment">// v4有2个元素，值分别是10和1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v5 &#123; <span class="string">&quot;hi&quot;</span>&#125;;<span class="comment">//列表初始化:v5有一个元素</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v6</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;<span class="comment">//错误:不能使用字符串字面值构建vector对象</span></span><br><span class="line">vector&lt;string&gt; V7 &#123;<span class="number">10</span>&#125;;<span class="comment">// v7有10个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span> &#125;;<span class="comment">// v8有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，只有v5为列表初始化，使用花括号时，若提供的对象不可以作为对象的初始值，则编译器会尝试默认值初始化。</p>
<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;<span class="comment">//空vector对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">	v2.<span class="built_in">push_back</span>(i); <span class="comment">//依次把整数值放到v2尾端//循环结束后v2有100个元素，值从0到99</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">使用范围for循环遍历容器时，不得改变vector容器的大小。</label></p>
<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v.<span class="built_in">empty</span> () 				<span class="comment">//如果v不含有任何元素，返回真;否则返回假</span></span><br><span class="line">v.<span class="built_in">size</span> () 				<span class="comment">//返回v中元素的个数</span></span><br><span class="line">v.<span class="built_in">push_back</span> (t) 		<span class="comment">//向v的尾端添加一个值为t的元素</span></span><br><span class="line">v [n] 					<span class="comment">//返回v中第n个位置上元素的引用</span></span><br><span class="line">v1 = v2					<span class="comment">//用v2中元素的铂贝替换v1中的元素</span></span><br><span class="line">vl = &#123;a,b,c... &#125;		<span class="comment">//用列表中元素的拷贝替换v1中的元素</span></span><br><span class="line">vl == v2 				<span class="comment">//v1和 v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2</span><br><span class="line">&lt;,&lt;=,&gt;,&gt;= 				<span class="comment">//顾名思义，以字典顺序进行比较</span></span><br></pre></td></tr></table></figure>

<p>vector容器的size类型一定要包含元素类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">veetor&lt;<span class="keyword">int</span>&gt;: :size_type		<span class="comment">//正确</span></span><br><span class="line">vector::size type			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>vector容器的比较大小参照string。</p>
<p><label style = "color::red">vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。</label></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由编译器决定b和e的类型</span></span><br><span class="line"><span class="comment">// b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>(); <span class="comment">//b 和e的类型相同</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">容器为空时，begin和end都是返回的是同一个迭代器，都是尾后迭代器</label></p>
<p><strong>迭代器运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* iter				<span class="comment">//返回迭代器iter所指兀素的引用</span></span><br><span class="line">iter-&gt;mem			<span class="comment">//解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</span></span><br><span class="line">++iter			 	<span class="comment">//令iter指示容器中的下一个元素</span></span><br><span class="line">--iter				<span class="comment">//令iter指示容器中的上一个元素</span></span><br><span class="line">iter1 == iter2		<span class="comment">//判断两个迭代器是否相等（不相等)，如果两个迭代器指示的是同一个元</span></span><br><span class="line">iter1 != iter2		<span class="comment">//素或者它们是同一个容器的尾后迭代器，则相等;反之，不相等</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器的移动</strong></p>
<p>采用++或–操作改变其位置</p>
<p><label style = "color::red">end返回的迭代器不代表莫格元素，所以不能增减，解引用操作</label></p>
<p>迭代器用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依次处理s 的字符直至我们处理完全部字符或者遇到空白</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span> ( ) &amp;&amp; !<span class="built_in">isspace</span> (*it); ++it)</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it); <span class="comment">//将当前字符改成大写形式</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; : :iterator it; <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string: :iterator it2;		<span class="comment">// it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; : : const_iterator it3; <span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line">string : :const_iterator it4;  		<span class="comment">//it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">如果容器是常量，则只能使用const迭代器</label></p>
<p><strong>begin和end</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> itl = v.<span class="built_in">begin</span>();	<span class="comment">//it1的类型是vector&lt;int&gt; : :iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();	<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();	<span class="comment">//it3的类型是vector&lt;int&gt;::const iterator</span></span><br></pre></td></tr></table></figure>

<p>如果对象只需读操作而无须写操作的话最好使用常量类型(比如 const_iterator)。为了便于专门得到const_iterator类型的返回值,C++11新标准引入了两个新函数,分别是cbegin和cend，无论对象是什么，返回值都是const_iterator。</p>
<p><strong>结合解引用和成员访问操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">( *it) .<span class="built_in">empty</span>()	<span class="comment">//解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.<span class="built_in">empty</span>()		<span class="comment">//错误:试图访问it的名为empty的成员，但it是个迭代器，没有empty成员</span></span><br><span class="line">it-&gt;<span class="built_in">empty</span>()		<span class="comment">//此操作与上面操作相同</span></span><br></pre></td></tr></table></figure>

<p>为了简化上述表达式，C++语言定义了箭头运算符（-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it-&gt;mem和(*it) .mem表达的意思相同。</p>
<p><strong>迭代器失效</strong></p>
<p><label style = "color::red">谨记,但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</label></p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器可以进行+- 等运算使它一次移动多个位置，大于小于操作则判断迭代器的相对位置，但必须在同一个容器里。</p>
<p>迭代器相减得到所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type 的带符号整型数。string 和vector都定义了difference_type ，因为这个距离可正可负，所以difference_type是带符号类型的。</p>
<p><strong>使用迭代器运算</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// text必须是有序的</span></span><br><span class="line"><span class="comment">// beg 和end表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span> ( ) , end = text.<span class="built_in">end</span> ( ) ;</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span> () + (end - beg)/<span class="number">2</span>; <span class="comment">// 初始状态下的中间点</span></span><br><span class="line"><span class="comment">//当还有元素尚未检查并且我们还没有找到sought时执行循环</span></span><br><span class="line"><span class="keyword">while</span> (mid != end &amp; &amp; *mid != sought) &#123;</span><br><span class="line">	<span class="keyword">if</span> (sought&lt; *mid)	<span class="comment">//我们要找的元素在前半部分吗?</span></span><br><span class="line">		end = mid;		<span class="comment">//如果是，调整搜索范围使得忽略掉后半部分</span></span><br><span class="line">	<span class="keyword">else</span>				<span class="comment">//我们要找的元素在后半部分</span></span><br><span class="line">		beg = mid + <span class="number">1</span>;	<span class="comment">//在mid之后寻找</span></span><br><span class="line">	mid = beg + (end - beg)/ <span class="number">2</span>;				<span class="comment">//新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与vector对比：</p>
<ul>
<li>数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。</li>
<li>与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</li>
</ul>
<h3 id="定义和初始化-1"><a href="#定义和初始化-1" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;			<span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;	<span class="comment">//常量表达式，关于constexpr，参见2.4.4节（第59页)</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] ;				<span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *parr[sz];				<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line">string bad[cnt ] ;			<span class="comment">//错误:cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];	<span class="comment">// 当get_size是constexpr时正确;否则错误</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">和内置类型的变量一样,如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</label></p>
<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
<p><strong>显示初始化数组元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> ia1[sz] = &#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>];				<span class="comment">//含有3个元素的数组,元素值分别是0，1，2</span></span><br><span class="line"><span class="keyword">int</span> a2[]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;					<span class="comment">//若不指定维度，则根据初始值计算，这里是维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>&#125;;				<span class="comment">//等价于a3[] =&#123;0,1，2，0,0&#125;</span></span><br><span class="line">string a4 [<span class="number">3</span>] = &#123; <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span> &#125; ;	<span class="comment">//等价于a4 [] = &#123; &quot;hi&quot;，&quot;bye&quot;，&quot;&quot; )</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;					<span class="comment">//错误:初始值过多</span></span><br></pre></td></tr></table></figure>

<p><strong>字符数组的特殊性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> al[]= &#123;<span class="string">&#x27;c&#x27;</span> , <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;		<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[]= &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;+‘， ’+‘， ’\0‘&#125;;	//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="string">char a3[]= &quot;C++&quot;;					//自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="string">const char a4 [6]=&quot;Daniel&quot;;			//错误:没有空间可存放空字符!</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">字符串结尾还有一个空字符，也会占用空间，和被拷贝。</label></p>
<p><strong>拷贝与赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>，<span class="number">2</span>&#125;;			   <span class="comment">//含有3个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> a2[]= a;					<span class="comment">//错误:不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;							<span class="comment">//错误:不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>

<p><em>一些编译器支持数组的赋值,这就是所谓的编译器扩展（compiler extension)。但一般来说,最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</em></p>
<p><strong>复杂数组的声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>] ;			<span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/* ?*/</span>;		<span class="comment">//错误:不存在引用的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*Parray)[<span class="number">10</span>]= &amp;arr;	<span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;arrRef)[<span class="number">10</span>] = arr;	<span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> * (&amp;arry)[<span class="number">10</span>] = ptrs;  <span class="comment">//arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure>

<p>这里重点在于顺序，</p>
<ul>
<li>对于无括号情况，从右往左，例如ptrs，我们先看到的是[10]，表明这是一个数组。</li>
<li>对于右括号，从内向外，例如parray，先看到是一个指针，表明是一个指针，它指向了数组。</li>
<li>对于arry，先从内向外，再从右往左。</li>
</ul>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库 stddef.h头文件的C++语言版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)		<span class="comment">//对于scores中的每个计数值</span></span><br><span class="line">	cout&lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;			<span class="comment">//输出当前的计数值</span></span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>在大多数表达式中,使用数组类型的对象其实是使用一个指向该数组首元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;	<span class="comment">// ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;						<span class="comment">// ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line">ia2 =<span class="number">42</span>;							<span class="comment">//错误:ia2是一个指针，不能用int值给指针赋值</span></span><br><span class="line"><span class="comment">//尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式:</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span> <span class="params">( &amp;ia[<span class="number">0</span>])</span></span>;					<span class="comment">//显然ia2的类型是int*</span></span><br><span class="line"><span class="comment">//当使用decltype关键字时上述转换不会发生，decltype (ia)返回的类型是由10个整数构成的数组:</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line">ia3 = p;							<span class="comment">//错误:不能用整型指针给数组赋值</span></span><br><span class="line">ia3 [<span class="number">4</span>] = i;					 	<span class="comment">//正确:把i的值赋给ia3的一个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>指针也是迭代器</strong></p>
<p>指针可以做与迭代器同样的操作（我认为本质上没有区别），尾指针可以通过<code>int *e = &amp;arr[arr.len];</code>的方法获取。</p>
<p><strong>标准函数begin和end</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[ ] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>); 	<span class="comment">//ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span> (ia) ;				<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="keyword">int</span> * last = <span class="built_in">end</span> (ia) ;				<span class="comment">//指向arr尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>

<p><em>C++11新标准引入了两个名为begin和 end 的函数。这两个函数与容器中的两个同名成员，功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数:</em></p>
<p><label style = "color::red">一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意,尾后指针不能执行解引用和递增操作。</label></p>
<p><strong>指针运算</strong></p>
<p>这里与容器中的迭代器除了两个指针相减是ptrdiff_t类型基本一致，该类型也是带符号类型。</p>
<p><em>指针运算同样适用于空指针和所指对象并非数组的指针。在后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span> last1 = *(ia + <span class="number">4</span>);		<span class="comment">//为ia[4]的值</span></span><br><span class="line"><span class="keyword">int</span> last2 = *ia +<span class="number">4</span>			<span class="comment">//含义完全不同，</span></span><br></pre></td></tr></table></figure>

<p><strong>下标和指针</strong></p>
<p>只要指针指向的是数组中的元素(或者数组中尾元素的下一位置)，都可以执行下标运算:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];				<span class="comment">// ia转换成指向数组首元素的指针ll ia [2]得到(ia + 2)所指的元素</span></span><br><span class="line"><span class="keyword">int</span> *p = ia;				<span class="comment">// p指向ia的首元素</span></span><br><span class="line">i =*(p + <span class="number">2</span>);				<span class="comment">//价于i = ia[2]</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;ia[ <span class="number">2</span>] ;			<span class="comment">// p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];				<span class="comment">// p[1]等价于*(p + 1)，就是ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k= p[<span class="number">-2</span>] ;				<span class="comment">// p[-2]是ia [ 0]表示的那个元素</span></span><br></pre></td></tr></table></figure>

<p>数组下标类型是带符号类型，这与vector和string不一致。</p>
<p><strong>C风格字符串</strong></p>
<p>风险大，不推荐使用，故暂时跳过</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。</p>
<p><strong>多维数组初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[ <span class="number">3</span>][<span class="number">4</span>]= &#123;			 <span class="comment">//三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">	&#123; <span class="number">0</span>,<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> &#125; ,			<span class="comment">//第1行的初始值</span></span><br><span class="line">	&#123; <span class="number">4</span>,<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>),				<span class="comment">//第2行的初始值</span></span><br><span class="line">	&#123; <span class="number">8</span>,<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>&#125;			<span class="comment">//第3行的初始值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//没有标识每行的花括号，与之前的初始化语句是等价的</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line"><span class="comment">//显式地初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;O &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125;&#125;;</span><br><span class="line"><span class="comment">//显式地初始化第1行，其他元素执行值初始化0</span></span><br><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">3</span>，<span class="number">6</span>，<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>多维数组的下标引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用arr的首元素为ia最后一行的最后一个元素赋值</span></span><br><span class="line">ia [<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];			<span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure>

<p><strong>for循环遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)				<span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row)&#123;			<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">		col = cnt;					<span class="comment">//将下一个值赋给该元素</span></span><br><span class="line">		++cnt;						<span class="comment">//将cnt 加1</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><label style = "color::red">要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</label></p>
<p><strong>指针和多维数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>*ip[<span class="number">4</span>];			<span class="comment">//整型指针的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*ip)[<span class="number">4</span>];		<span class="comment">//指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>声明指针注意区分以上区别，C++ 11推荐使用auto或者decltype也可避免加指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia [ <span class="number">3</span>][<span class="number">4</span>];			<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(*p)[ <span class="number">4</span>]= ia;		<span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p= &amp;ia [<span class="number">2</span>];				<span class="comment">//p指向ia的尾元素</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="comment">// p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)&#123;	</span><br><span class="line">	<span class="comment">// q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">		cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>auto p = begin(ia)</code>以可以更加简洁。</p>
<p><strong>类型别名简化多维数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span> [<span class="number">4</span>];	<span class="comment">//新标准下类型别名的声明，参见2.5.1节（第60页)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];	<span class="comment">//等价的typedef声明，参见2.5.1节（第60 页)</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="keyword">for</span> (int_array *p = ia; p != ia + <span class="number">3</span>; ++p)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> *q= *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">		cout&lt;&lt; *q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将类型“4个整数组成的数组”命名为 int_array，用类型名int_array定义外层循环的控制变量让程序显得简洁明了。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第二章</title>
    <url>/2021/12/08/C++Primer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><p>​    内置类型包括算术类型和空类型</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>1、算术类型分为两类：整型（包括字符和布尔类型）和浮点型。</p>
<p>2、布尔类型（bool）：取值是真或假。</p>
<span id="more"></span>

<p>3、字符类型（char）：一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值，即一个char的大小和一个机器字节一样（8位）。</p>
<p>4、短整型（short）：16位</p>
<p>5、整型（int）：16位</p>
<p>6、长整型（long）；32位</p>
<p>7、长整型（long long）：64位</p>
<p>8、单精度浮点类型（float）：32位，保留6位有效数字</p>
<p>9、双精度浮点类型（double）：64位，保留10位有效数字</p>
<p>10、扩展精度浮点类型（long double）：96或128位，保留10位有效数字</p>
<h3 id="带符号与无符号类型"><a href="#带符号与无符号类型" class="headerlink" title="带符号与无符号类型"></a>带符号与无符号类型</h3><p>​        除去<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</a>和扩展的字符型之外，其他整型可以划分为<strong>带符号的（signed）</strong>  和 <strong>无符号类型（unsigned）</strong> 两种，带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。</p>
<p><label style="color:red">只有整型才有符号型和无符号型之分，浮点型无此区别</label></p>
<p>​        类型int 、short 、 long 和 long long 都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，</p>
<p>例如 unsigned long 。类型 unsigned int 可以缩写为 unsigned 。</p>
<p><strong>特殊的char</strong></p>
<p>​        与其他整型不同，字符型被分为了三种：char 、 signed char 和 unsigned char。特别注意的是：类型 cahr 和 类型 signed char 并不一样。尽管字符型有三种，但是字符型的表现形式却只有两种： 带符号和无符号的。类型char实际上会表现为上述两种形式的一种 ，具体是哪种由编译器决定。</p>
<p>​        无符号类型中所有比特都用来存储值，例如，8比特的unsigned char 可以表示0至255区间内的值。</p>
<p>​        但是约定了在表示范围内正值和负值的最应该平衡。因此，8比特的signed char 理论上应该可以表示-127至127区间内的值，大多数现代计算器实际的表示范围定位 -128 至 127。可以理解为：因为把0划分到了无符号类型，所以0+127 = 128.</p>
<p>看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>;</span><br></pre></td></tr></table></figure>

<p>（均假设cahr占8比特）这两个语句的运行结果是：</p>
<p>c的值为255，</p>
<p>c2的值是未定义的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为o则结果为false,否则结果为true。</li>
<li>当我们把一个布尔值赋给非布尔类型时，初始值为false 则结果为o，初始值为true则结果为1。</li>
<li>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</li>
<li>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li>
</ul>
<p><strong>结论：</strong></p>
<p>1.当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char 可以表示0至255区间内的值，如果我们赋了一个区间意外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char 所得的结果是255.</p>
<p>2.当我们赋给符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>​        <strong>字面值常量</strong>（literal constant），“字面值”是指只能用它的值称呼它，“常量”是指其值不能修改。每个字面值都有相应的类型，3.14是double型，2是int型。只有内置类型存在字面值。</p>
<p><strong>1.</strong> <strong>整形字面值规则</strong></p>
<p>整形字面值常量可以用十进制、八进制、十六进制表示。</p>
<p>20    // dec</p>
<p>024   // oct（以0开头）</p>
<p>0x14  // hex（以0x或0X开头）</p>
<p>整形字面值常量的类型默认为int或long，其值适合int就是int类型，比int大就是long类型。在数值后加L或l（小写字母l容易与数字1混淆，建议用L）可以指定为long，加U或u指定为unsigned类型，加UL或LU定义为unsigned long类型。没有short类型的字面值常量。</p>
<p><strong>2.</strong> <strong>浮点字面值规则</strong></p>
<p>可以用十进制或科学计数法（指数用E或e）表示，默认为double，在数值后加F或f表示单精度，加L或l表示扩展精度。</p>
<p>3.14159F      .001f    12.345L     0.</p>
<p>3.14159E0f     1E-3F   1.2345E1L   0e0</p>
<p><strong>3.</strong> <strong>布尔字面值和字符字面值</strong></p>
<p>布尔字面值：true、false。字符字面值由单引号定义：’2’（char类型）、L’a’（wchar_t类型）。</p>
<p><strong>4.</strong> <strong>非打印字符和转义序列</strong></p>
<p>非打印字符和特殊字符（如单引号、双引号、反斜杠）都要写为转义字符（以反斜杠开头）。</p>
<p><img src="https://s2.loli.net/2021/12/07/vCu3TR6SWiftqVL.png" alt="image.png"></p>
<p>无论是普通字符，还是非打印字符和特殊字符，都可以表示为“通用转义字符”。如八进制形式的“\7（响铃符）、\12（换行符）、\0（空字符）、\62（数字2）”（可以对照ASCII码表看一下）。“通用转义字符”也可以用十六进制表示（\xddd）。</p>
<p><strong>5.</strong> <strong>字符串字面值</strong></p>
<p>需要用双引号括起来，非打印字符写要转义，编译器会自动在末尾添加一个空字符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">“hello c++”       <span class="comment">// simple string literal</span></span><br><span class="line">“”                <span class="comment">// empty string literal</span></span><br><span class="line">“\n hello \t c++” <span class="comment">// string literal using newlines and tabs</span></span><br><span class="line">L”hello c++”      <span class="comment">// a wide string literal</span></span><br></pre></td></tr></table></figure>

<p><strong>6.</strong> <strong>字符串字面值的连接</strong></p>
<p>两个相邻的，仅由空格、制表符、换行符分隔的字符串字面值，将连接在一起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; “a multi-line “ “string literal “</span><br><span class="line">            “<span class="keyword">using</span> concatenation”</span><br><span class="line">          &lt;&lt; std::endl</span><br></pre></td></tr></table></figure>

<p>输出：<strong>a multi-line string literal using concatenation</strong></p>
<p><strong>7</strong> <strong>多行字面值</strong></p>
<p>可以使用反斜杠，将多行内容当作同一行处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multiline string literal``std::cout &lt;&lt; “a multi-line \``string literal \``using` `a backslash”``   ``&lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure>

<p>反斜杠必须是行尾字符，后面不能有注释或空格。后继行行首的任何空格和制表符都是字符串字面值的一部分。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>​        变量类型决定所占空间的大小的布局方式以及所能参与的运算，变量与对象可互换。</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>​        命名空间 : : 类型说明符 空格 一个或多个变量名（中间以逗号分隔，以分号结束），可同时附初始值。</p>
<p><label style="color:red">初始化不是赋值,初始化的含义是创建变量时赋予其一个初始值,而赋值的含义是把对象的当前值擦除,而以一个新值来替代。</label></p>
<p><strong>列表初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> unit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unit = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> unit&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上效相同，但2、3无法转换类型、因为存在丢失信息风险。</p>
<p><strong>默认初始化</strong></p>
<p>​        定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化,则其值由类确定。</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>​        由于C++支持分离式编译，一个变量可被多个文件使用，则可使用变量名前加extern</p>
<p><code>extern int i</code></p>
<p>若给extern变量赋予初始值，则关键字失效。</p>
<p><label style="color:red">变量能且只能被定义一次，但可以被多次声明</label></p>
<p><strong>静态类型</strong></p>
<p>​    ·    <em>C+是一种静态类型（statically typed)语言,其含义是在编译阶段检查类型。其中,检查类型的过程称为类型检查(type checking)。<br>我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算,如果试图执行类型不支持的运算,编译器将报错并且不会生成可执行文件。</em></p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>​        用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>**全局作用域( global scope)**。一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用。</p>
<p>**块作用域(block scope)**。只在自己所声明区域可用。</p>
<p><label style="color:red">当局部变量与全局变量相同，局部变量会覆盖全局变量。不建议使用相同名称</label></p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>​        一条声明语句由一个基本数据类型(base type）和紧随其后的一个声明符( declarator）（变量名）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>​        引用并非对象，它只是已经存在对象的另一个名字，它出生就必须和初始值绑在一起，永不分离！</p>
<p><strong>引用的定义</strong></p>
<p><code>int i = 1024; int &amp;i1 = i;</code></p>
<p><label style="color:red">引用的初始值必须是像<strong>匹配</strong>的<strong>对象</strong></label></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>​        与引用类似，指针也实现了对其他对象的<strong>间接访问</strong>。然而指针与引用的不同点如下</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li>
<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
<p><strong>指针的定义</strong></p>
<p><code>int i = 1024; int *p = i;</code></p>
<p><label style="color:red">因为引用不是对象，所以不可以定义指向引用</label></p>
<p><strong>指针值</strong></p>
<p>指针的值（即地址）应属下列4种状态之一:</p>
<ul>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ul>
<p>使用解引用符*可访问所指对象，仅适用于状态1。</p>
<p><label style="color:red">无效指针不允许拷贝或访问，2、3指针虽然有效，但仍不允许访问</label></p>
<p><strong>空指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p4 = z;    </span><br></pre></td></tr></table></figure>

<p>p1，p2，p3都定义了一个空指针，但p4并不是空指针。</p>
<p><label style="color:red">建议初始化所有的指针</label></p>
<p><strong>赋值和指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="number">0</span>;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line">p = p1;</span><br></pre></td></tr></table></figure>

<p>赋值改变的永远是等号左侧的对象。则第4行为改指向对象，第5行改指针。</p>
<p><em><em>void</em>  指针</em>*</p>
<p>​        它可以指向任意类型，但也无法进行大部分操作，如输入、输出、赋给另一个void* 指针且不能直接操作所指对象。以它的视角，它只知道自己指向了一块内存空间。</p>
<p><strong>指向指针的指针</strong></p>
<p>​        <code>int *p1 = nullptr; int **p2 = p1;</code></p>
<p><strong>指向指针的引用</strong></p>
<p><code>        int *p = nullptr; int *&amp;r = p;</code></p>
<p>要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针，则r为p的别名。</p>
<p>思考：既然有指向指针的指针，那么有引用的引用吗？</p>
<p>答案：[C++ 是否能够定义引用的引用？]zhihu.com/question/28023545</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p><code>const int i = 520;</code></p>
<p>这样定义一个变量后，任何试图改变i的值的操作都会报错，且const必须附予初始值。</p>
<p><code>int j  = i;</code></p>
<p>i的常量特征仅仅只在执行改变i的才会发挥作用。仍可进行拷贝，运算等，一旦拷贝完成，新对象与原来的对象没什么关系了。</p>
<p><label style="color:red">在多个文件之间共享const对象，必须在变量定义前添加extern，因为我们只需要在一个文件中定义，而在其他文件中声明并使用</label></p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>把引用绑定到const对象上，称为对<strong>常量的引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化和对const的引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ci = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> &amp;r1 = ci;</span><br><span class="line"><span class="keyword">const</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> &amp;r3 = r1*<span class="number">2</span>; <span class="comment">//虽然不可以定义引用的引用但是，此句只是引用了48这个常量而已</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">//此句错误，r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li><p><label style="color:red">const可以引用const或普通变量，但不加const去引用const是不允许的</label></p>
</li>
<li><p>对于const引用一个非const对象，书中解释是可以绑定，但不允许通过此引用去修改它的值。这里我的理解是，既然不能通过自身修改，也能通过其他途径修改，那么他们就没有任何联系了，所以我理解为这里const仅仅只是引用了该对象的值而已。所以解释r4的错误应该是：r4引用了一个常量。</p>
</li>
</ul>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针(pointer to const)**不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针:</p>
<p><label style="color:red">所谓指向常量的指针或引用，不过是指针或引用的“自以为是”罢了，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值</label></p>
<p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针(const pointer)*<em>必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址）就不能再改变了。把</em>放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值:</p>
<p><label style="color:red">总结： 指向常量的指针与常量指针一个是</label></p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>对于一般变量而言没有顶层const和底层const区别，但一般算作顶层const。对于符合变量却有不同。</p>
<p>区别：</p>
<ul>
<li><strong>指向常量的指针</strong>：代表 <strong>不能改变其指向内容</strong>的指针。声明时const可以放在类型名前后都可，拿int类型来说，声明时：const int和int const 是等价的。声明指向常量的指针也就是 <strong>底层const</strong></li>
<li><strong>指针常量</strong>：代表指针本身是常量，声明时必须初始化，之后<strong>它存储的地址值就不能再改变</strong>。声明时const必须放在指针符号<em>后面，即：</em>const 。声明常量指针就是<strong>顶层const</strong></li>
<li>顶层const和底层const很简单， 一个指针本身添加const限定符就是顶层const，而指针所指的对象添加const限定符就是底层const。</li>
</ul>
<p>作用：</p>
<ul>
<li><p>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const。也就是说，你只要能正确区分顶层const和底层const，你就能避免这样的赋值错误。</p>
</li>
<li><p>使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。</p>
</li>
</ul>
<p>[练习一下，const int <em>const</em>const* pppi 是顶层const还是底层const？</p>
<p>答案当然是底层const，因为int前面const限定符，而最后一个*后面没有const限定符。看最后一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="comment">//int * pi = &amp;a;  //错误，&amp;a是底层const，不能赋值给非底层const </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pi = &amp;a; <span class="comment">//正确，&amp;a是底层const，可以赋值给底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> *<span class="keyword">const</span> ppi = &amp;pi  <span class="comment">//即是底层const，也是顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> *<span class="keyword">const</span> *pppi = &amp;ppi; <span class="comment">//底层const</span></span><br></pre></td></tr></table></figure>

<p>[参考原文]<a href="https://blog.csdn.net/qq_19528953/article/details/50922303">(18条消息) C++的顶层const和底层const的理解_冬之晓-CSDN博客_顶层const和底层const</a></p>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p><strong>常量表达式(const expression）</strong>是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 const对象也是常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ci = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> r = ci;<span class="comment">//这里并不属于常量表达式</span></span><br></pre></td></tr></table></figure>

<p><strong>constrxpr变量</strong>（C++ 11）</p>
<p>将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> li = mf + <span class="number">1</span>;<span class="comment">//这些都是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();<span class="comment">//只有当size是一个constexpr函数才是正确的声明</span></span><br></pre></td></tr></table></figure>

<p><label style="color:red">如果认定变量是一个常量表达式，就把它声明称constexpr类型。</label></p>
<p><strong>字面值类型</strong></p>
<ul>
<li><p>算数类型、引用、指针都属于字面值类型。</p>
</li>
<li><p>自定义类、IO库、string类型不属于字面值类型。</p>
</li>
</ul>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者o,或者是存储于某个固定地址中的对象。</p>
<ul>
<li><p>函数体内定义的变量一般来说并非存放在固定地址中,因此constexpr指针不能指向这样的变量。</p>
</li>
<li><p>相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化 constexpr指针。</p>
</li>
</ul>
<p>允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr 指针也能指向这样的变量。</p>
<p><strong>指针和constptr</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是指向常量整数的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是指向整数的常量指针</span></span><br></pre></td></tr></table></figure>



<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>它是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">//wage是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;<span class="comment">//base是double的同义词、p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sale_item;<span class="comment">//C++ 11中一种新的方法，效果一样</span></span><br></pre></td></tr></table></figure>

<p><strong>指针、常量和类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pst;  <span class="comment">//这里把char*看作一个整体，则pst替代的是char*</span></span><br><span class="line"><span class="keyword">const</span> pst cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pst *ps;<span class="comment">//ps是一个指针，指向char的常量指针。就等于const char **ps</span></span><br></pre></td></tr></table></figure>

<p>这里比较绕，首先pst是char*的别名，先不论pst看第二行代码，可知cstr是一个不能改变的值，再用pst替换这个值，就是不能改变指向char的指针。再不论pst看第三行，ps是一个指向常量的指针，用pst替换掉这个量，就是一个指向char的常量指针。</p>
<h3 id="auto类型说明符（C-11）"><a href="#auto类型说明符（C-11）" class="headerlink" title="auto类型说明符（C++ 11）"></a>auto类型说明符（C++ 11）</h3><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如 double)不同，auto 让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;<span class="comment">//类型一致可以一起定义</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//错误若类型不一致不可一起定义</span></span><br></pre></td></tr></table></figure>

<p><strong>符合类型’常量和auto</strong></p>
<ul>
<li>当引用被当作初始值，参与的是引用的对象</li>
<li>auto一般会忽略掉顶层const，同时底层const会保留下来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">//b为整数（顶层const忽略）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">//c为整数（一样忽略顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;  <span class="comment">//d为指向整形的指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">//e是指向整数常量的指针（这里属于底层const，保留）</span></span><br><span class="line"><span class="comment">//如果需要auto是顶层const则可以</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;<span class="comment">//推演为int，但f为const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;<span class="comment">//推演为int，可定义引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;<span class="comment">//非常量引用不可以绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;<span class="comment">//常量引用可以绑定字面值</span></span><br></pre></td></tr></table></figure>



<h3 id="decltype类型指示符（C-11）"><a href="#decltype类型指示符（C-11）" class="headerlink" title="decltype类型指示符（C++ 11）"></a>decltype类型指示符（C++ 11）</h3><p>它的作用是选择并返回操作数的数据类型，此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p>
<p><code>decltype(f()) sum = x;//sum的类型就是函数f返回的类型</code></p>
<p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢?就是假如f被调用的话将会返回的那个类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，则y绑定了x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//z类型是const int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>decltype和引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;<span class="comment">//正确，加法得到的结果是int，因此b为int类型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p);<span class="comment">//错误，解引用得到的是int&amp;，而非int，需要初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(r) c;<span class="comment">//错误，这里没有用加法，得到的是引用类型，需初始化</span></span><br></pre></td></tr></table></figure>

<p>使用+0的操作可以避免变成引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;<span class="comment">//d为引用</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;<span class="comment">//为int</span></span><br></pre></td></tr></table></figure>

<p><label style="color:red">切记:decltype ((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当 variable本身就是一个引用时才是引用。</label></p>
<h2 id="自定义的数据结构"><a href="#自定义的数据结构" class="headerlink" title="自定义的数据结构"></a>自定义的数据结构</h2><p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p>
<h3 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span><span class="comment">/*...*/</span>&#125; accum, trans, *salesptr;</span><br><span class="line"><span class="comment">//两种定义相同，但下面一种更好</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span><span class="comment">/*...*/</span>&#125;;</span><br><span class="line">Sales_data  accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>

<p>类体定义<strong>成员</strong>，这个类只有<strong>数据成员</strong>。类体定义完成后相当与一个类型。</p>
<p>C++11新标准规定，可以为数据成员提供一个**类内初始值（in-class initializer)**。创建对象时,类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="使用Sale-data类"><a href="#使用Sale-data类" class="headerlink" title="使用Sale_data类"></a>使用Sale_data类</h3><p><strong>总体轮廓</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sales_data.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	sales_data datal, data2;</span><br><span class="line">	<span class="comment">//读入datal和data2的代码</span></span><br><span class="line">	<span class="comment">//检查datal 和data2的工SBN是否相同的代码</span></span><br><span class="line">	<span class="comment">//如果相同，求datal和data2的总和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读入数据并处理</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price = <span class="number">0</span>; <span class="comment">//书的单价，用于计算销售收入</span></span><br><span class="line"><span class="comment">//读入第1笔交易:ISBN、销售数量、单价</span></span><br><span class="line">std: :cin &gt;&gt; data1.bookNo &gt;&gt; datal.units_sold &gt;&gt; price;</span><br><span class="line"><span class="comment">//计算销售收入</span></span><br><span class="line">data1.revenue = data1.units_sold *price;</span><br></pre></td></tr></table></figure>

<p><strong>输出和</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data1 . bookNo m= data2.bookNo)&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> totalCnt = data1.units_sold + data2.units_sold;</span><br><span class="line">	<span class="keyword">double</span> totalRevenue = data1.revenue + data2.revenue;</span><br><span class="line">	<span class="comment">//输出:ISBN、总销售量、总销售额、平均价格</span></span><br><span class="line">	std::cout &lt;&lt; data1.bookNo&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; totalCnt&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (totalcnt != o)</span><br><span class="line">		std:: cout &lt;&lt; totalRevenue/totalCnt &lt;&lt; std: :endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		std: :cout &lt;&lt;<span class="string">&quot; (no sales) &quot;</span> &lt;&lt; std: :endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//标示成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//两笔交易的ISBN不一样</span></span><br><span class="line">	std: :cerr &lt;&lt;<span class="string">&quot;Data must refer to the same ISBN&quot;</span> &lt;&lt;std: :endl;</span><br><span class="line">	<span class="keyword">return</span> -l;<span class="comment">//标示失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>头文件一旦改变，相关源文件必须重新编译以获取更新过的声明。</p>
<p><strong>预处理概述</strong></p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器(preprocessor)<strong>，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。例如#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。<br>C++程序还会用到的一项预处理功能是头文件</strong>保护符(header guard)<strong>，头文件保护符依赖于预处理变量。预处理变量有两种状态:已定义和未定义。</strong>#define</strong>指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:<strong>#ifdef</strong>当且仅当变量已定义时为真，**#ifndef<strong>当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到</strong>#endif**指令为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line">	std : : string bookNo ;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><label style="color:red">这里只需要知道无论你的程序多简单，习惯性的加上就好。</label></p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>类型规定了其对象的存储要求和所能执行的操作。C++语言提供了一套基础内置类型，如int和char等，这些类型与实现它们的机器硬件密切相关。类型分为非常量和常量，一个常量对象必须初始化,而且一旦初始化其值就不能再改变。此外，还可以定义复合类型,如指针和引用等。复合类型的定义以其他类型为基础。<br>C++语言允许用户以类的形式自定义类型。C++库通过类提供了一套高级抽象类型,如输入输出和string等。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo博客中文无法正常显示问题</title>
    <url>/2021/11/08/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="情况一：没有在站点配置文件或主题配置文件中将语言设置为中文"><a href="#情况一：没有在站点配置文件或主题配置文件中将语言设置为中文" class="headerlink" title="情况一：没有在站点配置文件或主题配置文件中将语言设置为中文"></a>情况一：没有在站点配置文件或主题配置文件中将语言设置为中文</h1><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>1：打开bolg目录下的_config.yml文件。</p>
<span id="more"></span>

<p>2：找到language字段，添加zh-CN，如下</p>
<p><code>language: zh-CN </code></p>
<p>3： 主题配置文件以next为例，打开\blog\themes\next_config.yml文件。</p>
<p>4： 同样进行如上操作</p>
<h3 id="这里建议直接创建Mardown文件"><a href="#这里建议直接创建Mardown文件" class="headerlink" title="这里建议直接创建Mardown文件"></a>这里建议直接创建Mardown文件</h3><p>以下为方法链接，并附上软件下载链接</p>
<p>[右键新建markdown文件]<a href="https://blog.csdn.net/huangjun0210/article/details/105952385">https://blog.csdn.net/huangjun0210/article/details/105952385</a></p>
<p>链接：<a href="https://pan.baidu.com/s/118PmZiKsJV8fLqjFd9X1JA">https://pan.baidu.com/s/118PmZiKsJV8fLqjFd9X1JA</a><br>提取码：5p7c<br>–来自百度网盘超级会员V4的分享</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>类名冲突问题</title>
    <url>/2021/11/07/%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>一般来说，leetcode给出的测试用例数量足够多，覆盖范围足够广，基本可以证明代码正确</strong></p>
<p>​        </p>
<p>​        这里可能是因为命名空间的问题，因为力扣中所有类名均为Solution，倘若在同一源文件下可能会造成命名冲突，这里有两种解决方法。</p>
<span id="more"></span>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>​        更改类名，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;```</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>​        添加命名空间，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> letter &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/11/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="hello-大家好，这是我的第一篇博客"><a href="#hello-大家好，这是我的第一篇博客" class="headerlink" title="hello! 大家好，这是我的第一篇博客"></a>hello! 大家好，这是我的第一篇博客</h1><h2 id="1、-我是谁？"><a href="#1、-我是谁？" class="headerlink" title="1、 我是谁？"></a>1、 我是谁？</h2><p>​        我是谁不重要。重要的是我想成为知识的传播者。</p>
<span id="more"></span>

<h2 id="2、创建博客的初衷"><a href="#2、创建博客的初衷" class="headerlink" title="2、创建博客的初衷"></a>2、创建博客的初衷</h2><p>​        我在解决一个又一个的问题的时候，各种博客、平台帮了我很多，这其中有很多非常详细且友好的帖子，但也有充斥各种问题的帖子，如语意不清、啰嗦、付费、繁杂等等，虽然最后我还是解决了这些问题，我不希望获得知识的路上充满荆棘，所以我创建了自己的博客，希望分享我所获得的知识，同时把我解决问题的过程、思考、以及总结的经验保存下来。为了你，也为了以后的我不再重蹈覆辙。</p>
<h2 id="3、我的计划"><a href="#3、我的计划" class="headerlink" title="3、我的计划"></a>3、我的计划</h2><p>​        我计划首先分享我在阅读书籍中、以前unity项目中、刷题中、以及搭建博客中的遇到的问题，同时因为我目前从事的是忆阻器件的制备，我也会分享在半导体方向所收获的知识（这方面的知识网上尤其的少）。也希望自己能够再接再厉。学更多的知识、看更远的风景。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
