<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Primer 第四章</title>
    <url>/2021/12/09/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>一元运算符</strong>作用于一个运算对象，二元运算符作用于两个运算对象，三元对运算对象没有限制。</p>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符（ overloadedoperator)**。IO库的&gt;&gt;和&lt;&lt;运算符以及string对象、vector对象和迭代器使用的运算</p>
<p><strong>左值和右值</strong></p>
<ul>
<li>当一个对象被用作右值的时候，用的是对象的值（内容);</li>
<li>当对象被用作左值的时候,用的是对象的身份（在内存中的位置)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">decltype</span>(*p) d1;<span class="comment">//d1为引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;p) d2;<span class="comment">//d2为指针的指针</span></span><br></pre></td></tr></table></figure>



<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; ++i &lt;&lt; endl; <span class="comment">//未定义的</span></span><br></pre></td></tr></table></figure>

<p>这里可能先++i再求值，结果为1 1，也可能求值，再++i，结果为0 1，所以避免出现此种代码。</p>
<p>只有&amp;&amp;、||、？：、，四种运算符有明确的求值顺序。</p>
<p>形如<code>f() + g() * h() + j()</code>，因为求值的顺序与优先级和结合律无关，所以如果函数内部改变了一些关联的参数，则无法预计</p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul>
<li>一元运算符大于二元运算符</li>
<li>%不允许运算对象为浮点类型</li>
<li>C++11规定无论正负一律向0取整</li>
</ul>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p><img src="C:\Users\28559\AppData\Roaming\Typora\typora-user-images\image-20211210152812002.png" alt="image-20211210152812002"></p>
<p>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值(short-circuit evaluation）</strong>。<br><strong>逻辑非运算符</strong></p>
<p>在对象前加！表示取反，如<code>!s.empty()</code>。</p>
<p><strong>关系运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哎哟!这个条件居然拿i&lt;j的布尔值结果和k比较!</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;j&lt;k)<span class="comment">//若k 大于1则为真!</span></span><br><span class="line"><span class="comment">//正确:当i小于j并且j小于k时条件为真</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j &amp;&amp; j&lt;k)&#123;<span class="comment">/* ...* / &#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算的结果是它的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</p>
<p>C++11允许使用花括号赋值</p>
<p>如<code>vector&lt;int&gt; v = &#123;0,5,3,4,8&#125;;</code></p>
<p><strong>赋值运算满足右结合律</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值运算符满足右结合律，这一点与其他二元运算符不太一样:</span></span><br><span class="line"><span class="keyword">int</span> ival,jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;		<span class="comment">//正确:都被赋值为0</span></span><br><span class="line"><span class="keyword">int</span> ival, *pval;		<span class="comment">// ival的类型是int; pval是指向int的指针</span></span><br><span class="line">ival = pval = <span class="number">0</span> ;		<span class="comment">//错误:不能把指针的值赋给int</span></span><br><span class="line">string sl,s2;</span><br><span class="line">sl = s2 = <span class="string">&quot;OK&quot;</span> ;		<span class="comment">//字符串字面值&quot;OK&quot;转换成string对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一种形式烦琐、容易出错的写法</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">get_value</span> () ;		<span class="comment">//得到第一个值</span></span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">42</span>)&#123;</span><br><span class="line">	<span class="comment">//其他处理·</span></span><br><span class="line">	i = <span class="built_in">get_value</span> ( );		<span class="comment">//得到剩下的值</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="comment">//更好的写法:条件部分表达得更加清晰</span></span><br><span class="line"><span class="keyword">while</span> ((i = <span class="built_in">get_value</span>())!= <span class="number">42</span>)&#123;	<span class="comment">//其他处理…..</span></span><br></pre></td></tr></table></figure>

<p><label stype = "color: red">切勿混淆”==”与“=”</label></p>
<h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>++和–是加一减一一种简介的书写，若非必须，建议养成写前置版本的习惯。因为后置版本会造成性能浪费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span> ();</span><br><span class="line"><span class="comment">//输出元素直至遇到第一个负值为止</span></span><br><span class="line"><span class="keyword">while</span> (pbeg != v.<span class="built_in">end</span> () &amp;&amp; *beg &gt;= <span class="number">0</span> )</span><br><span class="line">	cout&lt;&lt; *pbeg++ &lt;&lt; endl;<span class="comment">//输出当前值并将pbeg向前移动一个元素</span></span><br></pre></td></tr></table></figure>

<p><code>*pbeg++</code>等价于<code>*(pbeg++)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该循环的行为是未定义的!</span></span><br><span class="line"><span class="keyword">while</span> (beg != s.<span class="built_in">end</span> () &amp; &amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">	*beg = <span class="built_in">toupper</span> ( *beg++); <span class="comment">//错误:该赋值语句未定义</span></span><br></pre></td></tr></table></figure>

<p>如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>ptr-&gt;mem等价于(*ptr).mem；</p>
<p>因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没加括号，代码的含义就大不相同了。</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>cond ? expr1 : expr2;</p>
<p>此运算符只对expr1和expr2中的一个求值。</p>
<p><strong>嵌套运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span></span><br><span class="line">						  : (grade &lt; <span class="number">60</span>)?<span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span> ;</span><br></pre></td></tr></table></figure>

<p>条件运算符是满足右结合性质，意味着从右向左顺序组合，但嵌套最好不要超过两层。</p>
<p><em>解释一下左（右）结合律，举个例子，假设<del>是一个运算符，又有表达式a</del>b<del>c，如果</del>是左结合的，那么该表达式被解析为(a<del>b)</del>c，如果<del>是右结合的，那么该表达式将被解析为a</del>(b~c)。比如上表中三目运算符?:是从右向左结合的</em></p>
<p><strong>优先级</strong></p>
<p>该运算符优先级非常低，所以长表达式嵌套时最好加上括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; ( (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span> );	<span class="comment">// 输出pass或者fail</span></span><br><span class="line">cout &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;		<span class="comment">//输出1或者0!</span></span><br><span class="line">cout &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;		<span class="comment">//错误:试图比较cout和60</span></span><br></pre></td></tr></table></figure>



<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp; 			位与</span><br><span class="line">| 			位或</span><br><span class="line">^ 			位异或</span><br><span class="line">~ 			取反</span><br><span class="line">&gt;&gt; 			向右移</span><br><span class="line">&gt;&gt;&gt; 		无符号右移</span><br><span class="line">&lt;&lt; 			向左移</span><br></pre></td></tr></table></figure>

<p>关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型，小整型在使用位运算符时会自动提升至大整型。</p>
<p><strong>移位运算符</strong></p>
<p>左移运算符(&lt;&lt;)在右侧插入值为0的二进制位。右移运算符(&gt;&gt;)的行为则依赖于其左侧运算对象的类型:如果该运算对象是无符号类型,在左侧插入值为0的二进制位;如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。</p>
<p><strong>位求反运算符</strong></p>
<p>位求反运算符(~）将运算对象逐位求反后生成一个新值，将1置为0、将0置为1。char类型的运算对象首先提升成int类型，提升时运算对象原来的位保持不变，往高位添加0即可。因此在本例中，首先将bits提升成int类型，增加24个高位0，随后将提升后的值逐位求反。</p>
<p><strong>使用位运算符</strong></p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第三章</title>
    <url>/2021/12/08/C++%20Primer%20%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><p>​        第2章介绍的内置类型是由C++语言直接定义的。这些类型，比如数字和字符，体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，它们尚未直接实现到计算机硬件中。<br>​        本章将介绍两种最重要的标准库类型: string 和 vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型，和其他内置类型一样，<strong>数组的实现与硬件密切相关</strong>。因此相较于标准库类型string和 vector，数组在灵活性上稍显不足。</p>
<span id="more"></span>

<h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>有了 using声明就无须专门的前缀（形如std :）也能使用所需的名字。声明如下：<br><code>using namespace::name ;</code><br>例如：<code>using std::cin; using std::cout;</code></p>
<p>头文件不应包含using声明，以免产生名字的冲突。</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>使用前需包含</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>

<h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string sl;<span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line">string s2 = s1;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s1)</span></span>;<span class="comment">//与上面相同</span></span><br><span class="line">string s4 = <span class="string">&quot;hiya&quot;</span>;<span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>;<span class="comment">//与上相同</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span> )</span></span>;<span class="comment">//s4的内容是cccccccccc</span></span><br><span class="line">string s7 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);<span class="comment">//与上相同</span></span><br></pre></td></tr></table></figure>

<p><strong>直接初始化与拷贝初始化</strong></p>
<p>区分：使用等号的都是拷贝初始化，其余是直接初始化。</p>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><strong>读写string对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="function">nt <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	string s;<span class="comment">//空字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cin &gt;&gt; s;<span class="comment">//将string 对象读入s，遇到空白停止</span></span></span></span><br><span class="line"><span class="params"><span class="function">	cout &lt;&lt; s &lt;&lt;endl;<span class="comment">//输出s</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>输入过程中自动忽略开头空白，直到下一处空白，如：“   Hello World!  ”则只会输出”Hello”，输出结果没有任何空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string sl, s2;</span><br><span class="line">cin &gt;&gt; sl &gt;&gt; s2; <span class="comment">//把第一个输入读到s1中，第二个输入读到s2中</span></span><br><span class="line">cout&lt;&lt; s1 &lt;&lt; s2 &lt;&lt;endl;<span class="comment">//输出两个string对象</span></span><br></pre></td></tr></table></figure>

<p>这样输入上面的语句则会输出”HelloWorld!”。</p>
<p><strong>读取未知数量的string对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	string word;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; word)&#123;<span class="comment">//反复读取，直至到达文件末尾</span></span><br><span class="line">		cout &lt;&lt; word &lt;&lt; endl;<span class="comment">//逐个输出单词，每个单词后面紧跟一个换行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遇到文件结束符或非法输入就结束了</p>
<p><strong>getline读取一整行</strong></p>
<p>​    <strong>getline函数</strong>的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去（注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">    <span class="comment">//每次读入一整行，直至到达文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,line) )</span><br><span class="line">		cout&lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>string的empty和size操作</strong></p>
<ul>
<li><p>empty函数根据string对象是否为空返回对应的布尔值。</p>
</li>
<li><p>size函数返回string对象的长度，其类型为string::size_type类型，它是一个无符号类型的值，所以尽量避免size()和int混用。</p>
</li>
</ul>
<p><strong>比较string对象</strong></p>
<ul>
<li>两个string对象长度相同，所包含字符必须一模一样才算相等。</li>
<li>长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。</li>
<li>如果两个string 对象在某些对应的位置上不一致，则string对象比较的结果<br>其实是string对象中第一对相异字符比较的结果。</li>
</ul>
<p><strong>为string对象赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">st1</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span>, st2</span>;</span><br><span class="line">st1 = st2;</span><br></pre></td></tr></table></figure>

<p><strong>两个string对象相加</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello, &quot;</span>, s2 = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">string s3 = s1 + s2; <span class="comment">// s3 = &quot;hello, world\n&quot;</span></span><br><span class="line">s1 += s2; <span class="comment">//与上面等价</span></span><br></pre></td></tr></table></figure>

<p><strong>字面值和string对象相加</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span> + s2; <span class="comment">//可以，依次运算中至少保证有一个string对象</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span><span class="comment">//错误，不允许两个字面值直接相加</span></span><br></pre></td></tr></table></figure>



<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>函数名称                                   返回值<br>isalnum()        如果参数是字母数字，即字母或者数字，函数返回true</p>
<p>isalpha()         如果参数是字母，函数返回true</p>
<p>iscntrl()           如果参数是控制字符，函数返回true</p>
<p>isdigit()           如果参数是数字（0－9），函数返回true<br>isgraph()        如果参数是除空格之外的打印字符，函数返回true</p>
<p>islower()         如果参数是小写字母，函数返回true</p>
<p>isprint()          如果参数是打印字符（包括空格），函数返回true</p>
<p>ispunct()        如果参数是标点符号，函数返回true</p>
<p>isspace()        如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回true</p>
<p>isupper()        如果参数是大写字母，函数返回true</p>
<p>isxdigit()         如果参数是十六进制数字，即0－9、a－f、A－F，函数返回true</p>
<p>tolower()        如果参数是大写字符，返回其小写，否则返回该参数</p>
<p>toupper()       如果参数是小写字符，返回其大写，否则返回该参数</p>
<p>C++版本的标准库头文件为形如cname，而C头文件形如name.h，这里建议使用C++版本。</p>
<p><strong>for处理每个字符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span> <span class="params">( <span class="string">&quot;some string&quot;</span> )</span></span>;</span><br><span class="line"><span class="comment">//每行输出str中的一个字符。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)  <span class="comment">//对于str中的每个字符</span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl; <span class="comment">//输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>如果需要改变str中的字符，则在c前面加上&amp;。</p>
<p><strong>处理部分字符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index =<span class="number">0</span>;index != s.<span class="built_in">size</span> ( ) &amp;&amp; !<span class="built_in">isspace</span>(s [index]); ++index)</span><br><span class="line">	s[index] = <span class="built_in">toupper</span>(s[index]);<span class="comment">//将当前字符改成大写形式</span></span><br></pre></td></tr></table></figure>

<p>这里主要注意一点，index必须大于等于0，小于size()。</p>
<h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>

<p>vector是一个<strong>类模板</strong>，模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化（instantiation)**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<p>例如<code>vector&lt;int&gt; ivec; vector&lt;Sales_item&gt; Sales_vec;</code></p>
<p><label style = "color::red">vector模板不是类型，包含元素类型的vector才是，如<code>vector&lt;int&gt;</code>,且不可以包含引用</label></p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v1				v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span> <span class="params">(v1)</span>			v2中包含有v1所有元素的副本</span></span><br><span class="line"><span class="function">vector&lt;T&gt; v2 </span>= v1			等价于<span class="built_in">v2</span>(v1)，v2中包含有v1所有元素的副本</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span> <span class="params">(n,val)</span>		v3包含了n个重复的元素，每个元素的值都是val</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span> <span class="params">(n)</span>			v4包含了n个重复地执行了值初始化的对象</span></span><br><span class="line"><span class="function">vector&lt;T&gt; v5</span>&#123;a,b,c...&#125;  	v5包含了初始值个数的元素，每个元素被赋予相应的初始值</span><br><span class="line">vector&lt;T&gt; v5 =&#123;a,b,c...&#125; 	等价于v5&#123;a,b,c...&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造（类型必须相同）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;				<span class="comment">//初始状态为空</span></span><br><span class="line"><span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec2</span> <span class="params">(ivec)</span></span>;		<span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec3 = ivec;		<span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(ivec2)</span></span>;		<span class="comment">//错误: svec的元素是string对象，不是int</span></span><br></pre></td></tr></table></figure>

<p><strong>列表初始化vector对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; articles = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span> , <span class="string">&quot;the&quot;</span> &#125;;</span><br><span class="line">vector&lt;string&gt; v1 &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125; ; 	<span class="comment">//列表初始化</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v2</span><span class="params">( <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>)</span> </span>; 		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>值初始化</strong></p>
<p>使用<code>vector&lt;T&gt; v(n);</code>需注意 T 支不支持默认初始化。</p>
<p><code>vector&lt;int&gt; vi = 10;//错误:必须使用直接初始化的形式指定向量大小</code></p>
<p>注意区分花括号和圆括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span> </span>;		<span class="comment">// v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;; 		<span class="comment">// v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>，<span class="number">1</span>)</span></span>;		<span class="comment">// v3有10个元素，每个的值都是1</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4 &#123;<span class="number">10</span>,<span class="number">1</span>&#125;; 		 <span class="comment">// v4有2个元素，值分别是10和1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v5 &#123; <span class="string">&quot;hi&quot;</span>&#125;;<span class="comment">//列表初始化:v5有一个元素</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v6</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;<span class="comment">//错误:不能使用字符串字面值构建vector对象</span></span><br><span class="line">vector&lt;string&gt; V7 &#123;<span class="number">10</span>&#125;;<span class="comment">// v7有10个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span> &#125;;<span class="comment">// v8有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，只有v5为列表初始化，使用花括号时，若提供的对象不可以作为对象的初始值，则编译器会尝试默认值初始化。</p>
<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;<span class="comment">//空vector对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">	v2.<span class="built_in">push_back</span>(i); <span class="comment">//依次把整数值放到v2尾端//循环结束后v2有100个元素，值从0到99</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">使用范围for循环遍历容器时，不得改变vector容器的大小。</label></p>
<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v.<span class="built_in">empty</span> () 				<span class="comment">//如果v不含有任何元素，返回真;否则返回假</span></span><br><span class="line">v.<span class="built_in">size</span> () 				<span class="comment">//返回v中元素的个数</span></span><br><span class="line">v.<span class="built_in">push_back</span> (t) 		<span class="comment">//向v的尾端添加一个值为t的元素</span></span><br><span class="line">v [n] 					<span class="comment">//返回v中第n个位置上元素的引用</span></span><br><span class="line">v1 = v2					<span class="comment">//用v2中元素的铂贝替换v1中的元素</span></span><br><span class="line">vl = &#123;a,b,c... &#125;		<span class="comment">//用列表中元素的拷贝替换v1中的元素</span></span><br><span class="line">vl == v2 				<span class="comment">//v1和 v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2</span><br><span class="line">&lt;,&lt;=,&gt;,&gt;= 				<span class="comment">//顾名思义，以字典顺序进行比较</span></span><br></pre></td></tr></table></figure>

<p>vector容器的size类型一定要包含元素类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">veetor&lt;<span class="keyword">int</span>&gt;: :size_type		<span class="comment">//正确</span></span><br><span class="line">vector::size type			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>vector容器的比较大小参照string。</p>
<p><label style = "color::red">vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。</label></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由编译器决定b和e的类型</span></span><br><span class="line"><span class="comment">// b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>(); <span class="comment">//b 和e的类型相同</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">容器为空时，begin和end都是返回的是同一个迭代器，都是尾后迭代器</label></p>
<p><strong>迭代器运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* iter				<span class="comment">//返回迭代器iter所指兀素的引用</span></span><br><span class="line">iter-&gt;mem			<span class="comment">//解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</span></span><br><span class="line">++iter			 	<span class="comment">//令iter指示容器中的下一个元素</span></span><br><span class="line">--iter				<span class="comment">//令iter指示容器中的上一个元素</span></span><br><span class="line">iter1 == iter2		<span class="comment">//判断两个迭代器是否相等（不相等)，如果两个迭代器指示的是同一个元</span></span><br><span class="line">iter1 != iter2		<span class="comment">//素或者它们是同一个容器的尾后迭代器，则相等;反之，不相等</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器的移动</strong></p>
<p>采用++或–操作改变其位置</p>
<p><label style = "color::red">end返回的迭代器不代表莫格元素，所以不能增减，解引用操作</label></p>
<p>迭代器用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依次处理s 的字符直至我们处理完全部字符或者遇到空白</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span> ( ) &amp;&amp; !<span class="built_in">isspace</span> (*it); ++it)</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it); <span class="comment">//将当前字符改成大写形式</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; : :iterator it; <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string: :iterator it2;		<span class="comment">// it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; : : const_iterator it3; <span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line">string : :const_iterator it4;  		<span class="comment">//it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">如果容器是常量，则只能使用const迭代器</label></p>
<p><strong>begin和end</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> itl = v.<span class="built_in">begin</span>();	<span class="comment">//it1的类型是vector&lt;int&gt; : :iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();	<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();	<span class="comment">//it3的类型是vector&lt;int&gt;::const iterator</span></span><br></pre></td></tr></table></figure>

<p>如果对象只需读操作而无须写操作的话最好使用常量类型(比如 const_iterator)。为了便于专门得到const_iterator类型的返回值,C++11新标准引入了两个新函数,分别是cbegin和cend，无论对象是什么，返回值都是const_iterator。</p>
<p><strong>结合解引用和成员访问操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">( *it) .<span class="built_in">empty</span>()	<span class="comment">//解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.<span class="built_in">empty</span>()		<span class="comment">//错误:试图访问it的名为empty的成员，但it是个迭代器，没有empty成员</span></span><br><span class="line">it-&gt;<span class="built_in">empty</span>()		<span class="comment">//此操作与上面操作相同</span></span><br></pre></td></tr></table></figure>

<p>为了简化上述表达式，C++语言定义了箭头运算符（-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it-&gt;mem和(*it) .mem表达的意思相同。</p>
<p><strong>迭代器失效</strong></p>
<p><label style = "color::red">谨记,但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</label></p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器可以进行+- 等运算使它一次移动多个位置，大于小于操作则判断迭代器的相对位置，但必须在同一个容器里。</p>
<p>迭代器相减得到所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type 的带符号整型数。string 和vector都定义了difference_type ，因为这个距离可正可负，所以difference_type是带符号类型的。</p>
<p><strong>使用迭代器运算</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// text必须是有序的</span></span><br><span class="line"><span class="comment">// beg 和end表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span> ( ) , end = text.<span class="built_in">end</span> ( ) ;</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span> () + (end - beg)/<span class="number">2</span>; <span class="comment">// 初始状态下的中间点</span></span><br><span class="line"><span class="comment">//当还有元素尚未检查并且我们还没有找到sought时执行循环</span></span><br><span class="line"><span class="keyword">while</span> (mid != end &amp; &amp; *mid != sought) &#123;</span><br><span class="line">	<span class="keyword">if</span> (sought&lt; *mid)	<span class="comment">//我们要找的元素在前半部分吗?</span></span><br><span class="line">		end = mid;		<span class="comment">//如果是，调整搜索范围使得忽略掉后半部分</span></span><br><span class="line">	<span class="keyword">else</span>				<span class="comment">//我们要找的元素在后半部分</span></span><br><span class="line">		beg = mid + <span class="number">1</span>;	<span class="comment">//在mid之后寻找</span></span><br><span class="line">	mid = beg + (end - beg)/ <span class="number">2</span>;				<span class="comment">//新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与vector对比：</p>
<ul>
<li>数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。</li>
<li>与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</li>
</ul>
<h3 id="定义和初始化-1"><a href="#定义和初始化-1" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;			<span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;	<span class="comment">//常量表达式，关于constexpr，参见2.4.4节（第59页)</span></span><br><span class="line"><span class="keyword">int</span> arr [<span class="number">10</span>] ;				<span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *parr [sz];				<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line">string bad [cnt ] ;			<span class="comment">//错误:cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>() ];	<span class="comment">// 当get_size是constexpr时正确;否则错误</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">和内置类型的变量一样,如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</label></p>
<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
<p><strong>显示初始化数组元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> ia1[sz] = &#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>];				<span class="comment">//含有3个元素的数组,元素值分别是0，1，2</span></span><br><span class="line"><span class="keyword">int</span> a2[]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;					<span class="comment">//若不指定维度，则根据初始值计算，这里是维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>&#125;;				<span class="comment">//等价于a3[] =&#123;0,1，2，0,0&#125;</span></span><br><span class="line">string a4 [<span class="number">3</span>] = &#123; <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span> &#125; ;	<span class="comment">//等价于a4 [] = &#123; &quot;hi&quot;，&quot;bye&quot;，&quot;&quot; )</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;					<span class="comment">//错误:初始值过多</span></span><br></pre></td></tr></table></figure>

<p><strong>字符数组的特殊性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> al[]= &#123;<span class="string">&#x27;c&#x27;</span> , <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;		<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[]= &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;+‘， ’+‘， ’\0‘&#125;;	//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="string">char a3[]= &quot;C++&quot;;					//自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="string">const char a4 [6]=&quot;Daniel&quot;;			//错误:没有空间可存放空字符!</span></span><br></pre></td></tr></table></figure>

<p><label style = "color::red">字符串结尾还有一个空字符，也会占用空间，和被拷贝。</label></p>
<p><strong>拷贝与赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>，<span class="number">2</span>&#125;;			   <span class="comment">//含有3个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> a2[]= a;					<span class="comment">//错误:不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;							<span class="comment">//错误:不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>

<p><em>一些编译器支持数组的赋值,这就是所谓的编译器扩展（compiler extension)。但一般来说,最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</em></p>
<p><strong>复杂数组的声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs [<span class="number">10</span>] ;			<span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs [<span class="number">10</span>]=<span class="comment">/* ?*/</span>;		<span class="comment">//错误:不存在引用的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*Parray) [<span class="number">10</span>]= &amp;arr;	<span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;arrRef)[<span class="number">10</span>] = arr;	<span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> * (&amp;arry) [<span class="number">10</span>] = ptrs;  <span class="comment">//arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure>

<p>这里重点在于顺序，</p>
<ul>
<li>对于无括号情况，从右往左，例如ptrs，我们先看到的是[10]，表明这是一个数组。</li>
<li>对于右括号，从内向外，例如parray，先看到是一个指针，表明是一个指针，它指向了数组。</li>
<li>对于arry，先从内向外，再从右往左。</li>
</ul>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库 stddef.h头文件的C++语言版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)		<span class="comment">//对于scores中的每个计数值</span></span><br><span class="line">	cout&lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;			<span class="comment">//输出当前的计数值</span></span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>在大多数表达式中,使用数组类型的对象其实是使用一个指向该数组首元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;	<span class="comment">// ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;						<span class="comment">// ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line">ia2 =<span class="number">42</span>;							<span class="comment">//错误:ia2是一个指针，不能用int值给指针赋值</span></span><br><span class="line"><span class="comment">//尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式:</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span> <span class="params">( &amp;ia[<span class="number">0</span>])</span></span>;					<span class="comment">//显然ia2的类型是int*</span></span><br><span class="line"><span class="comment">//当使用decltype关键字时上述转换不会发生，decltype (ia)返回的类型是由10个整数构成的数组:</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; ;</span><br><span class="line">ia3 = p;							<span class="comment">//错误:不能用整型指针给数组赋值</span></span><br><span class="line">ia3 [<span class="number">4</span>] = i;					 	<span class="comment">//正确:把i的值赋给ia3的一个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>指针也是迭代器</strong></p>
<p>指针可以做与迭代器同样的操作（我认为本质上没有区别），尾指针可以通过<code>int *e = &amp;arr[arr.len];</code>的方法获取。</p>
<p><strong>标准函数begin和end</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[ ] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>); 	<span class="comment">//ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span> (ia) ;				<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="keyword">int</span> * last = <span class="built_in">end</span> (ia) ;				<span class="comment">//指向arr尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>

<p><em>C++11新标准引入了两个名为begin和 end 的函数。这两个函数与容器中的两个同名成员，功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数:</em></p>
<p><label style = "color::red">一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意,尾后指针不能执行解引用和递增操作。</label></p>
<p><strong>指针运算</strong></p>
<p>这里与容器中的迭代器除了两个指针相减是ptrdiff_t类型基本一致，该类型也是带符号类型。</p>
<p><em>指针运算同样适用于空指针和所指对象并非数组的指针。在后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span> last1 = *(ia + <span class="number">4</span>);		<span class="comment">//为ia[4]的值</span></span><br><span class="line"><span class="keyword">int</span> last2 = *ia +<span class="number">4</span>			<span class="comment">//含义完全不同，</span></span><br></pre></td></tr></table></figure>

<p><strong>下标和指针</strong></p>
<p>只要指针指向的是数组中的元素(或者数组中尾元素的下一位置)，都可以执行下标运算:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];				<span class="comment">// ia转换成指向数组首元素的指针ll ia [2]得到(ia + 2)所指的元素</span></span><br><span class="line"><span class="keyword">int</span> *p = ia;				<span class="comment">// p指向ia的首元素</span></span><br><span class="line">i =*(p + <span class="number">2</span>);				<span class="comment">//价于i = ia[2]</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;ia[ <span class="number">2</span>] ;			<span class="comment">// p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];				<span class="comment">// p[1]等价于*(p + 1)，就是ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k= p[<span class="number">-2</span>] ;				<span class="comment">// p[-2]是ia [ 0]表示的那个元素</span></span><br></pre></td></tr></table></figure>

<p>数组下标类型是带符号类型，这与vector和string不一致。</p>
<p><strong>C风格字符串</strong></p>
<p>风险大，不推荐使用，故暂时跳过</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。</p>
<p><strong>多维数组初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[ <span class="number">3</span>][<span class="number">4</span>]= &#123;			 <span class="comment">//三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">	&#123; <span class="number">0</span>,<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> &#125; ,			<span class="comment">//第1行的初始值</span></span><br><span class="line">	&#123; <span class="number">4</span>,<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>),				<span class="comment">//第2行的初始值</span></span><br><span class="line">	&#123; <span class="number">8</span>,<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>&#125;			<span class="comment">//第3行的初始值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//没有标识每行的花括号，与之前的初始化语句是等价的</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line"><span class="comment">//显式地初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;O &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125;&#125;;</span><br><span class="line"><span class="comment">//显式地初始化第1行，其他元素执行值初始化0</span></span><br><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">3</span>，<span class="number">6</span>，<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>多维数组的下标引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用arr的首元素为ia最后一行的最后一个元素赋值</span></span><br><span class="line">ia [<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];			<span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure>

<p><strong>for循环遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)				<span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row)&#123;			<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">		col = cnt;					<span class="comment">//将下一个值赋给该元素</span></span><br><span class="line">		++cnt;						<span class="comment">//将cnt 加1</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><label style = "color::red">要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</label></p>
<p><strong>指针和多维数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>*ip[<span class="number">4</span>];			<span class="comment">//整型指针的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*ip)[<span class="number">4</span>];		<span class="comment">//指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>声明指针注意区分以上区别，C++ 11推荐使用auto或者decltype也可避免加指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia [ <span class="number">3</span>][<span class="number">4</span>];			<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(*p)[ <span class="number">4</span>]= ia;		<span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p= &amp;ia [<span class="number">2</span>];				<span class="comment">//p指向ia的尾元素</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="comment">// p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)&#123;	</span><br><span class="line">	<span class="comment">// q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">		cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>auto p = begin(ia)</code>以可以更加简洁。</p>
<p><strong>类型别名简化多维数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span> [<span class="number">4</span>];	<span class="comment">//新标准下类型别名的声明，参见2.5.1节（第60页)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];	<span class="comment">//等价的typedef声明，参见2.5.1节（第60 页)</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="keyword">for</span> (int_array *p = ia; p != ia + <span class="number">3</span>; ++p)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> *q= *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">		cout&lt;&lt; *q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将类型“4个整数组成的数组”命名为 int_array，用类型名int_array定义外层循环的控制变量让程序显得简洁明了。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第二章</title>
    <url>/2021/12/08/C++Primer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><p>​    内置类型包括算术类型和空类型</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>1、算术类型分为两类：整型（包括字符和布尔类型）和浮点型。</p>
<p>2、布尔类型（bool）：取值是真或假。</p>
<span id="more"></span>

<p>3、字符类型（char）：一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值，即一个char的大小和一个机器字节一样（8位）。</p>
<p>4、短整型（short）：16位</p>
<p>5、整型（int）：16位</p>
<p>6、长整型（long）；32位</p>
<p>7、长整型（long long）：64位</p>
<p>8、单精度浮点类型（float）：32位，保留6位有效数字</p>
<p>9、双精度浮点类型（double）：64位，保留10位有效数字</p>
<p>10、扩展精度浮点类型（long double）：96或128位，保留10位有效数字</p>
<h3 id="带符号与无符号类型"><a href="#带符号与无符号类型" class="headerlink" title="带符号与无符号类型"></a>带符号与无符号类型</h3><p>​        除去<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</a>和扩展的字符型之外，其他整型可以划分为<strong>带符号的（signed）</strong>  和 <strong>无符号类型（unsigned）</strong> 两种，带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。</p>
<p><label style="color:red">只有整型才有符号型和无符号型之分，浮点型无此区别</label></p>
<p>​        类型int 、short 、 long 和 long long 都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，</p>
<p>例如 unsigned long 。类型 unsigned int 可以缩写为 unsigned 。</p>
<p><strong>特殊的char</strong></p>
<p>​        与其他整型不同，字符型被分为了三种：char 、 signed char 和 unsigned char。特别注意的是：类型 cahr 和 类型 signed char 并不一样。尽管字符型有三种，但是字符型的表现形式却只有两种： 带符号和无符号的。类型char实际上会表现为上述两种形式的一种 ，具体是哪种由编译器决定。</p>
<p>​        无符号类型中所有比特都用来存储值，例如，8比特的unsigned char 可以表示0至255区间内的值。</p>
<p>​        但是约定了在表示范围内正值和负值的最应该平衡。因此，8比特的signed char 理论上应该可以表示-127至127区间内的值，大多数现代计算器实际的表示范围定位 -128 至 127。可以理解为：因为把0划分到了无符号类型，所以0+127 = 128.</p>
<p>看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>;</span><br></pre></td></tr></table></figure>

<p>（均假设cahr占8比特）这两个语句的运行结果是：</p>
<p>c的值为255，</p>
<p>c2的值是未定义的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为o则结果为false,否则结果为true。</li>
<li>当我们把一个布尔值赋给非布尔类型时，初始值为false 则结果为o，初始值为true则结果为1。</li>
<li>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</li>
<li>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li>
</ul>
<p><strong>结论：</strong></p>
<p>1.当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char 可以表示0至255区间内的值，如果我们赋了一个区间意外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char 所得的结果是255.</p>
<p>2.当我们赋给符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>​        <strong>字面值常量</strong>（literal constant），“字面值”是指只能用它的值称呼它，“常量”是指其值不能修改。每个字面值都有相应的类型，3.14是double型，2是int型。只有内置类型存在字面值。</p>
<p><strong>1.</strong> <strong>整形字面值规则</strong></p>
<p>整形字面值常量可以用十进制、八进制、十六进制表示。</p>
<p>20    // dec</p>
<p>024   // oct（以0开头）</p>
<p>0x14  // hex（以0x或0X开头）</p>
<p>整形字面值常量的类型默认为int或long，其值适合int就是int类型，比int大就是long类型。在数值后加L或l（小写字母l容易与数字1混淆，建议用L）可以指定为long，加U或u指定为unsigned类型，加UL或LU定义为unsigned long类型。没有short类型的字面值常量。</p>
<p><strong>2.</strong> <strong>浮点字面值规则</strong></p>
<p>可以用十进制或科学计数法（指数用E或e）表示，默认为double，在数值后加F或f表示单精度，加L或l表示扩展精度。</p>
<p>3.14159F      .001f    12.345L     0.</p>
<p>3.14159E0f     1E-3F   1.2345E1L   0e0</p>
<p><strong>3.</strong> <strong>布尔字面值和字符字面值</strong></p>
<p>布尔字面值：true、false。字符字面值由单引号定义：’2’（char类型）、L’a’（wchar_t类型）。</p>
<p><strong>4.</strong> <strong>非打印字符和转义序列</strong></p>
<p>非打印字符和特殊字符（如单引号、双引号、反斜杠）都要写为转义字符（以反斜杠开头）。</p>
<p><img src="https://s2.loli.net/2021/12/07/vCu3TR6SWiftqVL.png" alt="image.png"></p>
<p>无论是普通字符，还是非打印字符和特殊字符，都可以表示为“通用转义字符”。如八进制形式的“\7（响铃符）、\12（换行符）、\0（空字符）、\62（数字2）”（可以对照ASCII码表看一下）。“通用转义字符”也可以用十六进制表示（\xddd）。</p>
<p><strong>5.</strong> <strong>字符串字面值</strong></p>
<p>需要用双引号括起来，非打印字符写要转义，编译器会自动在末尾添加一个空字符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">“hello c++”       <span class="comment">// simple string literal</span></span><br><span class="line">“”                <span class="comment">// empty string literal</span></span><br><span class="line">“\n hello \t c++” <span class="comment">// string literal using newlines and tabs</span></span><br><span class="line">L”hello c++”      <span class="comment">// a wide string literal</span></span><br></pre></td></tr></table></figure>

<p><strong>6.</strong> <strong>字符串字面值的连接</strong></p>
<p>两个相邻的，仅由空格、制表符、换行符分隔的字符串字面值，将连接在一起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; “a multi-line “ “string literal “</span><br><span class="line">            “<span class="keyword">using</span> concatenation”</span><br><span class="line">          &lt;&lt; std::endl</span><br></pre></td></tr></table></figure>

<p>输出：<strong>a multi-line string literal using concatenation</strong></p>
<p><strong>7</strong> <strong>多行字面值</strong></p>
<p>可以使用反斜杠，将多行内容当作同一行处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multiline string literal``std::cout &lt;&lt; “a multi-line \``string literal \``using` `a backslash”``   ``&lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure>

<p>反斜杠必须是行尾字符，后面不能有注释或空格。后继行行首的任何空格和制表符都是字符串字面值的一部分。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>​        变量类型决定所占空间的大小的布局方式以及所能参与的运算，变量与对象可互换。</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>​        命名空间 : : 类型说明符 空格 一个或多个变量名（中间以逗号分隔，以分号结束），可同时附初始值。</p>
<p><label style="color:red">初始化不是赋值,初始化的含义是创建变量时赋予其一个初始值,而赋值的含义是把对象的当前值擦除,而以一个新值来替代。</label></p>
<p><strong>列表初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> unit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unit = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> unit&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上效相同，但2、3无法转换类型、因为存在丢失信息风险。</p>
<p><strong>默认初始化</strong></p>
<p>​        定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化,则其值由类确定。</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>​        由于C++支持分离式编译，一个变量可被多个文件使用，则可使用变量名前加extern</p>
<p><code>extern int i</code></p>
<p>若给extern变量赋予初始值，则关键字失效。</p>
<p><label style="color:red">变量能且只能被定义一次，但可以被多次声明</label></p>
<p><strong>静态类型</strong></p>
<p>​    ·    <em>C+是一种静态类型（statically typed)语言,其含义是在编译阶段检查类型。其中,检查类型的过程称为类型检查(type checking)。<br>我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算,如果试图执行类型不支持的运算,编译器将报错并且不会生成可执行文件。</em></p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>​        用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>**全局作用域( global scope)**。一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用。</p>
<p>**块作用域(block scope)**。只在自己所声明区域可用。</p>
<p><label style="color:red">当局部变量与全局变量相同，局部变量会覆盖全局变量。不建议使用相同名称</label></p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>​        一条声明语句由一个基本数据类型(base type）和紧随其后的一个声明符( declarator）（变量名）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>​        引用并非对象，它只是已经存在对象的另一个名字，它出生就必须和初始值绑在一起，永不分离！</p>
<p><strong>引用的定义</strong></p>
<p><code>int i = 1024; int &amp;i1 = i;</code></p>
<p><label style="color:red">引用的初始值必须是像<strong>匹配</strong>的<strong>对象</strong></label></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>​        与引用类似，指针也实现了对其他对象的<strong>间接访问</strong>。然而指针与引用的不同点如下</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li>
<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
<p><strong>指针的定义</strong></p>
<p><code>int i = 1024; int *p = i;</code></p>
<p><label style="color:red">因为引用不是对象，所以不可以定义指向引用</label></p>
<p><strong>指针值</strong></p>
<p>指针的值（即地址）应属下列4种状态之一:</p>
<ul>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ul>
<p>使用解引用符*可访问所指对象，仅适用于状态1。</p>
<p><label style="color:red">无效指针不允许拷贝或访问，2、3指针虽然有效，但仍不允许访问</label></p>
<p><strong>空指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p4 = z;    </span><br></pre></td></tr></table></figure>

<p>p1，p2，p3都定义了一个空指针，但p4并不是空指针。</p>
<p><label style="color:red">建议初始化所有的指针</label></p>
<p><strong>赋值和指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="number">0</span>;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line">p = p1;</span><br></pre></td></tr></table></figure>

<p>赋值改变的永远是等号左侧的对象。则第4行为改指向对象，第5行改指针。</p>
<p><em><em>void</em>  指针</em>*</p>
<p>​        它可以指向任意类型，但也无法进行大部分操作，如输入、输出、赋给另一个void* 指针且不能直接操作所指对象。以它的视角，它只知道自己指向了一块内存空间。</p>
<p><strong>指向指针的指针</strong></p>
<p>​        <code>int *p1 = nullptr; int **p2 = p1;</code></p>
<p><strong>指向指针的引用</strong></p>
<p><code>        int *p = nullptr; int *&amp;r = p;</code></p>
<p>要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针，则r为p的别名。</p>
<p>思考：既然有指向指针的指针，那么有引用的引用吗？</p>
<p>答案：[C++ 是否能够定义引用的引用？]zhihu.com/question/28023545</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p><code>const int i = 520;</code></p>
<p>这样定义一个变量后，任何试图改变i的值的操作都会报错，且const必须附予初始值。</p>
<p><code>int j  = i;</code></p>
<p>i的常量特征仅仅只在执行改变i的才会发挥作用。仍可进行拷贝，运算等，一旦拷贝完成，新对象与原来的对象没什么关系了。</p>
<p><label style="color:red">在多个文件之间共享const对象，必须在变量定义前添加extern，因为我们只需要在一个文件中定义，而在其他文件中声明并使用</label></p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>把引用绑定到const对象上，称为对<strong>常量的引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化和对const的引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ci = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> &amp;r1 = ci;</span><br><span class="line"><span class="keyword">const</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> &amp;r3 = r1*<span class="number">2</span>; <span class="comment">//虽然不可以定义引用的引用但是，此句只是引用了48这个常量而已</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">//此句错误，r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li><p><label style="color:red">const可以引用const或普通变量，但不加const去引用const是不允许的</label></p>
</li>
<li><p>对于const引用一个非const对象，书中解释是可以绑定，但不允许通过此引用去修改它的值。这里我的理解是，既然不能通过自身修改，也能通过其他途径修改，那么他们就没有任何联系了，所以我理解为这里const仅仅只是引用了该对象的值而已。所以解释r4的错误应该是：r4引用了一个常量。</p>
</li>
</ul>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针(pointer to const)**不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针:</p>
<p><label style="color:red">所谓指向常量的指针或引用，不过是指针或引用的“自以为是”罢了，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值</label></p>
<p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针(const pointer)*<em>必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址）就不能再改变了。把</em>放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值:</p>
<p><label style="color:red">总结： 指向常量的指针与常量指针一个是</label></p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>对于一般变量而言没有顶层const和底层const区别，但一般算作顶层const。对于符合变量却有不同。</p>
<p>区别：</p>
<ul>
<li><strong>指向常量的指针</strong>：代表 <strong>不能改变其指向内容</strong>的指针。声明时const可以放在类型名前后都可，拿int类型来说，声明时：const int和int const 是等价的。声明指向常量的指针也就是 <strong>底层const</strong></li>
<li><strong>指针常量</strong>：代表指针本身是常量，声明时必须初始化，之后<strong>它存储的地址值就不能再改变</strong>。声明时const必须放在指针符号<em>后面，即：</em>const 。声明常量指针就是<strong>顶层const</strong></li>
<li>顶层const和底层const很简单， 一个指针本身添加const限定符就是顶层const，而指针所指的对象添加const限定符就是底层const。</li>
</ul>
<p>作用：</p>
<ul>
<li><p>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const。也就是说，你只要能正确区分顶层const和底层const，你就能避免这样的赋值错误。</p>
</li>
<li><p>使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。</p>
</li>
</ul>
<p>[练习一下，const int <em>const</em>const* pppi 是顶层const还是底层const？</p>
<p>答案当然是底层const，因为int前面const限定符，而最后一个*后面没有const限定符。看最后一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="comment">//int * pi = &amp;a;  //错误，&amp;a是底层const，不能赋值给非底层const </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pi = &amp;a; <span class="comment">//正确，&amp;a是底层const，可以赋值给底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> *<span class="keyword">const</span> ppi = &amp;pi  <span class="comment">//即是底层const，也是顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> *<span class="keyword">const</span> *pppi = &amp;ppi; <span class="comment">//底层const</span></span><br></pre></td></tr></table></figure>

<p>[参考原文]<a href="https://blog.csdn.net/qq_19528953/article/details/50922303">(18条消息) C++的顶层const和底层const的理解_冬之晓-CSDN博客_顶层const和底层const</a></p>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p><strong>常量表达式(const expression）</strong>是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 const对象也是常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ci = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> r = ci;<span class="comment">//这里并不属于常量表达式</span></span><br></pre></td></tr></table></figure>

<p><strong>constrxpr变量</strong>（C++ 11）</p>
<p>将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> li = mf + <span class="number">1</span>;<span class="comment">//这些都是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();<span class="comment">//只有当size是一个constexpr函数才是正确的声明</span></span><br></pre></td></tr></table></figure>

<p><label style="color:red">如果认定变量是一个常量表达式，就把它声明称constexpr类型。</label></p>
<p><strong>字面值类型</strong></p>
<ul>
<li><p>算数类型、引用、指针都属于字面值类型。</p>
</li>
<li><p>自定义类、IO库、string类型不属于字面值类型。</p>
</li>
</ul>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者o,或者是存储于某个固定地址中的对象。</p>
<ul>
<li><p>函数体内定义的变量一般来说并非存放在固定地址中,因此constexpr指针不能指向这样的变量。</p>
</li>
<li><p>相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化 constexpr指针。</p>
</li>
</ul>
<p>允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr 指针也能指向这样的变量。</p>
<p><strong>指针和constptr</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是指向常量整数的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是指向整数的常量指针</span></span><br></pre></td></tr></table></figure>



<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>它是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">//wage是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;<span class="comment">//base是double的同义词、p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sale_item;<span class="comment">//C++ 11中一种新的方法，效果一样</span></span><br></pre></td></tr></table></figure>

<p><strong>指针、常量和类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pst;  <span class="comment">//这里把char*看作一个整体，则pst替代的是char*</span></span><br><span class="line"><span class="keyword">const</span> pst cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pst *ps;<span class="comment">//ps是一个指针，指向char的常量指针。就等于const char **ps</span></span><br></pre></td></tr></table></figure>

<p>这里比较绕，首先pst是char*的别名，先不论pst看第二行代码，可知cstr是一个不能改变的值，再用pst替换这个值，就是不能改变指向char的指针。再不论pst看第三行，ps是一个指向常量的指针，用pst替换掉这个量，就是一个指向char的常量指针。</p>
<h3 id="auto类型说明符（C-11）"><a href="#auto类型说明符（C-11）" class="headerlink" title="auto类型说明符（C++ 11）"></a>auto类型说明符（C++ 11）</h3><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如 double)不同，auto 让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;<span class="comment">//类型一致可以一起定义</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//错误若类型不一致不可一起定义</span></span><br></pre></td></tr></table></figure>

<p><strong>符合类型’常量和auto</strong></p>
<ul>
<li>当引用被当作初始值，参与的是引用的对象</li>
<li>auto一般会忽略掉顶层const，同时底层const会保留下来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">//b为整数（顶层const忽略）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">//c为整数（一样忽略顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;  <span class="comment">//d为指向整形的指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">//e是指向整数常量的指针（这里属于底层const，保留）</span></span><br><span class="line"><span class="comment">//如果需要auto是顶层const则可以</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;<span class="comment">//推演为int，但f为const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;<span class="comment">//推演为int，可定义引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;<span class="comment">//非常量引用不可以绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;<span class="comment">//常量引用可以绑定字面值</span></span><br></pre></td></tr></table></figure>



<h3 id="decltype类型指示符（C-11）"><a href="#decltype类型指示符（C-11）" class="headerlink" title="decltype类型指示符（C++ 11）"></a>decltype类型指示符（C++ 11）</h3><p>它的作用是选择并返回操作数的数据类型，此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p>
<p><code>decltype(f()) sum = x;//sum的类型就是函数f返回的类型</code></p>
<p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢?就是假如f被调用的话将会返回的那个类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，则y绑定了x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//z类型是const int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>decltype和引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;<span class="comment">//正确，加法得到的结果是int，因此b为int类型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p);<span class="comment">//错误，解引用得到的是int&amp;，而非int，需要初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(r) c;<span class="comment">//错误，这里没有用加法，得到的是引用类型，需初始化</span></span><br></pre></td></tr></table></figure>

<p>使用+0的操作可以避免变成引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;<span class="comment">//d为引用</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;<span class="comment">//为int</span></span><br></pre></td></tr></table></figure>

<p><label style="color:red">切记:decltype ((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当 variable本身就是一个引用时才是引用。</label></p>
<h2 id="自定义的数据结构"><a href="#自定义的数据结构" class="headerlink" title="自定义的数据结构"></a>自定义的数据结构</h2><p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p>
<h3 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span><span class="comment">/*...*/</span>&#125; accum, trans, *salesptr;</span><br><span class="line"><span class="comment">//两种定义相同，但下面一种更好</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span><span class="comment">/*...*/</span>&#125;;</span><br><span class="line">Sales_data  accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>

<p>类体定义<strong>成员</strong>，这个类只有<strong>数据成员</strong>。类体定义完成后相当与一个类型。</p>
<p>C++11新标准规定，可以为数据成员提供一个**类内初始值（in-class initializer)**。创建对象时,类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="使用Sale-data类"><a href="#使用Sale-data类" class="headerlink" title="使用Sale_data类"></a>使用Sale_data类</h3><p><strong>总体轮廓</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sales_data.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	sales_data datal, data2;</span><br><span class="line">	<span class="comment">//读入datal和data2的代码</span></span><br><span class="line">	<span class="comment">//检查datal 和data2的工SBN是否相同的代码</span></span><br><span class="line">	<span class="comment">//如果相同，求datal和data2的总和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读入数据并处理</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price = <span class="number">0</span>; <span class="comment">//书的单价，用于计算销售收入</span></span><br><span class="line"><span class="comment">//读入第1笔交易:ISBN、销售数量、单价</span></span><br><span class="line">std: :cin &gt;&gt; data1.bookNo &gt;&gt; datal.units_sold &gt;&gt; price;</span><br><span class="line"><span class="comment">//计算销售收入</span></span><br><span class="line">data1.revenue = data1.units_sold *price;</span><br></pre></td></tr></table></figure>

<p><strong>输出和</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data1 . bookNo m= data2.bookNo)&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> totalCnt = data1.units_sold + data2.units_sold;</span><br><span class="line">	<span class="keyword">double</span> totalRevenue = data1.revenue + data2.revenue;</span><br><span class="line">	<span class="comment">//输出:ISBN、总销售量、总销售额、平均价格</span></span><br><span class="line">	std::cout &lt;&lt; data1.bookNo&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; totalCnt&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (totalcnt != o)</span><br><span class="line">		std:: cout &lt;&lt; totalRevenue/totalCnt &lt;&lt; std: :endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		std: :cout &lt;&lt;<span class="string">&quot; (no sales) &quot;</span> &lt;&lt; std: :endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//标示成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//两笔交易的ISBN不一样</span></span><br><span class="line">	std: :cerr &lt;&lt;<span class="string">&quot;Data must refer to the same ISBN&quot;</span> &lt;&lt;std: :endl;</span><br><span class="line">	<span class="keyword">return</span> -l;<span class="comment">//标示失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>头文件一旦改变，相关源文件必须重新编译以获取更新过的声明。</p>
<p><strong>预处理概述</strong></p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器(preprocessor)<strong>，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。例如#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。<br>C++程序还会用到的一项预处理功能是头文件</strong>保护符(header guard)<strong>，头文件保护符依赖于预处理变量。预处理变量有两种状态:已定义和未定义。</strong>#define</strong>指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:<strong>#ifdef</strong>当且仅当变量已定义时为真，**#ifndef<strong>当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到</strong>#endif**指令为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sales_data</span> &#123;</span></span><br><span class="line">	std : : string bookNo ;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><label style="color:red">这里只需要知道无论你的程序多简单，习惯性的加上就好。</label></p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>类型规定了其对象的存储要求和所能执行的操作。C++语言提供了一套基础内置类型，如int和char等，这些类型与实现它们的机器硬件密切相关。类型分为非常量和常量，一个常量对象必须初始化,而且一旦初始化其值就不能再改变。此外，还可以定义复合类型,如指针和引用等。复合类型的定义以其他类型为基础。<br>C++语言允许用户以类的形式自定义类型。C++库通过类提供了一套高级抽象类型,如输入输出和string等。</p>
]]></content>
      <categories>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo博客中文无法正常显示问题</title>
    <url>/2021/11/08/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="情况一：没有在站点配置文件或主题配置文件中将语言设置为中文"><a href="#情况一：没有在站点配置文件或主题配置文件中将语言设置为中文" class="headerlink" title="情况一：没有在站点配置文件或主题配置文件中将语言设置为中文"></a>情况一：没有在站点配置文件或主题配置文件中将语言设置为中文</h1><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>1：打开bolg目录下的_config.yml文件。</p>
<span id="more"></span>

<p>2：找到language字段，添加zh-CN，如下</p>
<p><code>language: zh-CN </code></p>
<p>3： 主题配置文件以next为例，打开\blog\themes\next_config.yml文件。</p>
<p>4： 同样进行如上操作</p>
<h3 id="这里建议直接创建Mardown文件"><a href="#这里建议直接创建Mardown文件" class="headerlink" title="这里建议直接创建Mardown文件"></a>这里建议直接创建Mardown文件</h3><p>以下为方法链接，并附上软件下载链接</p>
<p>[右键新建markdown文件]<a href="https://blog.csdn.net/huangjun0210/article/details/105952385">https://blog.csdn.net/huangjun0210/article/details/105952385</a></p>
<p>链接：<a href="https://pan.baidu.com/s/118PmZiKsJV8fLqjFd9X1JA">https://pan.baidu.com/s/118PmZiKsJV8fLqjFd9X1JA</a><br>提取码：5p7c<br>–来自百度网盘超级会员V4的分享</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>类名冲突问题</title>
    <url>/2021/11/07/%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>一般来说，leetcode给出的测试用例数量足够多，覆盖范围足够广，基本可以证明代码正确</strong></p>
<p>​        </p>
<p>​        这里可能是因为命名空间的问题，因为力扣中所有类名均为Solution，倘若在同一源文件下可能会造成命名冲突，这里有两种解决方法。</p>
<span id="more"></span>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>​        更改类名，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;```</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>​        添加命名空间，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> letter &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/11/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="hello-大家好，这是我的第一篇博客"><a href="#hello-大家好，这是我的第一篇博客" class="headerlink" title="hello! 大家好，这是我的第一篇博客"></a>hello! 大家好，这是我的第一篇博客</h1><h2 id="1、-我是谁？"><a href="#1、-我是谁？" class="headerlink" title="1、 我是谁？"></a>1、 我是谁？</h2><p>​        我是谁不重要。重要的是我想成为知识的传播者。</p>
<span id="more"></span>

<h2 id="2、创建博客的初衷"><a href="#2、创建博客的初衷" class="headerlink" title="2、创建博客的初衷"></a>2、创建博客的初衷</h2><p>​        我在解决一个又一个的问题的时候，各种博客、平台帮了我很多，这其中有很多非常详细且友好的帖子，但也有充斥各种问题的帖子，如语意不清、啰嗦、付费、繁杂等等，虽然最后我还是解决了这些问题，我不希望获得知识的路上充满荆棘，所以我创建了自己的博客，希望分享我所获得的知识，同时把我解决问题的过程、思考、以及总结的经验保存下来。为了你，也为了以后的我不再重蹈覆辙。</p>
<h2 id="3、我的计划"><a href="#3、我的计划" class="headerlink" title="3、我的计划"></a>3、我的计划</h2><p>​        我计划首先分享我在阅读书籍中、以前unity项目中、刷题中、以及搭建博客中的遇到的问题，同时因为我目前从事的是忆阻器件的制备，我也会分享在半导体方向所收获的知识（这方面的知识网上尤其的少）。也希望自己能够再接再厉。学更多的知识、看更远的风景。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
